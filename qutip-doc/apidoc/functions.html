


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Functions &mdash; QuTiP 4.1 Documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="QuTiP 4.1 Documentation" href="../index.html"/>
        <link rel="up" title="API documentation" href="apidoc.html"/>
        <link rel="next" title="Change Log" href="../changelog.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> QuTiP: Quantum Toolbox in Python
          

          
          </a>

          
            
            
              <div class="version">
                4.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../frontmatter.html">Frontmatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guide/guide.html">Users Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="apidoc.html">API documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#manipulation-and-creation-of-states-and-operators">Manipulation and Creation of States and Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quantum-states">Quantum States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.operators">Quantum Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.random_objects">Random Operators and States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.three_level_atom">Three-Level Atoms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.superoperator">Superoperators and Liouvillians</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.superop_reps">Superoperator Representations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#functions-acting-on-states-and-operators">Functions acting on states and operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.tensor">Tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.expect">Expectation Values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.partial_transpose">Partial Transpose</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.entropy">Entropy Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.metrics">Density Matrix Metrics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.continuous_variables">Continous Variables</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dynamics-and-time-evolution">Dynamics and Time-Evolution</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.sesolve">Schrödinger Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.mesolve">Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.mcsolve">Monte Carlo Evolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.essolve">Exponential Series</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.bloch_redfield">Bloch-Redfield Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.floquet">Floquet States and Floquet-Markov Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.stochastic">Stochastic Schrödinger Equation and Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.correlation">Correlation Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.steadystate">Steady-state Solvers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.propagator">Propagators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.rhs_generate">Time-dependent problems</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#visualization">Visualization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.wigner">Pseudoprobability Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#graphs-and-visualization">Graphs and Visualization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.tomography">Quantum Process Tomography</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#quantum-information-processing">Quantum Information Processing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.qip.gates">Gates</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.qip.qubits">Qubits</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.qip.algorithms.qft">Algorithms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-qutip.nonmarkov.transfertensor">non-Markovian Solvers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-qutip.control.pulseoptim">Optimal control</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#grape">GRAPE</a></li>
<li class="toctree-l4"><a class="reference internal" href="#crab">CRAB</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#utilitiy-functions">Utilitiy Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.graph">Graph Theory Routines</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.utilities">Utility Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.fileio">File I/O Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.parallel">Parallelization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.ipynbtools">IPython Notebook Tools</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip">Miscellaneous</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../biblio.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QuTiP: Quantum Toolbox in Python</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="apidoc.html">API documentation</a> &raquo;</li>
        
      <li>Functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="functions">
<span id="id1"></span><h1>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="manipulation-and-creation-of-states-and-operators">
<h2>Manipulation and Creation of States and Operators<a class="headerlink" href="#manipulation-and-creation-of-states-and-operators" title="Permalink to this headline">¶</a></h2>
<div class="section" id="quantum-states">
<h3>Quantum States<a class="headerlink" href="#quantum-states" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-qutip.states"></span><dl class="function">
<dt id="qutip.states.basis">
<code class="descname">basis</code><span class="sig-paren">(</span><em>N</em>, <em>n=0</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the vector representation of a Fock state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of Fock states in Hilbert space.</p>
</div></blockquote>
<p><strong>n</strong> : int</p>
<blockquote>
<div><p>Integer corresponding to desired number state, defaults
to 0 if omitted.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the state.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote class="last">
<div><p>Qobj representing the requested number state <code class="docutils literal"><span class="pre">|n&gt;</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>A subtle incompatibility with the quantum optics toolbox: In QuTiP:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">ground</span> <span class="n">state</span>
</pre></div>
</div>
<p>but in the qotoolbox:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">ground</span> <span class="n">state</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 1.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.bell_state">
<code class="descname">bell_state</code><span class="sig-paren">(</span><em>state=‘00’</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#bell_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.bell_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Bell state:</p>
<blockquote>
<div><a href="#id2"><span class="problematic" id="id3">|</span></a>B00&gt; = 1 / sqrt(2)*[<a href="#id4"><span class="problematic" id="id5">|</span></a>0&gt;|0&gt;+|1&gt;|1&gt;]
<a href="#id6"><span class="problematic" id="id7">|</span></a>B01&gt; = 1 / sqrt(2)*[<a href="#id8"><span class="problematic" id="id9">|</span></a>0&gt;|0&gt;-<a href="#id10"><span class="problematic" id="id11">|</span></a>1&gt;|1&gt;]
<a href="#id12"><span class="problematic" id="id13">|</span></a>B10&gt; = 1 / sqrt(2)*[<a href="#id14"><span class="problematic" id="id15">|</span></a>0&gt;|1&gt;+|1&gt;|0&gt;]
<a href="#id16"><span class="problematic" id="id17">|</span></a>B11&gt; = 1 / sqrt(2)*[<a href="#id18"><span class="problematic" id="id19">|</span></a>0&gt;|1&gt;-<a href="#id20"><span class="problematic" id="id21">|</span></a>1&gt;|0&gt;]</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Bell_state</strong> : qobj</p>
<blockquote class="last">
<div><p>Bell state</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.bra">
<code class="descname">bra</code><span class="sig-paren">(</span><em>seq</em>, <em>dim=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#bra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.bra" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a multiparticle bra state for a list or string,
where each element stands for state of the respective particle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seq</strong> : str / list of ints or characters</p>
<blockquote>
<div><p>Each element defines state of the respective particle.
(e.g. [1,1,0,1] or a string “1101”).
For qubits it is also possible to use the following conventions:
- ‘g’/’e’ (ground and excited state)
- ‘u’/’d’ (spin up and down)
- ‘H’/’V’ (horizontal and vertical polarization)
Note: for dimension &gt; 9 you need to use a list.</p>
</div></blockquote>
<p><strong>dim</strong> : int (default: 2) / list of ints</p>
<blockquote>
<div><p>Space dimension for each particle:
int if there are the same, list if they are different.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>bra</strong> : qobj</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;10&quot;</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.  1.  0.]]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;Hue&quot;</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.  0.  0.  0.  0.  0.  0.]]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;12&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.  0.  0.  0.  1.  0.  0.  0.]]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;31&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.  0.  0.  0.  0.  0.  1.  0.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.coherent">
<code class="descname">coherent</code><span class="sig-paren">(</span><em>N</em>, <em>alpha</em>, <em>offset=0</em>, <em>method=’operator’</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#coherent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.coherent" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a coherent state with eigenvalue alpha.</p>
<p>Constructed using displacement operator on vacuum state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of Fock states in Hilbert space.</p>
</div></blockquote>
<p><strong>alpha</strong> : float/complex</p>
<blockquote>
<div><p>Eigenvalue of coherent state.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the state. Using a non-zero offset will make the
default method ‘analytic’.</p>
</div></blockquote>
<p><strong>method</strong> : string {‘operator’, ‘analytic’}</p>
<blockquote>
<div><p>Method for generating coherent state.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote class="last">
<div><p>Qobj quantum object for coherent state</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Select method ‘operator’ (default) or ‘analytic’. With the
‘operator’ method, the coherent state is generated by displacing
the vacuum state using the displacement operator defined in the
truncated Hilbert space of size ‘N’. This method guarantees that the
resulting state is normalized. With ‘analytic’ method the coherent state
is generated using the analytical formula for the coherent state
coefficients in the Fock basis. This method does not guarantee that the
state is normalized if truncated to a small number of Fock states,
but would in that case give more accurate coefficients.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coherent</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mf">0.25</span><span class="n">j</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[  9.69233235e-01+0.j        ]</span>
<span class="go"> [  0.00000000e+00+0.24230831j]</span>
<span class="go"> [ -4.28344935e-02+0.j        ]</span>
<span class="go"> [  0.00000000e+00-0.00618204j]</span>
<span class="go"> [  7.80904967e-04+0.j        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.coherent_dm">
<code class="descname">coherent_dm</code><span class="sig-paren">(</span><em>N</em>, <em>alpha</em>, <em>offset=0</em>, <em>method=’operator’</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#coherent_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.coherent_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix representation of a coherent state.</p>
<p>Constructed via outer product of <a class="reference internal" href="#qutip.states.coherent" title="qutip.states.coherent"><code class="xref py py-func docutils literal"><span class="pre">qutip.states.coherent</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of Fock states in Hilbert space.</p>
</div></blockquote>
<p><strong>alpha</strong> : float/complex</p>
<blockquote>
<div><p>Eigenvalue for coherent state.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the state.</p>
</div></blockquote>
<p><strong>method</strong> : string {‘operator’, ‘analytic’}</p>
<blockquote>
<div><p>Method for generating coherent density matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dm</strong> : qobj</p>
<blockquote class="last">
<div><p>Density matrix representation of coherent state.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Select method ‘operator’ (default) or ‘analytic’. With the
‘operator’ method, the coherent density matrix is generated by displacing
the vacuum state using the displacement operator defined in the
truncated Hilbert space of size ‘N’. This method guarantees that the
resulting density matrix is normalized. With ‘analytic’ method the coherent
density matrix is generated using the analytical formula for the coherent
state coefficients in the Fock basis. This method does not guarantee that
the state is normalized if truncated to a small number of Fock states,
but would in that case give more accurate coefficients.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coherent_dm</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.25</span><span class="n">j</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.93941695+0.j          0.00000000-0.23480733j -0.04216943+0.j        ]</span>
<span class="go"> [ 0.00000000+0.23480733j  0.05869011+0.j          0.00000000-0.01054025j]</span>
<span class="go"> [-0.04216943+0.j          0.00000000+0.01054025j  0.00189294+0.j        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.enr_state_dictionaries">
<code class="descname">enr_state_dictionaries</code><span class="sig-paren">(</span><em>dims</em>, <em>excitations</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#enr_state_dictionaries"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.enr_state_dictionaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of states, and lookup-dictionaries for translating
a state tuple to a state index, and vice versa, for a system with a given
number of components and maximum number of excitations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims: list</strong></p>
<blockquote>
<div><p>A list with the number of states in each sub-system.</p>
</div></blockquote>
<p><strong>excitations</strong> : integer</p>
<blockquote>
<div><p>The maximum numbers of dimension</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">nstates, state2idx, idx2state: integer, dict, dict</p>
<blockquote class="last">
<div><p>The number of states <cite>nstates</cite>, a dictionary for looking up state
indices from a state tuple, and a dictionary for looking up state
state tuples from state indices.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.enr_thermal_dm">
<code class="descname">enr_thermal_dm</code><span class="sig-paren">(</span><em>dims</em>, <em>excitations</em>, <em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#enr_thermal_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.enr_thermal_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the density operator for a thermal state in the excitation-number-
restricted state space defined by the <cite>dims</cite> and <cite>exciations</cite> arguments.
See the documentation for enr_fock for a more detailed description of
these arguments. The temperature of each mode in dims is specified by
the average number of excitatons <cite>n</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list</p>
<blockquote>
<div><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</div></blockquote>
<p><strong>excitations</strong> : integer</p>
<blockquote>
<div><p>The maximum number of excitations that are to be included in the
state space.</p>
</div></blockquote>
<p><strong>n</strong> : integer</p>
<blockquote>
<div><p>The average number of exciations in the thermal state. <cite>n</cite> can be
a float (which then applies to each mode), or a list/array of the same
length as dims, in which each element corresponds specifies the
temperature of the corresponding mode.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dm</strong> : Qobj</p>
<blockquote class="last">
<div><p>Thermal state density matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.enr_fock">
<code class="descname">enr_fock</code><span class="sig-paren">(</span><em>dims</em>, <em>excitations</em>, <em>state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#enr_fock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.enr_fock" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the Fock state representation in a excitation-number restricted
state space. The <cite>dims</cite> argument is a list of integers that define the
number of quantums states of each component of a composite quantum system,
and the <cite>excitations</cite> specifies the maximum number of excitations for
the basis states that are to be included in the state space. The <cite>state</cite>
argument is a tuple of integers that specifies the state (in the number
basis representation) for which to generate the Fock state representation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list</p>
<blockquote>
<div><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</div></blockquote>
<p><strong>excitations</strong> : integer</p>
<blockquote>
<div><p>The maximum number of excitations that are to be included in the
state space.</p>
</div></blockquote>
<p><strong>state</strong> : list of integers</p>
<blockquote>
<div><p>The state in the number basis representation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ket</strong> : Qobj</p>
<blockquote class="last">
<div><p>A Qobj instance that represent a Fock state in the exication-number-
restricted state space defined by <cite>dims</cite> and <cite>exciations</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.fock">
<code class="descname">fock</code><span class="sig-paren">(</span><em>N</em>, <em>n=0</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#fock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.fock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bosonic Fock (number) state.</p>
<p>Same as <a class="reference internal" href="#qutip.states.basis" title="qutip.states.basis"><code class="xref py py-func docutils literal"><span class="pre">qutip.states.basis</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of states in the Hilbert space.</p>
</div></blockquote>
<p><strong>n</strong> : int</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">int</span></code> for desired number state, defaults to 0 if omitted.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Requested number state <span class="math">\(\left|n\right&gt;\)</span>.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fock</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [1]], shape = [4, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.fock_dm">
<code class="descname">fock_dm</code><span class="sig-paren">(</span><em>N</em>, <em>n=0</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#fock_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.fock_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix representation of a Fock state</p>
<p>Constructed via outer product of <a class="reference internal" href="#qutip.states.fock" title="qutip.states.fock"><code class="xref py py-func docutils literal"><span class="pre">qutip.states.fock</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of Fock states in Hilbert space.</p>
</div></blockquote>
<p><strong>n</strong> : int</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">int</span></code> for desired number state, defaults to 0 if omitted.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dm</strong> : qobj</p>
<blockquote class="last">
<div><p>Density matrix representation of Fock state.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.ghz_state">
<code class="descname">ghz_state</code><span class="sig-paren">(</span><em>N=3</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#ghz_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.ghz_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the N-qubit GHZ-state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int (default=3)</p>
<blockquote>
<div><p>Number of qubits in state</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>G</strong> : qobj</p>
<blockquote class="last">
<div><p>N-qubit GHZ-state</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.maximally_mixed_dm">
<code class="descname">maximally_mixed_dm</code><span class="sig-paren">(</span><em>N</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#maximally_mixed_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.maximally_mixed_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximally mixed density matrix for a Hilbert space of
dimension N.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of basis states in Hilbert space.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dm</strong> : qobj</p>
<blockquote class="last">
<div><p>Thermal state density matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.ket">
<code class="descname">ket</code><span class="sig-paren">(</span><em>seq</em>, <em>dim=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#ket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.ket" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a multiparticle ket state for a list or string,
where each element stands for state of the respective particle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seq</strong> : str / list of ints or characters</p>
<blockquote>
<div><p>Each element defines state of the respective particle.
(e.g. [1,1,0,1] or a string “1101”).
For qubits it is also possible to use the following conventions:
- ‘g’/’e’ (ground and excited state)
- ‘u’/’d’ (spin up and down)
- ‘H’/’V’ (horizontal and vertical polarization)
Note: for dimension &gt; 9 you need to use a list.</p>
</div></blockquote>
<p><strong>dim</strong> : int (default: 2) / list of ints</p>
<blockquote>
<div><p>Space dimension for each particle:
int if there are the same, list if they are different.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ket</strong> : qobj</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;10&quot;</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;Hue&quot;</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;12&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;31&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.ket2dm">
<code class="descname">ket2dm</code><span class="sig-paren">(</span><em>Q</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#ket2dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.ket2dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes input ket or bra vector and returns density matrix
formed by outer product.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Q</strong> : qobj</p>
<blockquote>
<div><p>Ket or bra type quantum object.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dm</strong> : qobj</p>
<blockquote class="last">
<div><p>Density matrix formed by outer product of <cite>Q</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2dm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.phase_basis">
<code class="descname">phase_basis</code><span class="sig-paren">(</span><em>N</em>, <em>m</em>, <em>phi0=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#phase_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.phase_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis vector for the mth phase of the Pegg-Barnett phase operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of basis vectors in Hilbert space.</p>
</div></blockquote>
<p><strong>m</strong> : int</p>
<blockquote>
<div><p>Integer corresponding to the mth discrete phase phi_m=phi0+2*pi*m/N</p>
</div></blockquote>
<p><strong>phi0</strong> : float (default=0)</p>
<blockquote>
<div><p>Reference phase angle.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote class="last">
<div><p>Ket vector for mth Pegg-Barnett phase operator basis state.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The Pegg-Barnett basis states form a complete set over the truncated
Hilbert space.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.states.projection">
<code class="descname">projection</code><span class="sig-paren">(</span><em>N</em>, <em>n</em>, <em>m</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#projection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.projection" title="Permalink to this definition">¶</a></dt>
<dd><p>The projection operator that projects state <span class="math">\(|m&gt;\)</span> on state <span class="math">\(|n&gt;\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of basis states in Hilbert space.</p>
</div></blockquote>
<p><strong>n, m</strong> : float</p>
<blockquote>
<div><p>The number states in the projection.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the projector.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Requested projection operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.qutrit_basis">
<code class="descname">qutrit_basis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#qutrit_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.qutrit_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis states for a three level system (qutrit)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>qstates</strong> : array</p>
<blockquote class="last">
<div><p>Array of qutrit basis vectors</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.singlet_state">
<code class="descname">singlet_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#singlet_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.singlet_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the two particle singlet-state:</p>
<blockquote>
<div><a href="#id22"><span class="problematic" id="id23">|</span></a>S&gt;=1/sqrt(2)*[<a href="#id24"><span class="problematic" id="id25">|</span></a>0&gt;|1&gt;-<a href="#id26"><span class="problematic" id="id27">|</span></a>1&gt;|0&gt;]</div></blockquote>
<p>that is identical to the fourth bell state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Bell_state</strong> : qobj</p>
<blockquote class="last">
<div><p><a href="#id28"><span class="problematic" id="id29">|</span></a>B11&gt; Bell state</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.spin_state">
<code class="descname">spin_state</code><span class="sig-paren">(</span><em>j</em>, <em>m</em>, <em>type=’ket’</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#spin_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.spin_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the spin state <a href="#id30"><span class="problematic" id="id31">|</span></a>j, m&gt;, i.e.  the eigenstate
of the spin-j Sz operator with eigenvalue m.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>j</strong> : float</p>
<blockquote>
<div><p>The spin of the state ().</p>
</div></blockquote>
<p><strong>m</strong> : int</p>
<blockquote>
<div><p>Eigenvalue of the spin-j Sz operator.</p>
</div></blockquote>
<p><strong>type</strong> : string {‘ket’, ‘bra’, ‘dm’}</p>
<blockquote>
<div><p>Type of state to generate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote class="last">
<div><p>Qobj quantum object for spin state</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.spin_coherent">
<code class="descname">spin_coherent</code><span class="sig-paren">(</span><em>j</em>, <em>theta</em>, <em>phi</em>, <em>type=’ket’</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#spin_coherent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.spin_coherent" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the spin state <a href="#id32"><span class="problematic" id="id33">|</span></a>j, m&gt;, i.e.  the eigenstate
of the spin-j Sz operator with eigenvalue m.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>j</strong> : float</p>
<blockquote>
<div><p>The spin of the state.</p>
</div></blockquote>
<p><strong>theta</strong> : float</p>
<blockquote>
<div><p>Angle from z axis.</p>
</div></blockquote>
<p><strong>phi</strong> : float</p>
<blockquote>
<div><p>Angle from x axis.</p>
</div></blockquote>
<p><strong>type</strong> : string {‘ket’, ‘bra’, ‘dm’}</p>
<blockquote>
<div><p>Type of state to generate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote class="last">
<div><p>Qobj quantum object for spin coherent state</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_number_enumerate">
<code class="descname">state_number_enumerate</code><span class="sig-paren">(</span><em>dims</em>, <em>excitations=None</em>, <em>state=None</em>, <em>idx=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#state_number_enumerate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.state_number_enumerate" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator that enumerate all the state number arrays (quantum numbers on
the form [n1, n2, n3, …]) for a system with dimensions given by dims.</p>
<p class="rubric">Example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">state_number_enumerate</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="go">[ 0  0 ]</span>
<span class="go">[ 0  1 ]</span>
<span class="go">[ 1  0 ]</span>
<span class="go">[ 1  1 ]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list or array</p>
<blockquote>
<div><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</div></blockquote>
<p><strong>state</strong> : list</p>
<blockquote>
<div><p>Current state in the iteration. Used internally.</p>
</div></blockquote>
<p><strong>excitations</strong> : integer (None)</p>
<blockquote>
<div><p>Restrict state space to states with excitation numbers below or
equal to this value.</p>
</div></blockquote>
<p><strong>idx</strong> : integer</p>
<blockquote>
<div><p>Current index in the iteration. Used internally.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state_number</strong> : list</p>
<blockquote class="last">
<div><p>Successive state number arrays that can be used in loops and other
iterations, using standard state enumeration <em>by definition</em>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_number_index">
<code class="descname">state_number_index</code><span class="sig-paren">(</span><em>dims</em>, <em>state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#state_number_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.state_number_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of a quantum state corresponding to state,
given a system with dimensions given by dims.</p>
<p class="rubric">Example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_number_index</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">6</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list or array</p>
<blockquote>
<div><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</div></blockquote>
<p><strong>state</strong> : list</p>
<blockquote>
<div><p>State number array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>idx</strong> : int</p>
<blockquote class="last">
<div><p>The index of the state given by <cite>state</cite> in standard enumeration
ordering.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_index_number">
<code class="descname">state_index_number</code><span class="sig-paren">(</span><em>dims</em>, <em>index</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#state_index_number"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.state_index_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a quantum number representation given a state index, for a system
of composite structure defined by dims.</p>
<p class="rubric">Example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_index_number</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">[1, 1, 0]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list or array</p>
<blockquote>
<div><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</div></blockquote>
<p><strong>index</strong> : integer</p>
<blockquote>
<div><p>The index of the state in standard enumeration ordering.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : list</p>
<blockquote class="last">
<div><p>The state number array corresponding to index <cite>index</cite> in standard
enumeration ordering.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_number_qobj">
<code class="descname">state_number_qobj</code><span class="sig-paren">(</span><em>dims</em>, <em>state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#state_number_qobj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.state_number_qobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Qobj representation of a quantum state specified by the state
array <cite>state</cite>.</p>
<p class="rubric">Example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_number_qobj</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list or array</p>
<blockquote>
<div><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</div></blockquote>
<p><strong>state</strong> : list</p>
<blockquote>
<div><p>State number array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj.qobj</span></code></p>
<blockquote class="last">
<div><p>The state as a <code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj.qobj</span></code> instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.thermal_dm">
<code class="descname">thermal_dm</code><span class="sig-paren">(</span><em>N</em>, <em>n</em>, <em>method=’operator’</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#thermal_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.thermal_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix for a thermal state of n particles</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of basis states in Hilbert space.</p>
</div></blockquote>
<p><strong>n</strong> : float</p>
<blockquote>
<div><p>Expectation value for number of particles in thermal state.</p>
</div></blockquote>
<p><strong>method</strong> : string {‘operator’, ‘analytic’}</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">string</span></code> that sets the method used to generate the
thermal state probabilities</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dm</strong> : qobj</p>
<blockquote class="last">
<div><p>Thermal state density matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The ‘operator’ method (default) generates
the thermal state using the truncated number operator <code class="docutils literal"><span class="pre">num(N)</span></code>. This
is the method that should be used in computations. The
‘analytic’ method uses the analytic coefficients derived in
an infinite Hilbert space. The analytic form is not necessarily normalized,
if truncated too aggressively.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">thermal_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.51612903  0.          0.          0.          0.        ]</span>
<span class="go"> [ 0.          0.25806452  0.          0.          0.        ]</span>
<span class="go"> [ 0.          0.          0.12903226  0.          0.        ]</span>
<span class="go"> [ 0.          0.          0.          0.06451613  0.        ]</span>
<span class="go"> [ 0.          0.          0.          0.          0.03225806]]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">thermal_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;analytic&#39;</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.5      0.       0.       0.       0.     ]</span>
<span class="go"> [ 0.       0.25     0.       0.       0.     ]</span>
<span class="go"> [ 0.       0.       0.125    0.       0.     ]</span>
<span class="go"> [ 0.       0.       0.       0.0625   0.     ]</span>
<span class="go"> [ 0.       0.       0.       0.       0.03125]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.zero_ket">
<code class="descname">zero_ket</code><span class="sig-paren">(</span><em>N</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#zero_ket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.zero_ket" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the zero ket vector with shape Nx1 and
dimensions <cite>dims</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Hilbert space dimensionality</p>
</div></blockquote>
<p><strong>dims</strong> : list</p>
<blockquote>
<div><p>Optional dimensions if ket corresponds to
a composite Hilbert space.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>zero_ket</strong> : qobj</p>
<blockquote class="last">
<div><p>Zero ket on given Hilbert space.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.operators">
<span id="quantum-operators"></span><h3>Quantum Operators<a class="headerlink" href="#module-qutip.operators" title="Permalink to this headline">¶</a></h3>
<p>This module contains functions for generating Qobj representation of a variety
of commonly occuring quantum operators.</p>
<dl class="function">
<dt id="qutip.operators.charge">
<code class="descname">charge</code><span class="sig-paren">(</span><em>Nmax</em>, <em>Nmin=None</em>, <em>frac=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the diagonal charge operator over charge states
from Nmin to Nmax.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Nmax</strong> : int</p>
<blockquote>
<div><p>Maximum charge state to consider.</p>
</div></blockquote>
<p><strong>Nmin</strong> : int (default = -Nmax)</p>
<blockquote>
<div><p>Lowest charge state to consider.</p>
</div></blockquote>
<p><strong>frac</strong> : float (default = 1)</p>
<blockquote>
<div><p>Specify fractional charge if needed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>C</strong> : Qobj</p>
<blockquote class="last">
<div><p>Charge operator over [Nmin,Nmax].</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.commutator">
<code class="descname">commutator</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>kind=’normal’</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#commutator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.commutator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the commutator of kind <cite>kind</cite> (normal, anti) of the
two operators A and B.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.create">
<code class="descname">create</code><span class="sig-paren">(</span><em>N</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation (raising) operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Dimension of Hilbert space.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote>
<div><p>Qobj for raising operator.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote class="last">
<div><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">create</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 1.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  1.41421356+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  1.73205081+0.j  0.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>N</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#destroy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Destruction (lowering) operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Dimension of Hilbert space.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Qobj for lowering operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">destroy</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.00000000+0.j  1.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  1.41421356+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  1.73205081+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.displace">
<code class="descname">displace</code><span class="sig-paren">(</span><em>N</em>, <em>alpha</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#displace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.displace" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-mode displacement operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Dimension of Hilbert space.</p>
</div></blockquote>
<p><strong>alpha</strong> : float/complex</p>
<blockquote>
<div><p>Displacement amplitude.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Displacement operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">displace</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mf">0.25</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.96923323+0.j -0.24230859+0.j  0.04282883+0.j -0.00626025+0.j]</span>
<span class="go"> [ 0.24230859+0.j  0.90866411+0.j -0.33183303+0.j  0.07418172+0.j]</span>
<span class="go"> [ 0.04282883+0.j  0.33183303+0.j  0.84809499+0.j -0.41083747+0.j]</span>
<span class="go"> [ 0.00626025+0.j  0.07418172+0.j  0.41083747+0.j  0.90866411+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.enr_destroy">
<code class="descname">enr_destroy</code><span class="sig-paren">(</span><em>dims</em>, <em>excitations</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#enr_destroy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.enr_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate annilation operators for modes in a excitation-number-restricted
state space. For example, consider a system consisting of 4 modes, each
with 5 states. The total hilbert space size is 5**4 = 625. If we are
only interested in states that contain up to 2 excitations, we only need
to include states such as</p>
<blockquote>
<div>(0, 0, 0, 0)
(0, 0, 0, 1)
(0, 0, 0, 2)
(0, 0, 1, 0)
(0, 0, 1, 1)
(0, 0, 2, 0)
…</div></blockquote>
<p>This function creates annihilation operators for the 4 modes that act
within this state space:</p>
<blockquote>
<div>a1, a2, a3, a4 = enr_destroy([5, 5, 5, 5], excitations=2)</div></blockquote>
<p>From this point onwards, the annihiltion operators a1, …, a4 can be
used to setup a Hamiltonian, collapse operators and expectation-value
operators, etc., following the usual pattern.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list</p>
<blockquote>
<div><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</div></blockquote>
<p><strong>excitations</strong> : integer</p>
<blockquote>
<div><p>The maximum number of excitations that are to be included in the
state space.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>a_ops</strong> : list of qobj</p>
<blockquote class="last">
<div><p>A list of annihilation operators for each mode in the composite
quantum system described by dims.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.enr_identity">
<code class="descname">enr_identity</code><span class="sig-paren">(</span><em>dims</em>, <em>excitations</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#enr_identity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.enr_identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the identity operator for the excitation-number restricted
state space defined by the <cite>dims</cite> and <cite>exciations</cite> arguments. See the
docstring for enr_fock for a more detailed description of these arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list</p>
<blockquote>
<div><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</div></blockquote>
<p><strong>excitations</strong> : integer</p>
<blockquote>
<div><p>The maximum number of excitations that are to be included in the
state space.</p>
</div></blockquote>
<p><strong>state</strong> : list of integers</p>
<blockquote>
<div><p>The state in the number basis representation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>op</strong> : Qobj</p>
<blockquote class="last">
<div><p>A Qobj instance that represent the identity operator in the
exication-number-restricted state space defined by <cite>dims</cite> and
<cite>exciations</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.jmat">
<code class="descname">jmat</code><span class="sig-paren">(</span><em>j</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#jmat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.jmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Higher-order spin operators:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>j</strong> : float</p>
<blockquote>
<div><p>Spin of operator</p>
</div></blockquote>
<p><strong>args</strong> : str</p>
<blockquote>
<div><p>Which operator to return ‘x’,’y’,’z’,’+’,’-‘.
If no args given, then output is [‘x’,’y’,’z’]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>jmat</strong> : qobj / ndarray</p>
<blockquote class="last">
<div><p><code class="docutils literal"><span class="pre">qobj</span></code> for requested spin operator(s).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If no ‘args’ input, then returns array of [‘x’,’y’,’z’] operators.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">jmat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.          0.70710678  0.        ]</span>
<span class="go"> [ 0.70710678  0.          0.70710678]</span>
<span class="go"> [ 0.          0.70710678  0.        ]]</span>
<span class="go"> Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j          0.-0.70710678j  0.+0.j        ]</span>
<span class="go"> [ 0.+0.70710678j  0.+0.j          0.-0.70710678j]</span>
<span class="go"> [ 0.+0.j          0.+0.70710678j  0.+0.j        ]]</span>
<span class="go"> Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 0.  0.  0.]</span>
<span class="go"> [ 0.  0. -1.]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.num">
<code class="descname">num</code><span class="sig-paren">(</span><em>N</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#num"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.num" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object for number operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>The dimension of the Hilbert space.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">oper: qobj</p>
<blockquote class="last">
<div><p>Qobj for number operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[0 0 0 0]</span>
<span class="go"> [0 1 0 0]</span>
<span class="go"> [0 0 2 0]</span>
<span class="go"> [0 0 0 3]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.qeye">
<code class="descname">qeye</code><span class="sig-paren">(</span><em>N</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#qeye"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.qeye" title="Permalink to this definition">¶</a></dt>
<dd><p>Identity operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int or list of ints</p>
<blockquote>
<div><p>Dimension of Hilbert space. If provided as a list of ints,
then the dimension is the product over this list, but the
<code class="docutils literal"><span class="pre">dims</span></code> property of the new Qobj are set to this list.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Identity operator Qobj.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qeye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 0.  1.  0.]</span>
<span class="go"> [ 0.  0.  1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.identity">
<code class="descname">identity</code><span class="sig-paren">(</span><em>N</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#identity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Identity operator. Alternative name to <a class="reference internal" href="#qutip.operators.qeye" title="qutip.operators.qeye"><code class="xref py py-func docutils literal"><span class="pre">qeye</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int or list of ints</p>
<blockquote>
<div><p>Dimension of Hilbert space. If provided as a list of ints,
then the dimension is the product over this list, but the
<code class="docutils literal"><span class="pre">dims</span></code> property of the new Qobj are set to this list.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Identity operator Qobj.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.momentum">
<code class="descname">momentum</code><span class="sig-paren">(</span><em>N</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#momentum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.momentum" title="Permalink to this definition">¶</a></dt>
<dd><p>Momentum operator p=-1j/sqrt(2)*(a-a.dag())</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of Fock states in Hilbert space.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Momentum operator as Qobj.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.phase">
<code class="descname">phase</code><span class="sig-paren">(</span><em>N</em>, <em>phi0=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#phase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-mode Pegg-Barnett phase operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of basis states in Hilbert space.</p>
</div></blockquote>
<p><strong>phi0</strong> : float</p>
<blockquote>
<div><p>Reference phase.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Phase operator with respect to reference phase.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The Pegg-Barnett phase operator is Hermitian on a truncated Hilbert space.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.position">
<code class="descname">position</code><span class="sig-paren">(</span><em>N</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#position"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.position" title="Permalink to this definition">¶</a></dt>
<dd><p>Position operator x=1/sqrt(2)*(a+a.dag())</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of Fock states in Hilbert space.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Position operator as Qobj.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.qdiags">
<code class="descname">qdiags</code><span class="sig-paren">(</span><em>diagonals</em>, <em>offsets</em>, <em>dims=None</em>, <em>shape=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#qdiags"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.qdiags" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs an operator from an array of diagonals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>diagonals</strong> : sequence of array_like</p>
<blockquote>
<div><p>Array of elements to place along the selected diagonals.</p>
</div></blockquote>
<p><strong>offsets</strong> : sequence of ints</p>
<blockquote>
<div><dl class="docutils">
<dt>Sequence for diagonals to be set:</dt>
<dd><ul class="first last simple">
<li>k=0 main diagonal</li>
<li>k&gt;0 kth upper diagonal</li>
<li>k&lt;0 kth lower diagonal</li>
</ul>
</dd>
</dl>
</div></blockquote>
<p><strong>dims</strong> : list, optional</p>
<blockquote>
<div><p>Dimensions for operator</p>
</div></blockquote>
<p><strong>shape</strong> : list, tuple, optional</p>
<blockquote class="last">
<div><p>Shape of operator.  If omitted, a square operator large enough
to contain the diagonals is generated.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal"><span class="pre">scipy.sparse.diags</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>This function requires SciPy 0.11+.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qdiags</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)),</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.          1.          0.          0.        ]</span>
<span class="go"> [ 0.          0.          1.41421356  0.        ]</span>
<span class="go"> [ 0.          0.          0.          1.73205081]</span>
<span class="go"> [ 0.          0.          0.          0.        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.qutrit_ops">
<code class="descname">qutrit_ops</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#qutrit_ops"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.qutrit_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Operators for a three level system (qutrit).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">opers: array</p>
<blockquote class="last">
<div><p><cite>array</cite> of qutrit operators.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.qzero">
<code class="descname">qzero</code><span class="sig-paren">(</span><em>N</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#qzero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.qzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int or list of ints</p>
<blockquote>
<div><p>Dimension of Hilbert space. If provided as a list of ints,
then the dimension is the product over this list, but the
<code class="docutils literal"><span class="pre">dims</span></code> property of the new Qobj are set to this list.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>qzero</strong> : qobj</p>
<blockquote class="last">
<div><p>Zero operator Qobj.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmam">
<code class="descname">sigmam</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#sigmam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmam" title="Permalink to this definition">¶</a></dt>
<dd><p>Annihilation operator for Pauli spins.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmam</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.]</span>
<span class="go"> [ 1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmap">
<code class="descname">sigmap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#sigmap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation operator for Pauli spins.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmam</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.]</span>
<span class="go"> [ 0.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmax">
<code class="descname">sigmax</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#sigmax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli spin 1/2 sigma-x operator</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmax</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.]</span>
<span class="go"> [ 1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmay">
<code class="descname">sigmay</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#sigmay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmay" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli spin 1/2 sigma-y operator.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmay</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.-1.j]</span>
<span class="go"> [ 0.+1.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmaz">
<code class="descname">sigmaz</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#sigmaz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmaz" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli spin 1/2 sigma-z operator.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmaz</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.]</span>
<span class="go"> [ 0. -1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.spin_Jx">
<code class="descname">spin_Jx</code><span class="sig-paren">(</span><em>j</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#spin_Jx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.spin_Jx" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j x operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>j</strong> : float</p>
<blockquote>
<div><p>Spin of operator</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>op</strong> : Qobj</p>
<blockquote class="last">
<div><p><code class="docutils literal"><span class="pre">qobj</span></code> representation of the operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.spin_Jy">
<code class="descname">spin_Jy</code><span class="sig-paren">(</span><em>j</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#spin_Jy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.spin_Jy" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j y operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>j</strong> : float</p>
<blockquote>
<div><p>Spin of operator</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>op</strong> : Qobj</p>
<blockquote class="last">
<div><p><code class="docutils literal"><span class="pre">qobj</span></code> representation of the operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.spin_Jz">
<code class="descname">spin_Jz</code><span class="sig-paren">(</span><em>j</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#spin_Jz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.spin_Jz" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j z operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>j</strong> : float</p>
<blockquote>
<div><p>Spin of operator</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>op</strong> : Qobj</p>
<blockquote class="last">
<div><p><code class="docutils literal"><span class="pre">qobj</span></code> representation of the operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.spin_Jm">
<code class="descname">spin_Jm</code><span class="sig-paren">(</span><em>j</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#spin_Jm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.spin_Jm" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j annihilation operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>j</strong> : float</p>
<blockquote>
<div><p>Spin of operator</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>op</strong> : Qobj</p>
<blockquote class="last">
<div><p><code class="docutils literal"><span class="pre">qobj</span></code> representation of the operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.spin_Jp">
<code class="descname">spin_Jp</code><span class="sig-paren">(</span><em>j</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#spin_Jp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.spin_Jp" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j creation operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>j</strong> : float</p>
<blockquote>
<div><p>Spin of operator</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>op</strong> : Qobj</p>
<blockquote class="last">
<div><p><code class="docutils literal"><span class="pre">qobj</span></code> representation of the operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.squeeze">
<code class="descname">squeeze</code><span class="sig-paren">(</span><em>N</em>, <em>z</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#squeeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-mode Squeezing operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Dimension of hilbert space.</p>
</div></blockquote>
<p><strong>z</strong> : float/complex</p>
<blockquote>
<div><p>Squeezing parameter.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></code></p>
<blockquote class="last">
<div><p>Squeezing operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squeeze</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.98441565+0.j  0.00000000+0.j  0.17585742+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.95349007+0.j  0.00000000+0.j  0.30142443+0.j]</span>
<span class="go"> [-0.17585742+0.j  0.00000000+0.j  0.98441565+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.30142443+0.j  0.00000000+0.j  0.95349007+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.squeezing">
<code class="descname">squeezing</code><span class="sig-paren">(</span><em>a1</em>, <em>a2</em>, <em>z</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#squeezing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.squeezing" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized squeezing operator.</p>
<div class="math">
\[S(z) = \exp\left(\frac{1}{2}\left(z^*a_1a_2
- za_1^\dagger a_2^\dagger\right)\right)\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a1</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></code></p>
<blockquote>
<div><p>Operator 1.</p>
</div></blockquote>
<p><strong>a2</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></code></p>
<blockquote>
<div><p>Operator 2.</p>
</div></blockquote>
<p><strong>z</strong> : float/complex</p>
<blockquote>
<div><p>Squeezing parameter.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></code></p>
<blockquote class="last">
<div><p>Squeezing operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.tunneling">
<code class="descname">tunneling</code><span class="sig-paren">(</span><em>N</em>, <em>m=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#tunneling"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.tunneling" title="Permalink to this definition">¶</a></dt>
<dd><p>Tunneling operator with elements of the form
<span class="math">\(\sum |N&gt;&lt;N+m| + |N+m&gt;&lt;N|\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of basis states in Hilbert space.</p>
</div></blockquote>
<p><strong>m</strong> : int (default = 1)</p>
<blockquote>
<div><p>Number of excitations in tunneling event.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>T</strong> : Qobj</p>
<blockquote class="last">
<div><p>Tunneling operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.2.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="module-qutip.random_objects">
<span id="random-operators-and-states"></span><span id="functions-rand"></span><h3>Random Operators and States<a class="headerlink" href="#module-qutip.random_objects" title="Permalink to this headline">¶</a></h3>
<p>This module is a collection of random state and operator generators.
The sparsity of the ouput Qobj’s is controlled by varing the
<cite>density</cite> parameter.</p>
<dl class="function">
<dt id="qutip.random_objects.rand_dm">
<code class="descname">rand_dm</code><span class="sig-paren">(</span><em>N</em>, <em>density=0.75</em>, <em>pure=False</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random NxN density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int, ndarray, list</p>
<blockquote>
<div><p>If int, then shape of output operator. If list/ndarray then eigenvalues
of generated density matrix.</p>
</div></blockquote>
<p><strong>density</strong> : float</p>
<blockquote>
<div><p>Density between [0,1] of output density matrix.</p>
</div></blockquote>
<p><strong>dims</strong> : list</p>
<blockquote>
<div><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>NxN density matrix quantum operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For small density matrices., choosing a low density will result in an error
as no diagonal elements will be generated such that <span class="math">\(Tr(\rho)=1\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_dm_ginibre">
<code class="descname">rand_dm_ginibre</code><span class="sig-paren">(</span><em>N=2</em>, <em>rank=None</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_dm_ginibre"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_dm_ginibre" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Ginibre random density operator of dimension
<code class="docutils literal"><span class="pre">dim</span></code> and rank <code class="docutils literal"><span class="pre">rank</span></code> by using the algorithm of
<a class="reference internal" href="../biblio.html#bcsz08" id="id34">[BCSZ08]</a>. If <code class="docutils literal"><span class="pre">rank</span></code> is <cite>None</cite>, a full-rank
(Hilbert-Schmidt ensemble) random density operator will be
returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Dimension of the density operator to be returned.</p>
</div></blockquote>
<p><strong>dims</strong> : list</p>
<blockquote>
<div><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</div></blockquote>
<p><strong>rank</strong> : int or None</p>
<blockquote>
<div><p>Rank of the sampled density operator. If None, a full-rank
density operator is generated.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rho</strong> : Qobj</p>
<blockquote class="last">
<div><p>An N × N density operator sampled from the Ginibre
or Hilbert-Schmidt distribution.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_dm_hs">
<code class="descname">rand_dm_hs</code><span class="sig-paren">(</span><em>N=2</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_dm_hs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_dm_hs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Hilbert-Schmidt random density operator of dimension
<code class="docutils literal"><span class="pre">dim</span></code> and rank <code class="docutils literal"><span class="pre">rank</span></code> by using the algorithm of
<a class="reference internal" href="../biblio.html#bcsz08" id="id35">[BCSZ08]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Dimension of the density operator to be returned.</p>
</div></blockquote>
<p><strong>dims</strong> : list</p>
<blockquote>
<div><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rho</strong> : Qobj</p>
<blockquote class="last">
<div><p>A dim × dim density operator sampled from the Ginibre
or Hilbert-Schmidt distribution.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_herm">
<code class="descname">rand_herm</code><span class="sig-paren">(</span><em>N</em>, <em>density=0.75</em>, <em>dims=None</em>, <em>pos_def=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_herm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_herm" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random NxN sparse Hermitian quantum object.</p>
<p>If ‘N’ is an integer, uses <span class="math">\(H=0.5*(X+X^{+})\)</span> where <span class="math">\(X\)</span> is
a randomly generated quantum operator with a given <cite>density</cite>. Else uses
complex Jacobi rotations when ‘N’ is given by an array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int, list/ndarray</p>
<blockquote>
<div><p>If int, then shape of output operator. If list/ndarray then eigenvalues
of generated operator.</p>
</div></blockquote>
<p><strong>density</strong> : float</p>
<blockquote>
<div><p>Density between [0,1] of output Hermitian operator.</p>
</div></blockquote>
<p><strong>dims</strong> : list</p>
<blockquote>
<div><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</div></blockquote>
<p><strong>pos_def</strong> : bool (default=False)</p>
<blockquote>
<div><p>Return a positive semi-definite matrix (by diagonal dominance).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>NxN Hermitian quantum operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_ket">
<code class="descname">rand_ket</code><span class="sig-paren">(</span><em>N</em>, <em>density=1</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_ket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_ket" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random Nx1 sparse ket vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of rows for output quantum operator.</p>
</div></blockquote>
<p><strong>density</strong> : float</p>
<blockquote>
<div><p>Density between [0,1] of output ket state.</p>
</div></blockquote>
<p><strong>dims</strong> : list</p>
<blockquote>
<div><p>Left-dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N]].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Nx1 ket state quantum operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_ket_haar">
<code class="descname">rand_ket_haar</code><span class="sig-paren">(</span><em>N=2</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_ket_haar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_ket_haar" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Haar random pure state of dimension <code class="docutils literal"><span class="pre">dim</span></code> by
applying a Haar random unitary to a fixed pure state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Dimension of the state vector to be returned.</p>
</div></blockquote>
<p><strong>dims</strong> : list of ints, or None</p>
<blockquote>
<div><p>Left-dimensions of the resultant quantum object.
If None, [N] is used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>psi</strong> : Qobj</p>
<blockquote class="last">
<div><p>A random state vector drawn from the Haar measure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_unitary">
<code class="descname">rand_unitary</code><span class="sig-paren">(</span><em>N</em>, <em>density=0.75</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_unitary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random NxN sparse unitary quantum object.</p>
<p>Uses <span class="math">\(\exp(-iH)\)</span> where H is a randomly generated
Hermitian operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Shape of output quantum operator.</p>
</div></blockquote>
<p><strong>density</strong> : float</p>
<blockquote>
<div><p>Density between [0,1] of output Unitary operator.</p>
</div></blockquote>
<p><strong>dims</strong> : list</p>
<blockquote>
<div><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>NxN Unitary quantum operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_unitary_haar">
<code class="descname">rand_unitary_haar</code><span class="sig-paren">(</span><em>N=2</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_unitary_haar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_unitary_haar" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Haar random unitary matrix of dimension
<code class="docutils literal"><span class="pre">dim</span></code>, using the algorithm of <a class="reference internal" href="../biblio.html#mez07" id="id36">[Mez07]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Dimension of the unitary to be returned.</p>
</div></blockquote>
<p><strong>dims</strong> : list of lists of int, or None</p>
<blockquote>
<div><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>U</strong> : Qobj</p>
<blockquote class="last">
<div><p>Unitary of dims <code class="docutils literal"><span class="pre">[[dim],</span> <span class="pre">[dim]]</span></code> drawn from the Haar
measure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_super">
<code class="descname">rand_super</code><span class="sig-paren">(</span><em>N=5</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_super"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_super" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a randomly drawn superoperator acting on operators acting on
N dimensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Square root of the dimension of the superoperator to be returned.</p>
</div></blockquote>
<p><strong>dims</strong> : list</p>
<blockquote class="last">
<div><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[[N],[N]], [[N],[N]]].</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_super_bcsz">
<code class="descname">rand_super_bcsz</code><span class="sig-paren">(</span><em>N=2</em>, <em>enforce_tp=True</em>, <em>rank=None</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_super_bcsz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_super_bcsz" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random superoperator drawn from the Bruzda
et al ensemble for CPTP maps <a class="reference internal" href="../biblio.html#bcsz08" id="id37">[BCSZ08]</a>. Note that due to
finite numerical precision, for ranks less than full-rank,
zero eigenvalues may become slightly negative, such that the
returned operator is not actually completely positive.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Square root of the dimension of the superoperator to be returned.</p>
</div></blockquote>
<p><strong>enforce_tp</strong> : bool</p>
<blockquote>
<div><p>If True, the trace-preserving condition of <a class="reference internal" href="../biblio.html#bcsz08" id="id38">[BCSZ08]</a> is enforced;
otherwise only complete positivity is enforced.</p>
</div></blockquote>
<p><strong>rank</strong> : int or None</p>
<blockquote>
<div><p>Rank of the sampled superoperator. If None, a full-rank
superoperator is generated.</p>
</div></blockquote>
<p><strong>dims</strong> : list</p>
<blockquote>
<div><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[[N],[N]], [[N],[N]]].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rho</strong> : Qobj</p>
<blockquote class="last">
<div><p>A superoperator acting on vectorized dim × dim density operators,
sampled from the BCSZ distribution.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.three_level_atom">
<span id="three-level-atoms"></span><h3>Three-Level Atoms<a class="headerlink" href="#module-qutip.three_level_atom" title="Permalink to this headline">¶</a></h3>
<p>This module provides functions that are useful for simulating the
three level atom with QuTiP.  A three level atom (qutrit) has three states,
which are linked by dipole transitions so that 1 &lt;-&gt; 2 &lt;-&gt; 3.
Depending on there relative energies they are in the ladder, lambda or
vee configuration. The structure of the relevant operators is the same
for any of the three configurations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Ladder</span><span class="p">:</span>          <span class="n">Lambda</span><span class="p">:</span>                 <span class="n">Vee</span><span class="p">:</span>
                            <span class="o">|</span><span class="n">two</span><span class="o">&gt;</span>                       <span class="o">|</span><span class="n">three</span><span class="o">&gt;</span>
  <span class="o">-------|</span><span class="n">three</span><span class="o">&gt;</span>           <span class="o">-------</span>                      <span class="o">-------</span>
     <span class="o">|</span>                       <span class="o">/</span> \             <span class="o">|</span><span class="n">one</span><span class="o">&gt;</span>         <span class="o">/</span>
     <span class="o">|</span>                      <span class="o">/</span>   \           <span class="o">-------</span>       <span class="o">/</span>
     <span class="o">|</span>                     <span class="o">/</span>     \             \         <span class="o">/</span>
  <span class="o">-------|</span><span class="n">two</span><span class="o">&gt;</span>            <span class="o">/</span>       \             \       <span class="o">/</span>
     <span class="o">|</span>                   <span class="o">/</span>         \             \     <span class="o">/</span>
     <span class="o">|</span>                  <span class="o">/</span>           \             \   <span class="o">/</span>
     <span class="o">|</span>                 <span class="o">/</span>        <span class="o">--------</span>           \ <span class="o">/</span>
  <span class="o">-------|</span><span class="n">one</span><span class="o">&gt;</span>      <span class="o">-------</span>      <span class="o">|</span><span class="n">three</span><span class="o">&gt;</span>         <span class="o">-------</span>
                     <span class="o">|</span><span class="n">one</span><span class="o">&gt;</span>                       <span class="o">|</span><span class="n">two</span><span class="o">&gt;</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>The naming of qutip operators follows the convention in <a class="reference internal" href="#r1" id="id39">[R1]</a> .</p>
<table class="docutils citation" frame="void" id="r1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id39">[R1]</a></td><td>Shore, B. W., “The Theory of Coherent Atomic Excitation”,
Wiley, 1990.</td></tr>
</tbody>
</table>
<div class="admonition-notes admonition">
<p class="first admonition-title">Notes</p>
<p class="last">Contributed by Markus Baden, Oct. 07, 2011</p>
</div>
<dl class="function">
<dt id="qutip.three_level_atom.three_level_basis">
<code class="descname">three_level_basis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/three_level_atom.html#three_level_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.three_level_atom.three_level_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis states for a three level atom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>states</strong> : array</p>
<blockquote class="last">
<div><p><cite>array</cite> of three level atom basis vectors.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.three_level_atom.three_level_ops">
<code class="descname">three_level_ops</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/three_level_atom.html#three_level_ops"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.three_level_atom.three_level_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Operators for a three level system (qutrit)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ops</strong> : array</p>
<blockquote class="last">
<div><p><cite>array</cite> of three level operators.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.superoperator">
<span id="superoperators-and-liouvillians"></span><h3>Superoperators and Liouvillians<a class="headerlink" href="#module-qutip.superoperator" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.superoperator.operator_to_vector">
<code class="descname">operator_to_vector</code><span class="sig-paren">(</span><em>op</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#operator_to_vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.operator_to_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a vector representation of a quantum operator given
the matrix representation.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.vector_to_operator">
<code class="descname">vector_to_operator</code><span class="sig-paren">(</span><em>op</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#vector_to_operator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.vector_to_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a matrix representation given a quantum operator in
vector form.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.liouvillian">
<code class="descname">liouvillian</code><span class="sig-paren">(</span><em>H</em>, <em>c_ops=[]</em>, <em>data_only=False</em>, <em>chi=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#liouvillian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.liouvillian" title="Permalink to this definition">¶</a></dt>
<dd><p>Assembles the Liouvillian superoperator from a Hamiltonian
and a <code class="docutils literal"><span class="pre">list</span></code> of collapse operators. Like liouvillian, but with an
experimental implementation which avoids creating extra Qobj instances,
which can be advantageous for large systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : qobj</p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>c_ops</strong> : array_like</p>
<blockquote>
<div><p>A <code class="docutils literal"><span class="pre">list</span></code> or <code class="docutils literal"><span class="pre">array</span></code> of collapse operators.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>L</strong> : qobj</p>
<blockquote class="last">
<div><p>Liouvillian superoperator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.spost">
<code class="descname">spost</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#spost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.spost" title="Permalink to this definition">¶</a></dt>
<dd><p>Superoperator formed from post-multiplication by operator A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>Quantum operator for post multiplication.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>super</strong> : qobj</p>
<blockquote class="last">
<div><p>Superoperator formed from input qauntum object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.spre">
<code class="descname">spre</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#spre"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.spre" title="Permalink to this definition">¶</a></dt>
<dd><p>Superoperator formed from pre-multiplication by operator A.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>Quantum operator for pre-multiplication.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">super :qobj</p>
<blockquote class="last">
<div><p>Superoperator formed from input quantum object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.sprepost">
<code class="descname">sprepost</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#sprepost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.sprepost" title="Permalink to this definition">¶</a></dt>
<dd><p>Superoperator formed from pre-multiplication by operator A and post-
multiplication of operator B.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : Qobj</p>
<blockquote>
<div><p>Quantum operator for pre-multiplication.</p>
</div></blockquote>
<p><strong>B</strong> : Qobj</p>
<blockquote>
<div><p>Quantum operator for post-multiplication.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>super</strong> : Qobj</p>
<blockquote class="last">
<div><p>Superoperator formed from input quantum objects.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.lindblad_dissipator">
<code class="descname">lindblad_dissipator</code><span class="sig-paren">(</span><em>a</em>, <em>b=None</em>, <em>data_only=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#lindblad_dissipator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.lindblad_dissipator" title="Permalink to this definition">¶</a></dt>
<dd><p>Lindblad dissipator (generalized) for a single pair of collapse operators
(a, b), or for a single collapse operator (a) when b is not specified:</p>
<div class="math">
\[\mathcal{D}[a,b]\rho = a \rho b^\dagger -
\frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : qobj</p>
<blockquote>
<div><p>Left part of collapse operator.</p>
</div></blockquote>
<p><strong>b</strong> : qobj (optional)</p>
<blockquote>
<div><p>Right part of collapse operator. If not specified, b defaults to a.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>D</strong> : qobj</p>
<blockquote class="last">
<div><p>Lindblad dissipator superoperator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.superop_reps">
<span id="superoperator-representations"></span><h3>Superoperator Representations<a class="headerlink" href="#module-qutip.superop_reps" title="Permalink to this headline">¶</a></h3>
<p>This module implements transformations between superoperator representations,
including supermatrix, Kraus, Choi and Chi (process) matrix formalisms.</p>
<dl class="function">
<dt id="qutip.superop_reps.to_choi">
<code class="descname">to_choi</code><span class="sig-paren">(</span><em>q_oper</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superop_reps.html#to_choi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superop_reps.to_choi" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to the Choi representation,
such that the trace of the returned operator is equal to the dimension
of the system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q_oper</strong> : Qobj</p>
<blockquote>
<div><p>Superoperator to be converted to Choi representation. If
<code class="docutils literal"><span class="pre">q_oper</span></code> is <code class="docutils literal"><span class="pre">type=&quot;oper&quot;</span></code>, then it is taken to act by conjugation,
such that <code class="docutils literal"><span class="pre">to_choi(A)</span> <span class="pre">==</span> <span class="pre">to_choi(sprepost(A,</span> <span class="pre">A.dag()))</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>choi</strong> : Qobj</p>
<blockquote>
<div><p>A quantum object representing the same map as <code class="docutils literal"><span class="pre">q_oper</span></code>, such that
<code class="docutils literal"><span class="pre">choi.superrep</span> <span class="pre">==</span> <span class="pre">&quot;choi&quot;</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>TypeError: if the given quantum object is not a map, or cannot be converted</strong></p>
<blockquote class="last">
<div><p>to Choi representation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superop_reps.to_super">
<code class="descname">to_super</code><span class="sig-paren">(</span><em>q_oper</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superop_reps.html#to_super"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superop_reps.to_super" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to the supermatrix (Liouville)
representation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q_oper</strong> : Qobj</p>
<blockquote>
<div><p>Superoperator to be converted to supermatrix representation. If
<code class="docutils literal"><span class="pre">q_oper</span></code> is <code class="docutils literal"><span class="pre">type=&quot;oper&quot;</span></code>, then it is taken to act by conjugation,
such that <code class="docutils literal"><span class="pre">to_super(A)</span> <span class="pre">==</span> <span class="pre">sprepost(A,</span> <span class="pre">A.dag())</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>superop</strong> : Qobj</p>
<blockquote>
<div><p>A quantum object representing the same map as <code class="docutils literal"><span class="pre">q_oper</span></code>, such that
<code class="docutils literal"><span class="pre">superop.superrep</span> <span class="pre">==</span> <span class="pre">&quot;super&quot;</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>TypeError</strong></p>
<blockquote class="last">
<div><p>If the given quantum object is not a map, or cannot be converted
to supermatrix representation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superop_reps.to_kraus">
<code class="descname">to_kraus</code><span class="sig-paren">(</span><em>q_oper</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superop_reps.html#to_kraus"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superop_reps.to_kraus" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to a list of quantum objects,
each representing an operator in the Kraus decomposition of the given map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q_oper</strong> : Qobj</p>
<blockquote>
<div><p>Superoperator to be converted to Kraus representation. If
<code class="docutils literal"><span class="pre">q_oper</span></code> is <code class="docutils literal"><span class="pre">type=&quot;oper&quot;</span></code>, then it is taken to act by conjugation,
such that <code class="docutils literal"><span class="pre">to_kraus(A)</span> <span class="pre">==</span> <span class="pre">to_kraus(sprepost(A,</span> <span class="pre">A.dag()))</span> <span class="pre">==</span> <span class="pre">[A]</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>kraus_ops</strong> : list of Qobj</p>
<blockquote>
<div><p>A list of quantum objects, each representing a Kraus operator in the
decomposition of <code class="docutils literal"><span class="pre">q_oper</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>TypeError: if the given quantum object is not a map, or cannot be</strong></p>
<blockquote class="last">
<div><p>decomposed into Kraus operators.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="functions-acting-on-states-and-operators">
<h2>Functions acting on states and operators<a class="headerlink" href="#functions-acting-on-states-and-operators" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.tensor">
<span id="tensor"></span><h3>Tensor<a class="headerlink" href="#module-qutip.tensor" title="Permalink to this headline">¶</a></h3>
<p>Module for the creation of composite quantum objects via the tensor product.</p>
<dl class="function">
<dt id="qutip.tensor.tensor">
<code class="descname">tensor</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tensor.html#tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tensor.tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the tensor product of input operators.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>args</strong> : array_like</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">list</span></code> or <code class="docutils literal"><span class="pre">array</span></code> of quantum objects for tensor product.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>obj</strong> : qobj</p>
<blockquote class="last">
<div><p>A composite quantum object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tensor</span><span class="p">([</span><span class="n">sigmax</span><span class="p">(),</span> <span class="n">sigmax</span><span class="p">()])</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.tensor.super_tensor">
<code class="descname">super_tensor</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tensor.html#super_tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tensor.super_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the tensor product of input superoperators, by tensoring
together the underlying Hilbert spaces on which each vectorized operator
acts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>args</strong> : array_like</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">list</span></code> or <code class="docutils literal"><span class="pre">array</span></code> of quantum objects with <code class="docutils literal"><span class="pre">type=&quot;super&quot;</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>obj</strong> : qobj</p>
<blockquote class="last">
<div><p>A composite quantum object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.tensor.composite">
<code class="descname">composite</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tensor.html#composite"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tensor.composite" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two or more operators, kets or bras, returns the Qobj
corresponding to a composite system over each argument.
For ordinary operators and vectors, this is the tensor product,
while for superoperators and vectorized operators, this is
the column-reshuffled tensor product.</p>
<p>If a mix of Qobjs supported on Hilbert and Liouville spaces
are passed in, the former are promoted. Ordinary operators
are assumed to be unitaries, and are promoted using <code class="docutils literal"><span class="pre">to_super</span></code>,
while kets and bras are promoted by taking their projectors and
using <code class="docutils literal"><span class="pre">operator_to_vector(ket2dm(arg))</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.tensor.tensor_contract">
<code class="descname">tensor_contract</code><span class="sig-paren">(</span><em>qobj</em>, <em>*pairs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tensor.html#tensor_contract"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tensor.tensor_contract" title="Permalink to this definition">¶</a></dt>
<dd><p>Contracts a qobj along one or more index pairs.
Note that this uses dense representations and thus
should <em>not</em> be used for very large Qobjs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>pairs</strong> : tuple</p>
<blockquote>
<div><p>One or more tuples <code class="docutils literal"><span class="pre">(i,</span> <span class="pre">j)</span></code> indicating that the
<code class="docutils literal"><span class="pre">i</span></code> and <code class="docutils literal"><span class="pre">j</span></code> dimensions of the original qobj
should be contracted.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cqobj</strong> : Qobj</p>
<blockquote class="last">
<div><p>The original Qobj with all named index pairs contracted
away.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.expect">
<span id="expectation-values"></span><h3>Expectation Values<a class="headerlink" href="#module-qutip.expect" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.expect.expect">
<code class="descname">expect</code><span class="sig-paren">(</span><em>oper</em>, <em>state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/expect.html#expect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.expect.expect" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the expectation value for operator(s) and state(s).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj/array-like</p>
<blockquote>
<div><p>A single or a <cite>list</cite> or operators for expectation value.</p>
</div></blockquote>
<p><strong>state</strong> : qobj/array-like</p>
<blockquote>
<div><p>A single or a <cite>list</cite> of quantum states or density matrices.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>expt</strong> : float/complex/array-like</p>
<blockquote class="last">
<div><p>Expectation value.  <code class="docutils literal"><span class="pre">real</span></code> if <cite>oper</cite> is Hermitian, <code class="docutils literal"><span class="pre">complex</span></code>
otherwise. A (nested) array of expectaction values of state or operator
are arrays.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expect</span><span class="p">(</span><span class="n">num</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">basis</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.expect.variance">
<code class="descname">variance</code><span class="sig-paren">(</span><em>oper</em>, <em>state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/expect.html#variance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.expect.variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Variance of an operator for the given state vector or density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote>
<div><p>Operator for expectation value.</p>
</div></blockquote>
<p><strong>state</strong> : qobj/list</p>
<blockquote>
<div><p>A single or <cite>list</cite> of quantum states or density matrices..</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>var</strong> : float</p>
<blockquote class="last">
<div><p>Variance of operator ‘oper’ for given state.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.partial_transpose">
<span id="partial-transpose"></span><h3>Partial Transpose<a class="headerlink" href="#module-qutip.partial_transpose" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.partial_transpose.partial_transpose">
<code class="descname">partial_transpose</code><span class="sig-paren">(</span><em>rho</em>, <em>mask</em>, <em>method=’dense’</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/partial_transpose.html#partial_transpose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.partial_transpose.partial_transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the partial transpose of a Qobj instance <cite>rho</cite>,
where <cite>mask</cite> is an array/list with length that equals
the number of components of <cite>rho</cite> (that is, the length of
<cite>rho.dims[0]</cite>), and the values in <cite>mask</cite> indicates whether
or not the corresponding subsystem is to be transposed.
The elements in <cite>mask</cite> can be boolean or integers <cite>0</cite> or <cite>1</cite>,
where <cite>True</cite>/<cite>1</cite> indicates that the corresponding subsystem
should be tranposed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>A density matrix.</p>
</div></blockquote>
<p><strong>mask</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>A mask that selects which subsystems should be transposed.</p>
</div></blockquote>
<p><strong>method</strong> : str</p>
<blockquote>
<div><p>choice of method, <cite>dense</cite> or <cite>sparse</cite>. The default method
is <cite>dense</cite>. The <cite>sparse</cite> implementation can be faster for
large and sparse systems (hundreds of quantum states).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">rho_pr: <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote class="last">
<div><p>A density matrix with the selected subsystems transposed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.entropy">
<span id="entropy-functions"></span><span id="functions-entropy"></span><h3>Entropy Functions<a class="headerlink" href="#module-qutip.entropy" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.entropy.concurrence">
<code class="descname">concurrence</code><span class="sig-paren">(</span><em>rho</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/entropy.html#concurrence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.concurrence" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the concurrence entanglement measure for a two-qubit state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote>
<div><p>Ket, bra, or density matrix for a two-qubit state.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>concur</strong> : float</p>
<blockquote class="last">
<div><p>Concurrence</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id40">[R2]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Concurrence_(quantum_computing">http://en.wikipedia.org/wiki/Concurrence_(quantum_computing</a>)</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_conditional">
<code class="descname">entropy_conditional</code><span class="sig-paren">(</span><em>rho</em>, <em>selB</em>, <em>base=2.718281828459045</em>, <em>sparse=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/entropy.html#entropy_conditional"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.entropy_conditional" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the conditional entropy <span class="math">\(S(A|B)=S(A,B)-S(B)\)</span>
of a selected density matrix component.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : qobj</p>
<blockquote>
<div><p>Density matrix of composite object</p>
</div></blockquote>
<p><strong>selB</strong> : int/list</p>
<blockquote>
<div><p>Selected components for density matrix B</p>
</div></blockquote>
<p><strong>base</strong> : {e,2}</p>
<blockquote>
<div><p>Base of logarithm.</p>
</div></blockquote>
<p><strong>sparse</strong> : {False,True}</p>
<blockquote>
<div><p>Use sparse eigensolver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ent_cond</strong> : float</p>
<blockquote class="last">
<div><p>Value of conditional entropy</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_linear">
<code class="descname">entropy_linear</code><span class="sig-paren">(</span><em>rho</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/entropy.html#entropy_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.entropy_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear entropy of a density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : qobj</p>
<blockquote>
<div><p>sensity matrix or ket/bra vector.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>entropy</strong> : float</p>
<blockquote class="last">
<div><p>Linear entropy of rho.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy_linear</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_mutual">
<code class="descname">entropy_mutual</code><span class="sig-paren">(</span><em>rho</em>, <em>selA</em>, <em>selB</em>, <em>base=2.718281828459045</em>, <em>sparse=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/entropy.html#entropy_mutual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.entropy_mutual" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the mutual information S(A:B) between selection
components of a system density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : qobj</p>
<blockquote>
<div><p>Density matrix for composite quantum systems</p>
</div></blockquote>
<p><strong>selA</strong> : int/list</p>
<blockquote>
<div><p><cite>int</cite> or <cite>list</cite> of first selected density matrix components.</p>
</div></blockquote>
<p><strong>selB</strong> : int/list</p>
<blockquote>
<div><p><cite>int</cite> or <cite>list</cite> of second selected density matrix components.</p>
</div></blockquote>
<p><strong>base</strong> : {e,2}</p>
<blockquote>
<div><p>Base of logarithm.</p>
</div></blockquote>
<p><strong>sparse</strong> : {False,True}</p>
<blockquote>
<div><p>Use sparse eigensolver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ent_mut</strong> : float</p>
<blockquote class="last">
<div><p>Mutual information between selected components.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_vn">
<code class="descname">entropy_vn</code><span class="sig-paren">(</span><em>rho</em>, <em>base=2.718281828459045</em>, <em>sparse=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/entropy.html#entropy_vn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.entropy_vn" title="Permalink to this definition">¶</a></dt>
<dd><p>Von-Neumann entropy of density matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : qobj</p>
<blockquote>
<div><p>Density matrix.</p>
</div></blockquote>
<p><strong>base</strong> : {e,2}</p>
<blockquote>
<div><p>Base of logarithm.</p>
</div></blockquote>
<p><strong>sparse</strong> : {False,True}</p>
<blockquote>
<div><p>Use sparse eigensolver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>entropy</strong> : float</p>
<blockquote class="last">
<div><p>Von-Neumann entropy of <cite>rho</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy_vn</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-qutip.metrics">
<span id="density-matrix-metrics"></span><h3>Density Matrix Metrics<a class="headerlink" href="#module-qutip.metrics" title="Permalink to this headline">¶</a></h3>
<p>This module contains a collection of functions for calculating metrics
(distance measures) between states and operators.</p>
<dl class="function">
<dt id="qutip.metrics.fidelity">
<code class="descname">fidelity</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#fidelity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the fidelity (pseudo-metric) between two density matrices.
See: Nielsen &amp; Chuang, “Quantum Computation and Quantum Information”</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector.</p>
</div></blockquote>
<p><strong>B</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector with same dimensions as A.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fid</strong> : float</p>
<blockquote class="last">
<div><p>Fidelity pseudo-metric between A and B.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">fock_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">coherent_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">0.24104350624628332</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.tracedist">
<code class="descname">tracedist</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>sparse=False</em>, <em>tol=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#tracedist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.tracedist" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the trace distance between two density matrices..
See: Nielsen &amp; Chuang, “Quantum Computation and Quantum Information”</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector.</p>
</div></blockquote>
<p><strong>B</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector with same dimensions as A.</p>
</div></blockquote>
<p><strong>tol</strong> : float</p>
<blockquote>
<div><p>Tolerance used by sparse eigensolver, if used. (0=Machine precision)</p>
</div></blockquote>
<p><strong>sparse</strong> : {False, True}</p>
<blockquote>
<div><p>Use sparse eigensolver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tracedist</strong> : float</p>
<blockquote class="last">
<div><p>Trace distance between A and B.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">=</span><span class="n">coherent_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tracedist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">0.9705143161472971</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.bures_dist">
<code class="descname">bures_dist</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#bures_dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.bures_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Bures distance between two density matrices A &amp; B.</p>
<p>The Bures distance ranges from 0, for states with unit fidelity,
to sqrt(2).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector.</p>
</div></blockquote>
<p><strong>B</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector with same dimensions as A.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dist</strong> : float</p>
<blockquote class="last">
<div><p>Bures distance between density matrices.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.bures_angle">
<code class="descname">bures_angle</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#bures_angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.bures_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Bures Angle between two density matrices A &amp; B.</p>
<p>The Bures angle ranges from 0, for states with unit fidelity, to pi/2.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector.</p>
</div></blockquote>
<p><strong>B</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector with same dimensions as A.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>angle</strong> : float</p>
<blockquote class="last">
<div><p>Bures angle between density matrices.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.hilbert_dist">
<code class="descname">hilbert_dist</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#hilbert_dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.hilbert_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Hilbert-Schmidt distance between two density matrices A &amp; B.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector.</p>
</div></blockquote>
<p><strong>B</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector with same dimensions as A.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dist</strong> : float</p>
<blockquote class="last">
<div><p>Hilbert-Schmidt distance between density matrices.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998).</p>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.average_gate_fidelity">
<code class="descname">average_gate_fidelity</code><span class="sig-paren">(</span><em>oper</em>, <em>target=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#average_gate_fidelity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.average_gate_fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a Qobj representing the supermatrix form of a map, returns the
average gate fidelity (pseudo-metric) of that map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : Qobj</p>
<blockquote>
<div><p>Quantum object representing a superoperator.</p>
</div></blockquote>
<p><strong>target</strong> : Qobj</p>
<blockquote>
<div><p>Quantum object representing the target unitary; the inverse
is applied before evaluating the fidelity.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fid</strong> : float</p>
<blockquote class="last">
<div><p>Fidelity pseudo-metric between A and the identity superoperator,
or between A and the target superunitary.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.process_fidelity">
<code class="descname">process_fidelity</code><span class="sig-paren">(</span><em>U1</em>, <em>U2</em>, <em>normalize=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#process_fidelity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.process_fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the process fidelity given two process operators.</p>
</dd></dl>

</div>
<div class="section" id="module-qutip.continuous_variables">
<span id="continous-variables"></span><h3>Continous Variables<a class="headerlink" href="#module-qutip.continuous_variables" title="Permalink to this headline">¶</a></h3>
<p>This module contains a collection functions for calculating continuous variable
quantities from fock-basis representation of the state of multi-mode fields.</p>
<dl class="function">
<dt id="qutip.continuous_variables.correlation_matrix">
<code class="descname">correlation_matrix</code><span class="sig-paren">(</span><em>basis</em>, <em>rho=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/continuous_variables.html#correlation_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a basis set of operators <span class="math">\(\{a\}_n\)</span>, calculate the correlation
matrix:</p>
<div class="math">
\[C_{mn} = \langle a_m a_n \rangle\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>basis</strong> : list</p>
<blockquote>
<div><p>List of operators that defines the basis for the correlation matrix.</p>
</div></blockquote>
<p><strong>rho</strong> : Qobj</p>
<blockquote>
<div><p>Density matrix for which to calculate the correlation matrix. If
<cite>rho</cite> is <cite>None</cite>, then a matrix of correlation matrix operators is
returned instead of expectation values of those operators.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_mat</strong> : ndarray</p>
<blockquote class="last">
<div><p>A 2-dimensional <em>array</em> of correlation values or operators.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.covariance_matrix">
<code class="descname">covariance_matrix</code><span class="sig-paren">(</span><em>basis</em>, <em>rho</em>, <em>symmetrized=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/continuous_variables.html#covariance_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.covariance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a basis set of operators <span class="math">\(\{a\}_n\)</span>, calculate the covariance
matrix:</p>
<div class="math">
\[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -
\langle a_m \rangle \langle a_n\rangle\]</div>
<p>or, if of the optional argument <cite>symmetrized=False</cite>,</p>
<div class="math">
\[V_{mn} = \langle a_m a_n\rangle -
\langle a_m \rangle \langle a_n\rangle\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>basis</strong> : list</p>
<blockquote>
<div><p>List of operators that defines the basis for the covariance matrix.</p>
</div></blockquote>
<p><strong>rho</strong> : Qobj</p>
<blockquote>
<div><p>Density matrix for which to calculate the covariance matrix.</p>
</div></blockquote>
<p><strong>symmetrized</strong> : bool {True, False}</p>
<blockquote>
<div><p>Flag indicating whether the symmetrized (default) or non-symmetrized
correlation matrix is to be calculated.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_mat</strong> : ndarray</p>
<blockquote class="last">
<div><p>A 2-dimensional array of covariance values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.correlation_matrix_field">
<code class="descname">correlation_matrix_field</code><span class="sig-paren">(</span><em>a1</em>, <em>a2</em>, <em>rho=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/continuous_variables.html#correlation_matrix_field"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the correlation matrix for given field operators <span class="math">\(a_1\)</span> and
<span class="math">\(a_2\)</span>. If a density matrix is given the expectation values are
calculated, otherwise a matrix with operators is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a1</strong> : Qobj</p>
<blockquote>
<div><p>Field operator for mode 1.</p>
</div></blockquote>
<p><strong>a2</strong> : Qobj</p>
<blockquote>
<div><p>Field operator for mode 2.</p>
</div></blockquote>
<p><strong>rho</strong> : Qobj</p>
<blockquote>
<div><p>Density matrix for which to calculate the covariance matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cov_mat</strong> : ndarray</p>
<blockquote class="last">
<div><p>Array of complex numbers or Qobj’s
A 2-dimensional <em>array</em> of covariance values, or, if rho=0, a matrix
of operators.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.correlation_matrix_quadrature">
<code class="descname">correlation_matrix_quadrature</code><span class="sig-paren">(</span><em>a1</em>, <em>a2</em>, <em>rho=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/continuous_variables.html#correlation_matrix_quadrature"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix_quadrature" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the quadrature correlation matrix with given field operators
<span class="math">\(a_1\)</span> and <span class="math">\(a_2\)</span>. If a density matrix is given the expectation
values are calculated, otherwise a matrix with operators is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a1</strong> : Qobj</p>
<blockquote>
<div><p>Field operator for mode 1.</p>
</div></blockquote>
<p><strong>a2</strong> : Qobj</p>
<blockquote>
<div><p>Field operator for mode 2.</p>
</div></blockquote>
<p><strong>rho</strong> : Qobj</p>
<blockquote>
<div><p>Density matrix for which to calculate the covariance matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_mat</strong> : ndarray</p>
<blockquote class="last">
<div><p>Array of complex numbers or Qobj’s
A 2-dimensional <em>array</em> of covariance values for the field quadratures,
or, if rho=0, a matrix of operators.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.wigner_covariance_matrix">
<code class="descname">wigner_covariance_matrix</code><span class="sig-paren">(</span><em>a1=None</em>, <em>a2=None</em>, <em>R=None</em>, <em>rho=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/continuous_variables.html#wigner_covariance_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.wigner_covariance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Wigner covariance matrix
<span class="math">\(V_{ij} = \frac{1}{2}(R_{ij} + R_{ji})\)</span>, given
the quadrature correlation matrix
<span class="math">\(R_{ij} = \langle R_{i} R_{j}\rangle -
\langle R_{i}\rangle \langle R_{j}\rangle\)</span>, where
<span class="math">\(R = (q_1, p_1, q_2, p_2)^T\)</span> is the vector with quadrature operators
for the two modes.</p>
<p>Alternatively, if <cite>R = None</cite>, and if annihilation operators <cite>a1</cite> and <cite>a2</cite>
for the two modes are supplied instead, the quadrature correlation matrix
is constructed from the annihilation operators before then the covariance
matrix is calculated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a1</strong> : Qobj</p>
<blockquote>
<div><p>Field operator for mode 1.</p>
</div></blockquote>
<p><strong>a2</strong> : Qobj</p>
<blockquote>
<div><p>Field operator for mode 2.</p>
</div></blockquote>
<p><strong>R</strong> : ndarray</p>
<blockquote>
<div><p>The quadrature correlation matrix.</p>
</div></blockquote>
<p><strong>rho</strong> : Qobj</p>
<blockquote>
<div><p>Density matrix for which to calculate the covariance matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cov_mat</strong> : ndarray</p>
<blockquote class="last">
<div><p>A 2-dimensional array of covariance values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.logarithmic_negativity">
<code class="descname">logarithmic_negativity</code><span class="sig-paren">(</span><em>V</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/continuous_variables.html#logarithmic_negativity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.logarithmic_negativity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the logarithmic negativity given a symmetrized covariance
matrix, see <code class="xref py py-func docutils literal"><span class="pre">qutip.continous_variables.covariance_matrix</span></code>. Note that
the two-mode field state that is described by <cite>V</cite> must be Gaussian for this
function to applicable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>V</strong> : <em>2d array</em></p>
<blockquote>
<div><p>The covariance matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>N</strong> : float</p>
<blockquote class="last">
<div><p>The logarithmic negativity for the two-mode Gaussian state
that is described by the the Wigner covariance matrix V.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="dynamics-and-time-evolution">
<h2>Dynamics and Time-Evolution<a class="headerlink" href="#dynamics-and-time-evolution" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.sesolve">
<span id="schrodinger-equation"></span><h3>Schrödinger Equation<a class="headerlink" href="#module-qutip.sesolve" title="Permalink to this headline">¶</a></h3>
<p>This module provides solvers for the unitary Schrodinger equation.</p>
<dl class="function">
<dt id="qutip.sesolve.sesolve">
<code class="descname">sesolve</code><span class="sig-paren">(</span><em>H</em>, <em>rho0</em>, <em>tlist</em>, <em>e_ops=[]</em>, <em>args={}</em>, <em>options=None</em>, <em>progress_bar=&lt;qutip.ui.progressbar.BaseProgressBar object&gt;</em>, <em>_safe_mode=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/sesolve.html#sesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.sesolve.sesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Schrodinger equation evolution of a state vector for a given Hamiltonian.</p>
<p>Evolve the state vector or density matrix (<cite>rho0</cite>) using a given
Hamiltonian (<cite>H</cite>), by integrating the set of ordinary differential
equations that define the system.</p>
<p>The output is either the state vector at arbitrary points in time
(<cite>tlist</cite>), or the expectation values of the supplied operators
(<cite>e_ops</cite>). If e_ops is a callback function, it is invoked for each
time in <cite>tlist</cite> with time and the state as arguments, and the function
does not use any return values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>system Hamiltonian, or a callback function for time-dependent
Hamiltonians.</p>
</div></blockquote>
<p><strong>rho0</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>initial density matrix or state vector (ket).</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code> / callback function single</p>
<blockquote>
<div><p>single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>args</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>dictionary of parameters for time-dependent Hamiltonians and
collapse operators.</p>
</div></blockquote>
<p><strong>options</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.Qdeoptions</span></code></p>
<blockquote>
<div><p>with options for the ODE solver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">output: <code class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></code></p>
<blockquote class="last">
<div><p>An instance of the class <code class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></code>, which contains either
an <em>array</em> of expectation values for the times specified by <cite>tlist</cite>, or
an <em>array</em> or state vectors or density matrices corresponding to the
times in <cite>tlist</cite> [if <cite>e_ops</cite> is an empty list], or
nothing if a callback function was given inplace of operators for
which to calculate the expectation values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.mesolve">
<span id="master-equation"></span><h3>Master Equation<a class="headerlink" href="#module-qutip.mesolve" title="Permalink to this headline">¶</a></h3>
<p>This module provides solvers for the Lindblad master equation and von Neumann
equation.</p>
<dl class="function">
<dt id="qutip.mesolve.mesolve">
<code class="descname">mesolve</code><span class="sig-paren">(</span><em>H</em>, <em>rho0</em>, <em>tlist</em>, <em>c_ops=[]</em>, <em>e_ops=[]</em>, <em>args={}</em>, <em>options=None</em>, <em>progress_bar=None</em>, <em>_safe_mode=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/mesolve.html#mesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.mesolve.mesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Master equation evolution of a density matrix for a given Hamiltonian and
set of collapse operators, or a Liouvillian.</p>
<p>Evolve the state vector or density matrix (<cite>rho0</cite>) using a given
Hamiltonian (<cite>H</cite>) and an [optional] set of collapse operators
(<cite>c_ops</cite>), by integrating the set of ordinary differential equations
that define the system. In the absence of collapse operators the system is
evolved according to the unitary evolution of the Hamiltonian.</p>
<p>The output is either the state vector at arbitrary points in time
(<cite>tlist</cite>), or the expectation values of the supplied operators
(<cite>e_ops</cite>). If e_ops is a callback function, it is invoked for each
time in <cite>tlist</cite> with time and the state as arguments, and the function
does not use any return values.</p>
<p>If either <cite>H</cite> or the Qobj elements in <cite>c_ops</cite> are superoperators, they
will be treated as direct contributions to the total system Liouvillian.
This allows to solve master equations that are not on standard Lindblad
form by passing a custom Liouvillian in place of either the <cite>H</cite> or <cite>c_ops</cite>
elements.</p>
<p><strong>Time-dependent operators</strong></p>
<p>For time-dependent problems, <cite>H</cite> and <cite>c_ops</cite> can be callback
functions that takes two arguments, time and <cite>args</cite>, and returns the
Hamiltonian or Liouvillian for the system at that point in time
(<em>callback format</em>).</p>
<p>Alternatively, <cite>H</cite> and <cite>c_ops</cite> can be a specified in a nested-list format
where each element in the list is a list of length 2, containing an
operator (<code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code>) at the first element and where the
second element is either a string (<em>list string format</em>), a callback
function (<em>list callback format</em>) that evaluates to the time-dependent
coefficient for the corresponding operator, or a NumPy array (<em>list
array format</em>) which specifies the value of the coefficient to the
corresponding operator for each value of t in tlist.</p>
<p><em>Examples</em></p>
<blockquote>
<div><p>H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]</p>
<p>H = [[H0, f0_t], [H1, f1_t]]</p>
<p>where f0_t and f1_t are python functions with signature f_t(t, args).</p>
<p>H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]</p>
</div></blockquote>
<p>In the <em>list string format</em> and <em>list callback format</em>, the string
expression and the callback function must evaluate to a real or complex
number (coefficient for the corresponding operator).</p>
<p>In all cases of time-dependent operators, <cite>args</cite> is a dictionary of
parameters that is used when evaluating operators. It is passed to the
callback functions as second argument.</p>
<p><strong>Additional options</strong></p>
<p>Additional options to mesolve can be set via the <cite>options</cite> argument, which
should be an instance of <a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal"><span class="pre">qutip.solver.Options</span></code></a>. Many ODE
integration options can be set this way, and the <cite>store_states</cite> and
<cite>store_final_state</cite> options can be used to store states even though
expectation values are requested via the <cite>e_ops</cite> argument.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If an element in the list-specification of the Hamiltonian or
the list of collapse operators are in superoperator form it will be
added to the total Liouvillian of the problem with out further
transformation. This allows for using mesolve for solving master
equations that are not on standard Lindblad form.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On using callback function: mesolve transforms all <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code>
objects to sparse matrices before handing the problem to the integrator
function. In order for your callback function to work correctly, pass
all <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code> objects that are used in constructing the
Hamiltonian via args. mesolve will check for <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code> in
<cite>args</cite> and handle the conversion to sparse matrices. All other
<code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code> objects that are not passed via <cite>args</cite> will be
passed on to the integrator in scipy which will raise an NotImplemented
exception.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>System Hamiltonian, or a callback function for time-dependent
Hamiltonians, or alternatively a system Liouvillian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>initial density matrix or state vector (ket).</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>single collapse operator, or list of collapse operators, or a list
of Liouvillian superoperators.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a> / callback function single</p>
<blockquote>
<div><p>single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>args</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>dictionary of parameters for time-dependent Hamiltonians and
collapse operators.</p>
</div></blockquote>
<p><strong>options</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.Options</span></code></p>
<blockquote>
<div><p>with options for the solver.</p>
</div></blockquote>
<p><strong>progress_bar</strong> : BaseProgressBar</p>
<blockquote>
<div><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">result: <code class="xref py py-class docutils literal"><span class="pre">qutip.Result</span></code></p>
<blockquote class="last">
<div><p>An instance of the class <code class="xref py py-class docutils literal"><span class="pre">qutip.Result</span></code>, which contains
either an <em>array</em> <cite>result.expect</cite> of expectation values for the times
specified by <cite>tlist</cite>, or an <em>array</em> <cite>result.states</cite> of state vectors or
density matrices corresponding to the times in <cite>tlist</cite> [if <cite>e_ops</cite> is
an empty list], or nothing if a callback function was given in place of
operators for which to calculate the expectation values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.mcsolve">
<span id="monte-carlo-evolution"></span><h3>Monte Carlo Evolution<a class="headerlink" href="#module-qutip.mcsolve" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.mcsolve.mcsolve">
<code class="descname">mcsolve</code><span class="sig-paren">(</span><em>H</em>, <em>psi0</em>, <em>tlist</em>, <em>c_ops=[]</em>, <em>e_ops=[]</em>, <em>ntraj=None</em>, <em>args={}</em>, <em>options=None</em>, <em>progress_bar=True</em>, <em>map_func=None</em>, <em>map_kwargs=None</em>, <em>_safe_mode=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/mcsolve.html#mcsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.mcsolve.mcsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Monte Carlo evolution of a state vector <span class="math">\(|\psi \rangle\)</span> for a
given Hamiltonian and sets of collapse operators, and possibly, operators
for calculating expectation values. Options for the underlying ODE solver
are given by the Options class.</p>
<p>mcsolve supports time-dependent Hamiltonians and collapse operators using
either Python functions of strings to represent time-dependent
coefficients. Note that, the system Hamiltonian MUST have at least one
constant term.</p>
<p>As an example of a time-dependent problem, consider a Hamiltonian with two
terms <code class="docutils literal"><span class="pre">H0</span></code> and <code class="docutils literal"><span class="pre">H1</span></code>, where <code class="docutils literal"><span class="pre">H1</span></code> is time-dependent with coefficient
<code class="docutils literal"><span class="pre">sin(w*t)</span></code>, and collapse operators <code class="docutils literal"><span class="pre">C0</span></code> and <code class="docutils literal"><span class="pre">C1</span></code>, where <code class="docutils literal"><span class="pre">C1</span></code> is
time-dependent with coeffcient <code class="docutils literal"><span class="pre">exp(-a*t)</span></code>.  Here, w and a are constant
arguments with values <code class="docutils literal"><span class="pre">W</span></code> and <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Using the Python function time-dependent format requires two Python
functions, one for each collapse coefficient. Therefore, this problem could
be expressed as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">H1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">C1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="n">H1_coeff</span><span class="p">]]</span>

<span class="n">c_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">C0</span><span class="p">,</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="n">C1_coeff</span><span class="p">]]</span>

<span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="n">W</span><span class="p">}</span>
</pre></div>
</div>
<p>or in String (Cython) format we could write:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="s1">&#39;sin(w*t)&#39;</span><span class="p">]]</span>

<span class="n">c_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">C0</span><span class="p">,</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="s1">&#39;exp(-a*t)&#39;</span><span class="p">]]</span>

<span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="n">W</span><span class="p">}</span>
</pre></div>
</div>
<p>Constant terms are preferably placed first in the Hamiltonian and collapse
operator lists.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>psi0</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>Initial state vector</p>
</div></blockquote>
<p><strong>tlist</strong> : array_like</p>
<blockquote>
<div><p>Times at which results are recorded.</p>
</div></blockquote>
<p><strong>ntraj</strong> : int</p>
<blockquote>
<div><p>Number of trajectories to run.</p>
</div></blockquote>
<p><strong>c_ops</strong> : array_like</p>
<blockquote>
<div><p>single collapse operator or <code class="docutils literal"><span class="pre">list</span></code> or <code class="docutils literal"><span class="pre">array</span></code> of collapse
operators.</p>
</div></blockquote>
<p><strong>e_ops</strong> : array_like</p>
<blockquote>
<div><p>single operator or <code class="docutils literal"><span class="pre">list</span></code> or <code class="docutils literal"><span class="pre">array</span></code> of operators for calculating
expectation values.</p>
</div></blockquote>
<p><strong>args</strong> : dict</p>
<blockquote>
<div><p>Arguments for time-dependent Hamiltonian and collapse operator terms.</p>
</div></blockquote>
<p><strong>options</strong> : Options</p>
<blockquote>
<div><p>Instance of ODE solver options.</p>
</div></blockquote>
<p><strong>progress_bar: BaseProgressBar</strong></p>
<blockquote>
<div><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation. Set to None to disable the
progress bar.</p>
</div></blockquote>
<p><strong>map_func: function</strong></p>
<blockquote>
<div><p>A map function for managing the calls to the single-trajactory solver.</p>
</div></blockquote>
<p><strong>map_kwargs: dictionary</strong></p>
<blockquote>
<div><p>Optional keyword arguments to the map_func function.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>results</strong> : <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal"><span class="pre">qutip.solver.Result</span></code></a></p>
<blockquote>
<div><p>Object storing all results from the simulation.</p>
</div></blockquote>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is possible to reuse the random number seeds from a previous run
of the mcsolver by passing the output Result object seeds via the
Options class, i.e. Options(seeds=prev_result.seeds).</p>
</div>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.essolve">
<span id="exponential-series"></span><h3>Exponential Series<a class="headerlink" href="#module-qutip.essolve" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.essolve.essolve">
<code class="descname">essolve</code><span class="sig-paren">(</span><em>H</em>, <em>rho0</em>, <em>tlist</em>, <em>c_op_list</em>, <em>e_ops</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/essolve.html#essolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.essolve.essolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Evolution of a state vector or density matrix (<cite>rho0</cite>) for a given
Hamiltonian (<cite>H</cite>) and set of collapse operators (<cite>c_op_list</cite>), by
expressing the ODE as an exponential series. The output is either
the state vector at arbitrary points in time (<cite>tlist</cite>), or the
expectation values of the supplied operators (<cite>e_ops</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : qobj/function_type</p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>Initial state density matrix.</p>
</div></blockquote>
<p><strong>tlist</strong> : list/array</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">list</span></code> of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>c_op_list</strong> : list of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code> collapse operators.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code> operators for which to evaluate
expectation values.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>expt_array</strong> : array</p>
<blockquote>
<div><p>Expectation values of wavefunctions/density matrices for the
times specified in <code class="docutils literal"><span class="pre">tlist</span></code>.</p>
</div></blockquote>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This solver does not support time-dependent Hamiltonians.</p>
</div>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.essolve.ode2es">
<code class="descname">ode2es</code><span class="sig-paren">(</span><em>L</em>, <em>rho0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/essolve.html#ode2es"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.essolve.ode2es" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an exponential series that describes the time evolution for the
initial density matrix (or state vector) <cite>rho0</cite>, given the Liouvillian
(or Hamiltonian) <cite>L</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>L</strong> : qobj</p>
<blockquote>
<div><p>Liouvillian of the system.</p>
</div></blockquote>
<p><strong>rho0</strong> : qobj</p>
<blockquote>
<div><p>Initial state vector or density matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>eseries</strong> : <a class="reference internal" href="classes.html#qutip.eseries" title="qutip.eseries"><code class="xref py py-class docutils literal"><span class="pre">qutip.eseries</span></code></a></p>
<blockquote class="last">
<div><p><code class="docutils literal"><span class="pre">eseries</span></code> represention of the system dynamics.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.bloch_redfield">
<span id="bloch-redfield-master-equation"></span><h3>Bloch-Redfield Master Equation<a class="headerlink" href="#module-qutip.bloch_redfield" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.bloch_redfield.brmesolve">
<code class="descname">brmesolve</code><span class="sig-paren">(</span><em>H</em>, <em>psi0</em>, <em>tlist</em>, <em>a_ops=[]</em>, <em>e_ops=[]</em>, <em>c_ops=[]</em>, <em>args={}</em>, <em>use_secular=True</em>, <em>sec_cutoff=0.1</em>, <em>tol=1e-12</em>, <em>spectra_cb=None</em>, <em>options=None</em>, <em>progress_bar=None</em>, <em>_safe_mode=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/bloch_redfield.html#brmesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch_redfield.brmesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves for the dynamics of a system using the Bloch-Redfield master equation,
given an input Hamiltonian, Hermitian bath-coupling terms and their associated
spectrum functions, as well as possible Lindblad collapse operators.</p>
<p>For time-independent systems, the Hamiltonian must be given as a Qobj,
whereas the bath-coupling terms (a_ops), must be written as a nested list
of operator - spectrum function pairs, where the frequency is specified by
the <cite>w</cite> variable.</p>
<p><em>Example</em></p>
<blockquote>
<div>a_ops = [[a+a.dag(),lambda w: 0.2*(w&gt;=0)]]</div></blockquote>
<p>For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse
operators (c_ops), can be specified in the QuTiP string-based time-dependent
format.  For the a_op spectra, the frequency variable must be <cite>w</cite>, and the
string cannot contain any other variables other than the possibility of having
a time-dependence through the time variable <cite>t</cite>:</p>
<p><em>Example</em></p>
<blockquote>
<div>a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w&gt;=0)’]]</div></blockquote>
<p>It is also possible to use Cubic_Spline objects for time-dependence.  In
the case of a_ops, Cubic_Splines must be passed as a tuple:</p>
<p><em>Example</em></p>
<blockquote>
<div>a_ops = [ [a+a.dag(), ( f(w), g(t)] ]</div></blockquote>
<p>where f(w) and g(t) are strings or Cubic_spline objects for the bath
spectrum and time-dependence, respectively.</p>
<p>Finally, if one has bath-couplimg terms of the form
H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is</p>
<p><em>Example</em></p>
<blockquote>
<div>a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]</div></blockquote>
<p>where f(w) is the spectrum of the operators while g1(t) and g2(t)
are the time-dependence of the operators <cite>a</cite> and <cite>a.dag()</cite>, respectively</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : Qobj / list</p>
<blockquote>
<div><p>System Hamiltonian given as a Qobj or
nested list in string-based format.</p>
</div></blockquote>
<p><strong>psi0: Qobj</strong></p>
<blockquote>
<div><p>Initial density matrix or state vector (ket).</p>
</div></blockquote>
<p><strong>tlist</strong> : array_like</p>
<blockquote>
<div><p>List of times for evaluating evolution</p>
</div></blockquote>
<p><strong>a_ops</strong> : list</p>
<blockquote>
<div><p>Nested list of Hermitian system operators that couple to
the bath degrees of freedom, along with their associated
spectra.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list</p>
<blockquote>
<div><p>List of operators for which to evaluate expectation values.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list</p>
<blockquote>
<div><p>List of system collapse operators, or nested list in
string-based format.</p>
</div></blockquote>
<p><strong>args</strong> : dict (not implimented)</p>
<blockquote>
<div><p>Placeholder for future implementation, kept for API consistency.</p>
</div></blockquote>
<p><strong>use_secular</strong> : bool {True}</p>
<blockquote>
<div><p>Use secular approximation when evaluating bath-coupling terms.</p>
</div></blockquote>
<p><strong>sec_cutoff</strong> : float {0.1}</p>
<blockquote>
<div><p>Cutoff for secular approximation.</p>
</div></blockquote>
<p><strong>tol</strong> : float {qutip.setttings.atol}</p>
<blockquote>
<div><p>Tolerance used for removing small values after
basis transformation.</p>
</div></blockquote>
<p><strong>spectra_cb</strong> : list</p>
<blockquote>
<div><p>DEPRECIATED. Do not use.</p>
</div></blockquote>
<p><strong>options</strong> : <a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal"><span class="pre">qutip.solver.Options</span></code></a></p>
<blockquote>
<div><p>Options for the solver.</p>
</div></blockquote>
<p><strong>progress_bar</strong> : BaseProgressBar</p>
<blockquote>
<div><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">result: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal"><span class="pre">qutip.solver.Result</span></code></a></p>
<blockquote class="last">
<div><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal"><span class="pre">qutip.solver.Result</span></code></a>, which contains
either an array of expectation values, for operators given in e_ops,
or a list of states for the times specified by <cite>tlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.bloch_redfield.bloch_redfield_tensor">
<code class="descname">bloch_redfield_tensor</code><span class="sig-paren">(</span><em>H</em>, <em>a_ops</em>, <em>spectra_cb=None</em>, <em>c_ops=[]</em>, <em>use_secular=True</em>, <em>sec_cutoff=0.1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/bloch_redfield.html#bloch_redfield_tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch_redfield.bloch_redfield_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Bloch-Redfield tensor for a system given a set of operators
and corresponding spectral functions that describes the system’s coupling
to its environment.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This tensor generation requires a time-independent Hamiltonian.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>a_ops</strong> : list of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>List of system operators that couple to the environment.</p>
</div></blockquote>
<p><strong>spectra_cb</strong> : list of callback functions</p>
<blockquote>
<div><p>List of callback functions that evaluate the noise power spectrum
at a given frequency.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>List of system collapse operators.</p>
</div></blockquote>
<p><strong>use_secular</strong> : bool</p>
<blockquote>
<div><p>Flag (True of False) that indicates if the secular approximation should
be used.</p>
</div></blockquote>
<p><strong>sec_cutoff</strong> : float {0.1}</p>
<blockquote>
<div><p>Threshold for secular approximation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">R, kets: <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a>, list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote class="last">
<div><p>R is the Bloch-Redfield tensor and kets is a list eigenstates of the
Hamiltonian.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.bloch_redfield.bloch_redfield_solve">
<code class="descname">bloch_redfield_solve</code><span class="sig-paren">(</span><em>R</em>, <em>ekets</em>, <em>rho0</em>, <em>tlist</em>, <em>e_ops=[]</em>, <em>options=None</em>, <em>progress_bar=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/bloch_redfield.html#bloch_redfield_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch_redfield.bloch_redfield_solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Evolve the ODEs defined by Bloch-Redfield master equation. The
Bloch-Redfield tensor can be calculated by the function
<a class="reference internal" href="#qutip.bloch_redfield.bloch_redfield_tensor" title="qutip.bloch_redfield.bloch_redfield_tensor"><code class="xref py py-func docutils literal"><span class="pre">bloch_redfield_tensor</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>R</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>Bloch-Redfield tensor.</p>
</div></blockquote>
<p><strong>ekets</strong> : array of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>Array of kets that make up a basis tranformation for the eigenbasis.</p>
</div></blockquote>
<p><strong>rho0</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>Initial density matrix.</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>List of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code> / callback function</p>
<blockquote>
<div><p>List of operators for which to evaluate expectation values.</p>
</div></blockquote>
<p><strong>options</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.Qdeoptions</span></code></p>
<blockquote>
<div><p>Options for the ODE solver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">output: <code class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></code></p>
<blockquote class="last">
<div><p>An instance of the class <code class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></code>, which contains either
an <em>array</em> of expectation values for the times specified by <cite>tlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.floquet">
<span id="floquet-states-and-floquet-markov-master-equation"></span><h3>Floquet States and Floquet-Markov Master Equation<a class="headerlink" href="#module-qutip.floquet" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.floquet.fmmesolve">
<code class="descname">fmmesolve</code><span class="sig-paren">(</span><em>H</em>, <em>rho0</em>, <em>tlist</em>, <em>c_ops=[]</em>, <em>e_ops=[]</em>, <em>spectra_cb=[]</em>, <em>T=None</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em>, <em>floquet_basis=True</em>, <em>kmax=5</em>, <em>_safe_mode=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#fmmesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.fmmesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the dynamics for the system using the Floquet-Markov master equation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This solver currently does not support multiple collapse operators.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0 / psi0</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>initial density matrix or state vector (ket).</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code> / callback function</p>
<blockquote>
<div><p>list of operators for which to evaluate expectation values.</p>
</div></blockquote>
<p><strong>spectra_cb</strong> : list callback functions</p>
<blockquote>
<div><p>List of callback functions that compute the noise power spectrum as
a function of frequency for the collapse operators in <cite>c_ops</cite>.</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian. The default value
‘None’ indicates that the ‘tlist’ spans a single period of the driving.</p>
</div></blockquote>
<p><strong>args</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>dictionary of parameters for time-dependent Hamiltonians and
collapse operators.</p>
<p>This dictionary should also contain an entry ‘w_th’, which is
the temperature of the environment (if finite) in the
energy/frequency units of the Hamiltonian.  For example, if
the Hamiltonian written in units of 2pi GHz, and the
temperature is given in K, use the following conversion</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">temperature</span> <span class="o">=</span> <span class="mf">25e-3</span> <span class="c1"># unit K</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="mf">6.626e-34</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kB</span> <span class="o">=</span> <span class="mf">1.38e-23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;w_th&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temperature</span> <span class="o">*</span> <span class="p">(</span><span class="n">kB</span> <span class="o">/</span> <span class="n">h</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="mf">1e-9</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>options</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></code></p>
<blockquote>
<div><p>options for the ODE solver.</p>
</div></blockquote>
<p><strong>k_max</strong> : int</p>
<blockquote>
<div><p>The truncation of the number of sidebands (default 5).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></code></p>
<blockquote class="last">
<div><p>An instance of the class <code class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></code>, which contains either
an <em>array</em> of expectation values for the times specified by <cite>tlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes">
<code class="descname">floquet_modes</code><span class="sig-paren">(</span><em>H</em>, <em>T</em>, <em>args=None</em>, <em>sort=False</em>, <em>U=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_modes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the initial Floquet modes Phi_alpha(0) for a driven system with
period T.</p>
<p>Returns a list of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code> instances representing the Floquet
modes and a list of corresponding quasienergies, sorted by increasing
quasienergy in the interval [-pi/T, pi/T]. The optional parameter <cite>sort</cite>
decides if the output is to be sorted in increasing quasienergies or not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>system Hamiltonian, time-dependent with period <cite>T</cite></p>
</div></blockquote>
<p><strong>args</strong> : dictionary</p>
<blockquote>
<div><p>dictionary with variables required to evaluate H</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian. The default value
‘None’ indicates that the ‘tlist’ spans a single period of the driving.</p>
</div></blockquote>
<p><strong>U</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>The propagator for the time-dependent Hamiltonian with period <cite>T</cite>.
If U is <cite>None</cite> (default), it will be calculated from the Hamiltonian
<cite>H</cite> using <a class="reference internal" href="#qutip.propagator.propagator" title="qutip.propagator.propagator"><code class="xref py py-func docutils literal"><span class="pre">qutip.propagator.propagator</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : list of kets, list of quasi energies</p>
<blockquote class="last">
<div><p>Two lists: the Floquet modes as kets and the quasi energies.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes_t">
<code class="descname">floquet_modes_t</code><span class="sig-paren">(</span><em>f_modes_0</em>, <em>f_energies</em>, <em>t</em>, <em>H</em>, <em>T</em>, <em>args=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_modes_t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_modes_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the
initial Floquet modes Phi_alpha(0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f_modes_0</strong> : list of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code> (kets)</p>
<blockquote>
<div><p>Floquet modes at <span class="math">\(t\)</span></p>
</div></blockquote>
<p><strong>f_energies</strong> : list</p>
<blockquote>
<div><p>Floquet energies.</p>
</div></blockquote>
<p><strong>t</strong> : float</p>
<blockquote>
<div><p>The time at which to evaluate the floquet modes.</p>
</div></blockquote>
<p><strong>H</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>system Hamiltonian, time-dependent with period <cite>T</cite></p>
</div></blockquote>
<p><strong>args</strong> : dictionary</p>
<blockquote>
<div><p>dictionary with variables required to evaluate H</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : list of kets</p>
<blockquote class="last">
<div><p>The Floquet modes as kets at time <span class="math">\(t\)</span></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes_table">
<code class="descname">floquet_modes_table</code><span class="sig-paren">(</span><em>f_modes_0</em>, <em>f_energies</em>, <em>tlist</em>, <em>H</em>, <em>T</em>, <em>args=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_modes_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_modes_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-calculate the Floquet modes for a range of times spanning the floquet
period. Can later be used as a table to look up the floquet modes for
any time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f_modes_0</strong> : list of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code> (kets)</p>
<blockquote>
<div><p>Floquet modes at <span class="math">\(t\)</span></p>
</div></blockquote>
<p><strong>f_energies</strong> : list</p>
<blockquote>
<div><p>Floquet energies.</p>
</div></blockquote>
<p><strong>tlist</strong> : array</p>
<blockquote>
<div><p>The list of times at which to evaluate the floquet modes.</p>
</div></blockquote>
<p><strong>H</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>system Hamiltonian, time-dependent with period <cite>T</cite></p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian.</p>
</div></blockquote>
<p><strong>args</strong> : dictionary</p>
<blockquote>
<div><p>dictionary with variables required to evaluate H</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : nested list</p>
<blockquote class="last">
<div><p>A nested list of Floquet modes as kets for each time in <cite>tlist</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes_t_lookup">
<code class="descname">floquet_modes_t_lookup</code><span class="sig-paren">(</span><em>f_modes_table_t</em>, <em>t</em>, <em>T</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_modes_t_lookup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_modes_t_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Lookup the floquet mode at time t in the pre-calculated table of floquet
modes in the first period of the time-dependence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f_modes_table_t</strong> : nested list of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code> (kets)</p>
<blockquote>
<div><p>A lookup-table of Floquet modes at times precalculated by
<a class="reference internal" href="#qutip.floquet.floquet_modes_table" title="qutip.floquet.floquet_modes_table"><code class="xref py py-func docutils literal"><span class="pre">qutip.floquet.floquet_modes_table</span></code></a>.</p>
</div></blockquote>
<p><strong>t</strong> : float</p>
<blockquote>
<div><p>The time for which to evaluate the Floquet modes.</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : nested list</p>
<blockquote class="last">
<div><p>A list of Floquet modes as kets for the time that most closely matching
the time <cite>t</cite> in the supplied table of Floquet modes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_states_t">
<code class="descname">floquet_states_t</code><span class="sig-paren">(</span><em>f_modes_0</em>, <em>f_energies</em>, <em>t</em>, <em>H</em>, <em>T</em>, <em>args=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_states_t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_states_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the floquet states at time t given the initial Floquet modes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f_modes_t</strong> : list of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code> (kets)</p>
<blockquote>
<div><p>A list of initial Floquet modes (for time <span class="math">\(t=0\)</span>).</p>
</div></blockquote>
<p><strong>f_energies</strong> : array</p>
<blockquote>
<div><p>The Floquet energies.</p>
</div></blockquote>
<p><strong>t</strong> : float</p>
<blockquote>
<div><p>The time for which to evaluate the Floquet states.</p>
</div></blockquote>
<p><strong>H</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian.</p>
</div></blockquote>
<p><strong>args</strong> : dictionary</p>
<blockquote>
<div><p>Dictionary with variables required to evaluate H.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : list</p>
<blockquote class="last">
<div><p>A list of Floquet states for the time <span class="math">\(t\)</span>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_wavefunction_t">
<code class="descname">floquet_wavefunction_t</code><span class="sig-paren">(</span><em>f_modes_0</em>, <em>f_energies</em>, <em>f_coeff</em>, <em>t</em>, <em>H</em>, <em>T</em>, <em>args=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_wavefunction_t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_wavefunction_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the wavefunction for a time t using the Floquet state
decompositon, given the initial Floquet modes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f_modes_t</strong> : list of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code> (kets)</p>
<blockquote>
<div><p>A list of initial Floquet modes (for time <span class="math">\(t=0\)</span>).</p>
</div></blockquote>
<p><strong>f_energies</strong> : array</p>
<blockquote>
<div><p>The Floquet energies.</p>
</div></blockquote>
<p><strong>f_coeff</strong> : array</p>
<blockquote>
<div><p>The coefficients for Floquet decomposition of the initial wavefunction.</p>
</div></blockquote>
<p><strong>t</strong> : float</p>
<blockquote>
<div><p>The time for which to evaluate the Floquet states.</p>
</div></blockquote>
<p><strong>H</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian.</p>
</div></blockquote>
<p><strong>args</strong> : dictionary</p>
<blockquote>
<div><p>Dictionary with variables required to evaluate H.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote class="last">
<div><p>The wavefunction for the time <span class="math">\(t\)</span>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_state_decomposition">
<code class="descname">floquet_state_decomposition</code><span class="sig-paren">(</span><em>f_states</em>, <em>f_energies</em>, <em>psi</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_state_decomposition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_state_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose the wavefunction <cite>psi</cite> (typically an initial state) in terms of
the Floquet states, <span class="math">\(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f_states</strong> : list of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code> (kets)</p>
<blockquote>
<div><p>A list of Floquet modes.</p>
</div></blockquote>
<p><strong>f_energies</strong> : array</p>
<blockquote>
<div><p>The Floquet energies.</p>
</div></blockquote>
<p><strong>psi</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>The wavefunction to decompose in the Floquet state basis.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : array</p>
<blockquote class="last">
<div><p>The coefficients <span class="math">\(c_\alpha\)</span> in the Floquet state decomposition.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.fsesolve">
<code class="descname">fsesolve</code><span class="sig-paren">(</span><em>H</em>, <em>psi0</em>, <em>tlist</em>, <em>e_ops=[]</em>, <em>T=None</em>, <em>args={}</em>, <em>Tsteps=100</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#fsesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.fsesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the Schrodinger equation using the Floquet formalism.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></code></p>
<blockquote>
<div><p>System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</div></blockquote>
<p><strong>psi0</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>Initial state vector (ket).</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code> / callback function</p>
<blockquote>
<div><p>list of operators for which to evaluate expectation values. If this
list is empty, the state vectors for each time in <cite>tlist</cite> will be
returned instead of expectation values.</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian.</p>
</div></blockquote>
<p><strong>args</strong> : dictionary</p>
<blockquote>
<div><p>Dictionary with variables required to evaluate H.</p>
</div></blockquote>
<p><strong>Tsteps</strong> : integer</p>
<blockquote>
<div><p>The number of time steps in one driving period for which to
precalculate the Floquet modes. <cite>Tsteps</cite> should be an even number.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal"><span class="pre">qutip.solver.Result</span></code></a></p>
<blockquote class="last">
<div><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal"><span class="pre">qutip.solver.Result</span></code></a>, which
contains either an <em>array</em> of expectation values or an array of
state vectors, for the times specified by <cite>tlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.stochastic">
<span id="stochastic-schrodinger-equation-and-master-equation"></span><h3>Stochastic Schrödinger Equation and Master Equation<a class="headerlink" href="#module-qutip.stochastic" title="Permalink to this headline">¶</a></h3>
<p>This module contains functions for solving stochastic schrodinger and master
equations. The API should not be considered stable, and is subject to change
when we work more on optimizing this module for performance and features.</p>
<dl class="function">
<dt id="qutip.stochastic.smesolve">
<code class="descname">smesolve</code><span class="sig-paren">(</span><em>H</em>, <em>rho0</em>, <em>times</em>, <em>c_ops=[]</em>, <em>sc_ops=[]</em>, <em>e_ops=[]</em>, <em>_safe_mode=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/stochastic.html#smesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.stochastic.smesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve stochastic master equation. Dispatch to specific solvers
depending on the value of the <cite>solver</cite> keyword argument.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>Initial density matrix or state vector (ket).</p>
</div></blockquote>
<p><strong>times</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>List of times for <span class="math">\(t\)</span>. Must be uniformly spaced.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.</p>
</div></blockquote>
<p><strong>sc_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the eqaution of motion according to how the d1 and d2 functions
are defined.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a> / callback function single</p>
<blockquote>
<div><p>single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>kwargs</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">output: <code class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></code></p>
<blockquote class="last">
<div><p>An instance of the class <code class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.stochastic.ssesolve">
<code class="descname">ssesolve</code><span class="sig-paren">(</span><em>H</em>, <em>psi0</em>, <em>times</em>, <em>sc_ops=[]</em>, <em>e_ops=[]</em>, <em>_safe_mode=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/stochastic.html#ssesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.stochastic.ssesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the stochastic Schrödinger equation. Dispatch to specific solvers
depending on the value of the <cite>solver</cite> keyword argument.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>psi0</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>Initial state vector (ket).</p>
</div></blockquote>
<p><strong>times</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>List of times for <span class="math">\(t\)</span>. Must be uniformly spaced.</p>
</div></blockquote>
<p><strong>sc_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the equation of motion according to how the d1 and d2 functions
are defined.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>Single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>kwargs</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">output: <code class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></code></p>
<blockquote class="last">
<div><p>An instance of the class <code class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.stochastic.smepdpsolve">
<code class="descname">smepdpsolve</code><span class="sig-paren">(</span><em>H</em>, <em>rho0</em>, <em>times</em>, <em>c_ops</em>, <em>e_ops</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/stochastic.html#smepdpsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.stochastic.smepdpsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>A stochastic (piecewse deterministic process) PDP solver for density matrix
evolution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>Initial density matrix.</p>
</div></blockquote>
<p><strong>times</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>List of times for <span class="math">\(t\)</span>. Must be uniformly spaced.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.</p>
</div></blockquote>
<p><strong>sc_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the eqaution of motion according to how the d1 and d2 functions
are defined.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a> / callback function single</p>
<blockquote>
<div><p>single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>kwargs</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">output: <code class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></code></p>
<blockquote class="last">
<div><p>An instance of the class <code class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.stochastic.ssepdpsolve">
<code class="descname">ssepdpsolve</code><span class="sig-paren">(</span><em>H</em>, <em>psi0</em>, <em>times</em>, <em>c_ops</em>, <em>e_ops</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/stochastic.html#ssepdpsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.stochastic.ssepdpsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>A stochastic (piecewse deterministic process) PDP solver for wavefunction
evolution. For most purposes, use <a class="reference internal" href="#module-qutip.mcsolve" title="qutip.mcsolve"><code class="xref py py-func docutils literal"><span class="pre">qutip.mcsolve</span></code></a> instead for quantum
trajectory simulations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>psi0</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>Initial state vector (ket).</p>
</div></blockquote>
<p><strong>times</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>List of times for <span class="math">\(t\)</span>. Must be uniformly spaced.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a> / callback function single</p>
<blockquote>
<div><p>single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>kwargs</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">output: <code class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></code></p>
<blockquote class="last">
<div><p>An instance of the class <code class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.correlation">
<span id="correlation-functions"></span><h3>Correlation Functions<a class="headerlink" href="#module-qutip.correlation" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.correlation.correlation">
<code class="descname">correlation</code><span class="sig-paren">(</span><em>H</em>, <em>state0</em>, <em>tlist</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>solver=’me’</em>, <em>reverse=False</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-operator two-time correlation function:
<span class="math">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : Qobj</p>
<blockquote>
<div><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</div></blockquote>
<p><strong>state0</strong> : Qobj</p>
<blockquote>
<div><p>Initial state density matrix <span class="math">\(\rho(t_0)\)</span> or state vector
<span class="math">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</div></blockquote>
<p><strong>tlist</strong> : array_like</p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. when <span class="math">\(t \rightarrow \infty\)</span>; here
tlist is automatically set, ignoring user input.</p>
</div></blockquote>
<p><strong>taulist</strong> : array_like</p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list</p>
<blockquote>
<div><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</div></blockquote>
<p><strong>a_op</strong> : Qobj</p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : Qobj</p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>reverse</strong> : <em>bool</em></p>
<blockquote>
<div><p>If <cite>True</cite>, calculate <span class="math">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</div></blockquote>
<p><strong>options</strong> : Options</p>
<blockquote>
<div><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_mat</strong> : array</p>
<blockquote class="last">
<div><p>An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional array of correlation values
is returned instead.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_ss">
<code class="descname">correlation_ss</code><span class="sig-paren">(</span><em>H</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>solver=’me’</em>, <em>reverse=False</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_ss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-operator two-time correlation function:</p>
<div class="math">
\[\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\]</div>
<p>along one time axis (given steady-state initial conditions) using the
quantum regression theorem and the evolution solver indicated by the
<cite>solver</cite> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : Qobj</p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>taulist</strong> : array_like</p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list</p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : Qobj</p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : Qobj</p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>reverse</strong> : <em>bool</em></p>
<blockquote>
<div><p>If <cite>True</cite>, calculate
<span class="math">\(\lim_{t \to \infty} \left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math">\(\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation and
<cite>es</cite> for exponential series).</p>
</div></blockquote>
<p><strong>options</strong> : Options</p>
<blockquote>
<div><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_vec</strong> : array</p>
<blockquote class="last">
<div><p>An array of correlation values for the times specified by <cite>tlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_2op_1t">
<code class="descname">correlation_2op_1t</code><span class="sig-paren">(</span><em>H</em>, <em>state0</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>solver=’me’</em>, <em>reverse=False</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_2op_1t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_2op_1t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-operator two-time correlation function:
<span class="math">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>
along one time axis using the quantum regression theorem and the evolution
solver indicated by the <cite>solver</cite> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : Qobj</p>
<blockquote>
<div><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</div></blockquote>
<p><strong>state0</strong> : Qobj</p>
<blockquote>
<div><p>Initial state density matrix <span class="math">\(\rho(t_0)\)</span> or state vector
<span class="math">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</div></blockquote>
<p><strong>taulist</strong> : array_like</p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list</p>
<blockquote>
<div><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</div></blockquote>
<p><strong>a_op</strong> : Qobj</p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : Qobj</p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>reverse</strong> : bool {False, True}</p>
<blockquote>
<div><p>If <cite>True</cite>, calculate <span class="math">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</div></blockquote>
<p><strong>solver</strong> : str {‘me’, ‘mc’, ‘es’}</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</div></blockquote>
<p><strong>options</strong> : Options</p>
<blockquote>
<div><p>Solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_vec</strong> : ndarray</p>
<blockquote class="last">
<div><p>An array of correlation values for the times specified by <cite>tlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_2op_2t">
<code class="descname">correlation_2op_2t</code><span class="sig-paren">(</span><em>H</em>, <em>state0</em>, <em>tlist</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>solver=’me’</em>, <em>reverse=False</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_2op_2t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_2op_2t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-operator two-time correlation function:
<span class="math">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : Qobj</p>
<blockquote>
<div><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</div></blockquote>
<p><strong>state0</strong> : Qobj</p>
<blockquote>
<div><p>Initial state density matrix <span class="math">\(\rho_0\)</span> or state vector
<span class="math">\(\psi_0\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</div></blockquote>
<p><strong>tlist</strong> : array_like</p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. when <span class="math">\(t \rightarrow \infty\)</span>; here
tlist is automatically set, ignoring user input.</p>
</div></blockquote>
<p><strong>taulist</strong> : array_like</p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list</p>
<blockquote>
<div><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</div></blockquote>
<p><strong>a_op</strong> : Qobj</p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : Qobj</p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>reverse</strong> : bool {False, True}</p>
<blockquote>
<div><p>If <cite>True</cite>, calculate <span class="math">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</div></blockquote>
<p><strong>options</strong> : Options</p>
<blockquote>
<div><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_mat</strong> : ndarray</p>
<blockquote class="last">
<div><p>An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional array of correlation values
is returned instead.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_3op_1t">
<code class="descname">correlation_3op_1t</code><span class="sig-paren">(</span><em>H</em>, <em>state0</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>c_op</em>, <em>solver=’me’</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_3op_1t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_3op_1t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the three-operator two-time correlation function:
<span class="math">\(\left&lt;A(t)B(t+\tau)C(t)\right&gt;\)</span>
along one time axis using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math">\(\tau&lt;0\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : Qobj</p>
<blockquote>
<div><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</div></blockquote>
<p><strong>rho0</strong> : Qobj</p>
<blockquote>
<div><p>Initial state density matrix <span class="math">\(\rho(t_0)\)</span> or state vector
<span class="math">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</div></blockquote>
<p><strong>taulist</strong> : array_like</p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list</p>
<blockquote>
<div><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</div></blockquote>
<p><strong>a_op</strong> : Qobj</p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : Qobj</p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>c_op</strong> : Qobj</p>
<blockquote>
<div><p>operator C.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</div></blockquote>
<p><strong>options</strong> : Options</p>
<blockquote>
<div><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_vec</strong> : array</p>
<blockquote class="last">
<div><p>An array of correlation values for the times specified by <cite>taulist</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_3op_2t">
<code class="descname">correlation_3op_2t</code><span class="sig-paren">(</span><em>H</em>, <em>state0</em>, <em>tlist</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>c_op</em>, <em>solver=’me’</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_3op_2t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_3op_2t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the three-operator two-time correlation function:
<span class="math">\(\left&lt;A(t)B(t+\tau)C(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math">\(\tau&lt;0\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : Qobj</p>
<blockquote>
<div><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</div></blockquote>
<p><strong>rho0</strong> : Qobj</p>
<blockquote>
<div><p>Initial state density matrix <span class="math">\(\rho_0\)</span> or state vector
<span class="math">\(\psi_0\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</div></blockquote>
<p><strong>tlist</strong> : array_like</p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. when <span class="math">\(t \rightarrow \infty\)</span>; here
tlist is automatically set, ignoring user input.</p>
</div></blockquote>
<p><strong>taulist</strong> : array_like</p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list</p>
<blockquote>
<div><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</div></blockquote>
<p><strong>a_op</strong> : Qobj</p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : Qobj</p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>c_op</strong> : Qobj</p>
<blockquote>
<div><p>operator C.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</div></blockquote>
<p><strong>options</strong> : Options</p>
<blockquote>
<div><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_mat</strong> : array</p>
<blockquote class="last">
<div><p>An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional array of correlation values
is returned instead.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_4op_1t">
<code class="descname">correlation_4op_1t</code><span class="sig-paren">(</span><em>H</em>, <em>state0</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>c_op</em>, <em>d_op</em>, <em>solver=’me’</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_4op_1t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_4op_1t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the four-operator two-time correlation function:
<span class="math">\(\left&lt;A(t)B(t+\tau)C(t+\tau)D(t)\right&gt;\)</span>
along one time axis using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math">\(\tau&lt;0\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : Qobj</p>
<blockquote>
<div><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</div></blockquote>
<p><strong>rho0</strong> : Qobj</p>
<blockquote>
<div><p>Initial state density matrix <span class="math">\(\rho(t_0)\)</span> or state vector
<span class="math">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</div></blockquote>
<p><strong>taulist</strong> : array_like</p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list</p>
<blockquote>
<div><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</div></blockquote>
<p><strong>a_op</strong> : Qobj</p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : Qobj</p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>c_op</strong> : Qobj</p>
<blockquote>
<div><p>operator C.</p>
</div></blockquote>
<p><strong>d_op</strong> : Qobj</p>
<blockquote>
<div><p>operator D.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</div></blockquote>
<p><strong>options</strong> : Options</p>
<blockquote>
<div><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_vec</strong> : array</p>
<blockquote class="last">
<div><p>An array of correlation values for the times specified by <cite>taulist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Deprecated in QuTiP 3.1
Use correlation_3op_1t() instead.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_4op_2t">
<code class="descname">correlation_4op_2t</code><span class="sig-paren">(</span><em>H</em>, <em>state0</em>, <em>tlist</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>c_op</em>, <em>d_op</em>, <em>solver=’me’</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_4op_2t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_4op_2t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the four-operator two-time correlation function:
<span class="math">\(\left&lt;A(t)B(t+\tau)C(t+\tau)D(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math">\(\tau&lt;0\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : Qobj</p>
<blockquote>
<div><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</div></blockquote>
<p><strong>rho0</strong> : Qobj</p>
<blockquote>
<div><p>Initial state density matrix <span class="math">\(\rho_0\)</span> or state vector
<span class="math">\(\psi_0\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</div></blockquote>
<p><strong>tlist</strong> : array_like</p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. when <span class="math">\(t \rightarrow \infty\)</span>; here
tlist is automatically set, ignoring user input.</p>
</div></blockquote>
<p><strong>taulist</strong> : array_like</p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list</p>
<blockquote>
<div><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</div></blockquote>
<p><strong>a_op</strong> : Qobj</p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : Qobj</p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>c_op</strong> : Qobj</p>
<blockquote>
<div><p>operator C.</p>
</div></blockquote>
<p><strong>d_op</strong> : Qobj</p>
<blockquote>
<div><p>operator D.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</div></blockquote>
<p><strong>options</strong> : Options</p>
<blockquote>
<div><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_mat</strong> : array</p>
<blockquote class="last">
<div><p>An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional array of correlation values
is returned instead.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum">
<code class="descname">spectrum</code><span class="sig-paren">(</span><em>H</em>, <em>wlist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>solver=’es’</em>, <em>use_pinv=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#spectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum of the correlation function
<span class="math">\(\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>,
i.e., the Fourier transform of the correlation function:</p>
<div class="math">
\[S(\omega) = \int_{-\infty}^{\infty}
\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;
e^{-i\omega\tau} d\tau.\]</div>
<p>using the solver indicated by the <cite>solver</cite> parameter. Note: this spectrum
is only defined for stationary statistics (uses steady state rho0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>wlist</strong> : array_like</p>
<blockquote>
<div><p>list of frequencies for <span class="math">\(\omega\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list</p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : Qobj</p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : Qobj</p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>es</cite> for exponential series and
<cite>pi</cite> for psuedo-inverse).</p>
</div></blockquote>
<p><strong>use_pinv</strong> : bool</p>
<blockquote>
<div><p>For use with the <cite>pi</cite> solver: if <cite>True</cite> use numpy’s pinv method,
otherwise use a generic solver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>spectrum</strong> : array</p>
<blockquote class="last">
<div><p>An array with spectrum <span class="math">\(S(\omega)\)</span> for the frequencies
specified in <cite>wlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum_ss">
<code class="descname">spectrum_ss</code><span class="sig-paren">(</span><em>H</em>, <em>wlist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#spectrum_ss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.spectrum_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum of the correlation function
<span class="math">\(\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>,
i.e., the Fourier transform of the correlation function:</p>
<div class="math">
\[S(\omega) = \int_{-\infty}^{\infty}
\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;
e^{-i\omega\tau} d\tau.\]</div>
<p>using an eseries based solver Note: this spectrum is only defined for
stationary statistics (uses steady state rho0).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>wlist</strong> : array_like</p>
<blockquote>
<div><p>list of frequencies for <span class="math">\(\omega\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : <em>list</em> of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>use_pinv</strong> : <em>bool</em></p>
<blockquote>
<div><p>If <cite>True</cite> use numpy’s <cite>pinv</cite> method, otherwise use a generic solver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>spectrum</strong> : array</p>
<blockquote class="last">
<div><p>An array with spectrum <span class="math">\(S(\omega)\)</span> for the frequencies
specified in <cite>wlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum_pi">
<code class="descname">spectrum_pi</code><span class="sig-paren">(</span><em>H</em>, <em>wlist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>use_pinv=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#spectrum_pi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.spectrum_pi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum of the correlation function
<span class="math">\(\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>,
i.e., the Fourier transform of the correlation function:</p>
<div class="math">
\[S(\omega) = \int_{-\infty}^{\infty}
\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;
e^{-i\omega\tau} d\tau.\]</div>
<p>using a psuedo-inverse method. Note: this spectrum is only defined for
stationary statistics (uses steady state rho0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>wlist</strong> : array_like</p>
<blockquote>
<div><p>list of frequencies for <span class="math">\(\omega\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : <em>list</em> of <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></code></p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>use_pinv</strong> : <em>bool</em></p>
<blockquote>
<div><p>If <cite>True</cite> use numpy’s pinv method, otherwise use a generic solver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>spectrum</strong> : array</p>
<blockquote class="last">
<div><p>An array with spectrum <span class="math">\(S(\omega)\)</span> for the frequencies
specified in <cite>wlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum_correlation_fft">
<code class="descname">spectrum_correlation_fft</code><span class="sig-paren">(</span><em>tlist</em>, <em>y</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#spectrum_correlation_fft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.spectrum_correlation_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the power spectrum corresponding to a two-time correlation
function using FFT.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tlist</strong> : array_like</p>
<blockquote>
<div><p>list/array of times <span class="math">\(t\)</span> which the correlation function is given.</p>
</div></blockquote>
<p><strong>y</strong> : array_like</p>
<blockquote>
<div><p>list/array of correlations corresponding to time delays <span class="math">\(t\)</span>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>w, S</strong> : tuple</p>
<blockquote class="last">
<div><p>Returns an array of angular frequencies ‘w’ and the corresponding
one-sided power spectrum ‘S(w)’.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.coherence_function_g1">
<code class="descname">coherence_function_g1</code><span class="sig-paren">(</span><em>H</em>, <em>state0</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>solver=’me’</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#coherence_function_g1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.coherence_function_g1" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the normalized first-order quantum coherence function:</p>
<div class="math">
\[g^{(1)}(\tau) =
\frac{\langle A^\dagger(\tau)A(0)\rangle}
{\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle
        \langle A^\dagger(0)A(0)\rangle}}\]</div>
<p>using the quantum regression theorem and the evolution solver indicated by
the <cite>solver</cite> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : Qobj</p>
<blockquote>
<div><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</div></blockquote>
<p><strong>state0</strong> : Qobj</p>
<blockquote>
<div><p>Initial state density matrix <span class="math">\(\rho(t_0)\)</span> or state vector
<span class="math">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</div></blockquote>
<p><strong>taulist</strong> : array_like</p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list</p>
<blockquote>
<div><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</div></blockquote>
<p><strong>a_op</strong> : Qobj</p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation and
<cite>es</cite> for exponential series).</p>
</div></blockquote>
<p><strong>options</strong> : Options</p>
<blockquote>
<div><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>g1, G1</strong> : tuple</p>
<blockquote class="last">
<div><p>The normalized and unnormalized second-order coherence function.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.coherence_function_g2">
<code class="descname">coherence_function_g2</code><span class="sig-paren">(</span><em>H</em>, <em>state0</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>solver=’me’</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#coherence_function_g2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.coherence_function_g2" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the normalized second-order quantum coherence function:</p>
<div class="math">
\[ g^{(2)}(\tau) =
\frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}
{\langle A^\dagger(\tau)A(\tau)\rangle
 \langle A^\dagger(0)A(0)\rangle}\]</div>
<p>using the quantum regression theorem and the evolution solver indicated by
the <cite>solver</cite> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : Qobj</p>
<blockquote>
<div><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</div></blockquote>
<p><strong>state0</strong> : Qobj</p>
<blockquote>
<div><p>Initial state density matrix <span class="math">\(\rho(t_0)\)</span> or state vector
<span class="math">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</div></blockquote>
<p><strong>taulist</strong> : array_like</p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list</p>
<blockquote>
<div><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</div></blockquote>
<p><strong>a_op</strong> : Qobj</p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation and
<cite>es</cite> for exponential series).</p>
</div></blockquote>
<p><strong>options</strong> : Options</p>
<blockquote>
<div><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>g2, G2</strong> : tuple</p>
<blockquote class="last">
<div><p>The normalized and unnormalized second-order coherence function.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.steadystate">
<span id="steady-state-solvers"></span><h3>Steady-state Solvers<a class="headerlink" href="#module-qutip.steadystate" title="Permalink to this headline">¶</a></h3>
<p>Module contains functions for solving for the steady state density matrix of
open quantum systems defined by a Liouvillian or Hamiltonian and a list of
collapse operators.</p>
<dl class="function">
<dt id="qutip.steadystate.steadystate">
<code class="descname">steadystate</code><span class="sig-paren">(</span><em>A</em>, <em>c_op_list=[]</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/steadystate.html#steadystate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.steadystate.steadystate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the steady state for quantum evolution subject to the
supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a
list of collapse operators.</p>
<p>If the user passes a Hamiltonian then it, along with the list of collapse
operators, will be converted into a Liouvillian operator in Lindblad form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>A Hamiltonian or Liouvillian operator.</p>
</div></blockquote>
<p><strong>c_op_list</strong> : list</p>
<blockquote>
<div><p>A list of collapse operators.</p>
</div></blockquote>
<p><strong>method</strong> : str {‘direct’, ‘eigen’, ‘iterative-gmres’,</p>
<blockquote>
<div><blockquote>
<div><p>‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,
‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}</p>
</div></blockquote>
<p>Method for solving the underlying linear equation. Direct LU solver
‘direct’ (default), sparse eigenvalue problem ‘eigen’,
iterative GMRES method ‘iterative-gmres’, iterative LGMRES method
‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,
SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative
power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use
the same solvers as their direct counterparts.</p>
</div></blockquote>
<p><strong>return_info</strong> : bool, optional, default = False</p>
<blockquote>
<div><p>Return a dictionary of solver-specific infomation about the
solution and how it was obtained.</p>
</div></blockquote>
<p><strong>sparse</strong> : bool, optional, default = True</p>
<blockquote>
<div><p>Solve for the steady state using sparse algorithms. If set to False,
the underlying Liouvillian operator will be converted into a dense
matrix. Use only for ‘smaller’ systems.</p>
</div></blockquote>
<p><strong>use_rcm</strong> : bool, optional, default = False</p>
<blockquote>
<div><p>Use reverse Cuthill-Mckee reordering to minimize fill-in in the
LU factorization of the Liouvillian.</p>
</div></blockquote>
<p><strong>use_wbm</strong> : bool, optional, default = False</p>
<blockquote>
<div><p>Use Weighted Bipartite Matching reordering to make the Liouvillian
diagonally dominant.  This is useful for iterative preconditioners
only, and is set to <code class="docutils literal"><span class="pre">True</span></code> by default when finding a preconditioner.</p>
</div></blockquote>
<p><strong>weight</strong> : float, optional</p>
<blockquote>
<div><p>Sets the size of the elements used for adding the unity trace condition
to the linear solvers.  This is set to the average abs value of the
Liouvillian elements if not specified by the user.</p>
</div></blockquote>
<p><strong>x0</strong> : ndarray, optional</p>
<blockquote>
<div><p>ITERATIVE ONLY. Initial guess for solution vector.</p>
</div></blockquote>
<p><strong>maxiter</strong> : int, optional, default=1000</p>
<blockquote>
<div><p>ITERATIVE ONLY. Maximum number of iterations to perform.</p>
</div></blockquote>
<p><strong>tol</strong> : float, optional, default=1e-12</p>
<blockquote>
<div><p>ITERATIVE ONLY. Tolerance used for terminating solver.</p>
</div></blockquote>
<p><strong>permc_spec</strong> : str, optional, default=’COLAMD’</p>
<blockquote>
<div><p>ITERATIVE ONLY. Column ordering used internally by superLU for the
‘direct’ LU decomposition method. Options include ‘COLAMD’ and
‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically
unless explicitly specified.</p>
</div></blockquote>
<p><strong>use_precond</strong> : bool optional, default = False</p>
<blockquote>
<div><p>ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a
preconditioner for the ‘iterative’ GMRES and BICG solvers.
Speeds up convergence time by orders of magnitude in many cases.</p>
</div></blockquote>
<p><strong>M</strong> : {sparse matrix, dense matrix, LinearOperator}, optional</p>
<blockquote>
<div><p>ITERATIVE ONLY. Preconditioner for A. The preconditioner should
approximate the inverse of A. Effective preconditioning can
dramatically improve the rate of convergence for iterative methods.
If no preconditioner is given and <code class="docutils literal"><span class="pre">use_precond</span> <span class="pre">=</span> <span class="pre">True</span></code>, then one
is generated automatically.</p>
</div></blockquote>
<p><strong>fill_factor</strong> : float, optional, default = 100</p>
<blockquote>
<div><p>ITERATIVE ONLY. Specifies the fill ratio upper bound (&gt;=1) of the iLU
preconditioner.  Lower values save memory at the cost of longer
execution times and a possible singular factorization.</p>
</div></blockquote>
<p><strong>drop_tol</strong> : float, optional, default = 1e-4</p>
<blockquote>
<div><p>ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner
elements that should be dropped.  Can be reduced for a courser
factorization at the cost of an increased number of iterations, and a
possible singular factorization.</p>
</div></blockquote>
<p><strong>diag_pivot_thresh</strong> : float, optional, default = None</p>
<blockquote>
<div><p>ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal
elements are considered acceptable pivot points when using a
preconditioner.  A value of zero forces the pivot to be the diagonal
element.</p>
</div></blockquote>
<p><strong>ILU_MILU</strong> : str, optional, default = ‘smilu_2’</p>
<blockquote>
<div><p>ITERATIVE ONLY. Selects the incomplete LU decomposition method
algoithm used in creating the preconditoner. Should only be used by
advanced users.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dm</strong> : qobj</p>
<blockquote>
<div><p>Steady state density matrix.</p>
</div></blockquote>
<p><strong>info</strong> : dict, optional</p>
<blockquote class="last">
<div><p>Dictionary containing solver-specific information about the solution.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The SVD method works only for dense operators (i.e. small systems).</p>
</dd></dl>

<dl class="function">
<dt id="qutip.steadystate.build_preconditioner">
<code class="descname">build_preconditioner</code><span class="sig-paren">(</span><em>A</em>, <em>c_op_list=[]</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/steadystate.html#build_preconditioner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.steadystate.build_preconditioner" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a iLU preconditioner necessary for solving for
the steady state density matrix using the iterative linear solvers
in the ‘steadystate’ function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>A Hamiltonian or Liouvillian operator.</p>
</div></blockquote>
<p><strong>c_op_list</strong> : list</p>
<blockquote>
<div><p>A list of collapse operators.</p>
</div></blockquote>
<p><strong>return_info</strong> : bool, optional, default = False</p>
<blockquote>
<div><p>Return a dictionary of solver-specific infomation about the
solution and how it was obtained.</p>
</div></blockquote>
<p><strong>use_rcm</strong> : bool, optional, default = False</p>
<blockquote>
<div><p>Use reverse Cuthill-Mckee reordering to minimize fill-in in the
LU factorization of the Liouvillian.</p>
</div></blockquote>
<p><strong>use_wbm</strong> : bool, optional, default = False</p>
<blockquote>
<div><p>Use Weighted Bipartite Matching reordering to make the Liouvillian
diagonally dominant.  This is useful for iterative preconditioners
only, and is set to <code class="docutils literal"><span class="pre">True</span></code> by default when finding a preconditioner.</p>
</div></blockquote>
<p><strong>weight</strong> : float, optional</p>
<blockquote>
<div><p>Sets the size of the elements used for adding the unity trace condition
to the linear solvers.  This is set to the average abs value of the
Liouvillian elements if not specified by the user.</p>
</div></blockquote>
<p><strong>method</strong> : str, default = ‘iterative’</p>
<blockquote>
<div><p>Tells the preconditioner what type of Liouvillian to build for
iLU factorization.  For direct iterative methods use ‘iterative’.
For power iterative methods use ‘power’.</p>
</div></blockquote>
<p><strong>permc_spec</strong> : str, optional, default=’COLAMD’</p>
<blockquote>
<div><p>Column ordering used internally by superLU for the
‘direct’ LU decomposition method. Options include ‘COLAMD’ and
‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically
unless explicitly specified.</p>
</div></blockquote>
<p><strong>fill_factor</strong> : float, optional, default = 100</p>
<blockquote>
<div><p>Specifies the fill ratio upper bound (&gt;=1) of the iLU
preconditioner.  Lower values save memory at the cost of longer
execution times and a possible singular factorization.</p>
</div></blockquote>
<p><strong>drop_tol</strong> : float, optional, default = 1e-4</p>
<blockquote>
<div><p>Sets the threshold for the magnitude of preconditioner
elements that should be dropped.  Can be reduced for a courser
factorization at the cost of an increased number of iterations, and a
possible singular factorization.</p>
</div></blockquote>
<p><strong>diag_pivot_thresh</strong> : float, optional, default = None</p>
<blockquote>
<div><p>Sets the threshold between [0,1] for which diagonal
elements are considered acceptable pivot points when using a
preconditioner.  A value of zero forces the pivot to be the diagonal
element.</p>
</div></blockquote>
<p><strong>ILU_MILU</strong> : str, optional, default = ‘smilu_2’</p>
<blockquote>
<div><p>Selects the incomplete LU decomposition method algoithm used in
creating the preconditoner. Should only be used by advanced users.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lu</strong> : object</p>
<blockquote>
<div><p>Returns a SuperLU object representing iLU preconditioner.</p>
</div></blockquote>
<p><strong>info</strong> : dict, optional</p>
<blockquote class="last">
<div><p>Dictionary containing solver-specific information.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.propagator">
<span id="propagators"></span><h3>Propagators<a class="headerlink" href="#module-qutip.propagator" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.propagator.propagator">
<code class="descname">propagator</code><span class="sig-paren">(</span><em>H</em>, <em>t</em>, <em>c_op_list=[]</em>, <em>args={}</em>, <em>options=None</em>, <em>unitary_mode=’batch’</em>, <em>parallel=False</em>, <em>progress_bar=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/propagator.html#propagator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.propagator.propagator" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the propagator U(t) for the density matrix or wave function such
that <span class="math">\(\psi(t) = U(t)\psi(0)\)</span> or
<span class="math">\(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\)</span>
where <span class="math">\(\rho_{\mathrm vec}\)</span> is the vector representation of the
density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : qobj or list</p>
<blockquote>
<div><p>Hamiltonian as a Qobj instance of a nested list of Qobjs and
coefficients in the list-string or list-function format for
time-dependent Hamiltonians (see description in <a class="reference internal" href="#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal"><span class="pre">qutip.mesolve</span></code></a>).</p>
</div></blockquote>
<p><strong>t</strong> : float or array-like</p>
<blockquote>
<div><p>Time or list of times for which to evaluate the propagator.</p>
</div></blockquote>
<p><strong>c_op_list</strong> : list</p>
<blockquote>
<div><p>List of qobj collapse operators.</p>
</div></blockquote>
<p><strong>args</strong> : list/array/dictionary</p>
<blockquote>
<div><p>Parameters to callback functions for time-dependent Hamiltonians and
collapse operators.</p>
</div></blockquote>
<p><strong>options</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.Options</span></code></p>
<blockquote>
<div><p>with options for the ODE solver.</p>
</div></blockquote>
<p><strong>unitary_mode = str (‘batch’, ‘single’)</strong></p>
<blockquote>
<div><p>Solve all basis vectors simulaneously (‘batch’) or individually
(‘single’).</p>
</div></blockquote>
<p><strong>parallel</strong> : bool {False, True}</p>
<blockquote>
<div><p>Run the propagator in parallel mode. This will override the
unitary_mode settings if set to True.</p>
</div></blockquote>
<p><strong>progress_bar: BaseProgressBar</strong></p>
<blockquote>
<div><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation. By default no progress bar
is used, and if set to True a TextProgressBar will be used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>a</strong> : qobj</p>
<blockquote class="last">
<div><p>Instance representing the propagator <span class="math">\(U(t)\)</span>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.propagator.propagator_steadystate">
<code class="descname">propagator_steadystate</code><span class="sig-paren">(</span><em>U</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/propagator.html#propagator_steadystate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.propagator.propagator_steadystate" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the steady state for successive applications of the propagator
<span class="math">\(U\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : qobj</p>
<blockquote>
<div><p>Operator representing the propagator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>a</strong> : qobj</p>
<blockquote class="last">
<div><p>Instance representing the steady-state density matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.rhs_generate">
<span id="time-dependent-problems"></span><h3>Time-dependent problems<a class="headerlink" href="#module-qutip.rhs_generate" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.rhs_generate.rhs_generate">
<code class="descname">rhs_generate</code><span class="sig-paren">(</span><em>H</em>, <em>c_ops</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em>, <em>name=None</em>, <em>cleanup=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/rhs_generate.html#rhs_generate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.rhs_generate.rhs_generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the Cython functions needed for solving the dynamics of a
given system using the mesolve function inside a parfor loop.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : qobj</p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">list</span></code> of collapse operators.</p>
</div></blockquote>
<p><strong>args</strong> : dict</p>
<blockquote>
<div><p>Arguments for time-dependent Hamiltonian and collapse operator terms.</p>
</div></blockquote>
<p><strong>options</strong> : Options</p>
<blockquote>
<div><p>Instance of ODE solver options.</p>
</div></blockquote>
<p><strong>name: str</strong></p>
<blockquote>
<div><p>Name of generated RHS</p>
</div></blockquote>
<p><strong>cleanup: bool</strong></p>
<blockquote class="last">
<div><p>Whether the generated cython file should be automatically removed or
not.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Using this function with any solver other than the mesolve function
will result in an error.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.rhs_generate.rhs_clear">
<code class="descname">rhs_clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/rhs_generate.html#rhs_clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.rhs_generate.rhs_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the string-format time-dependent Hamiltonian parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Nothing, just clears data from internal config module.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="visualization">
<h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.wigner">
<span id="pseudoprobability-functions"></span><h3>Pseudoprobability Functions<a class="headerlink" href="#module-qutip.wigner" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.wigner.qfunc">
<code class="descname">qfunc</code><span class="sig-paren">(</span><em>state</em>, <em>xvec</em>, <em>yvec</em>, <em>g=1.4142135623730951</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/wigner.html#qfunc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.wigner.qfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Q-function of a given state vector or density matrix
at points <cite>xvec + i * yvec</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote>
<div><p>A state vector or density matrix.</p>
</div></blockquote>
<p><strong>xvec</strong> : array_like</p>
<blockquote>
<div><p>x-coordinates at which to calculate the Wigner function.</p>
</div></blockquote>
<p><strong>yvec</strong> : array_like</p>
<blockquote>
<div><p>y-coordinates at which to calculate the Wigner function.</p>
</div></blockquote>
<p><strong>g</strong> : float</p>
<blockquote>
<div><p>Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Q</strong> : array</p>
<blockquote class="last">
<div><p>Values representing the Q-function calculated over the specified range
[xvec,yvec].</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.wigner.spin_q_function">
<code class="descname">spin_q_function</code><span class="sig-paren">(</span><em>rho</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/wigner.html#spin_q_function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.wigner.spin_q_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Husimi Q-function for spins.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote>
<div><p>A state vector or density matrix for a spin-j quantum system.</p>
</div></blockquote>
<p><strong>theta</strong> : array_like</p>
<blockquote>
<div><p>theta-coordinates at which to calculate the Q function.</p>
</div></blockquote>
<p><strong>phi</strong> : array_like</p>
<blockquote>
<div><p>phi-coordinates at which to calculate the Q function.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Q, THETA, PHI</strong> : 2d-array</p>
<blockquote class="last">
<div><p>Values representing the spin Q function at the values specified
by THETA and PHI.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.wigner.spin_wigner">
<code class="descname">spin_wigner</code><span class="sig-paren">(</span><em>rho</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/wigner.html#spin_wigner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.wigner.spin_wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>Wigner function for spins on the Bloch sphere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote>
<div><p>A state vector or density matrix for a spin-j quantum system.</p>
</div></blockquote>
<p><strong>theta</strong> : array_like</p>
<blockquote>
<div><p>theta-coordinates at which to calculate the Q function.</p>
</div></blockquote>
<p><strong>phi</strong> : array_like</p>
<blockquote>
<div><p>phi-coordinates at which to calculate the Q function.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>W, THETA, PHI</strong> : 2d-array</p>
<blockquote class="last">
<div><p>Values representing the spin Wigner function at the values specified
by THETA and PHI.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Experimental.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.wigner.wigner">
<code class="descname">wigner</code><span class="sig-paren">(</span><em>psi</em>, <em>xvec</em>, <em>yvec</em>, <em>method=’clenshaw’</em>, <em>g=1.4142135623730951</em>, <em>sparse=False</em>, <em>parfor=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/wigner.html#wigner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.wigner.wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>Wigner function for a state vector or density matrix at points
<cite>xvec + i * yvec</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote>
<div><p>A state vector or density matrix.</p>
</div></blockquote>
<p><strong>xvec</strong> : array_like</p>
<blockquote>
<div><p>x-coordinates at which to calculate the Wigner function.</p>
</div></blockquote>
<p><strong>yvec</strong> : array_like</p>
<blockquote>
<div><p>y-coordinates at which to calculate the Wigner function.  Does not
apply to the ‘fft’ method.</p>
</div></blockquote>
<p><strong>g</strong> : float</p>
<blockquote>
<div><p>Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.</p>
</div></blockquote>
<p><strong>method</strong> : string {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}</p>
<blockquote>
<div><p>Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’
and ‘iterative’ use an iterative method to evaluate the Wigner functions for density
matrices <span class="math">\(|m&gt;&lt;n|\)</span>, while ‘laguerre’ uses the Laguerre polynomials
in scipy for the same task. The ‘fft’ method evaluates the Fourier
transform of the density matrix. The ‘iterative’ method is default, and
in general recommended, but the ‘laguerre’ method is more efficient for
very sparse density matrices (e.g., superpositions of Fock states in a
large Hilbert space). The ‘clenshaw’ method is the preferred method for
dealing with density matrices that have a large number of excitations
(&gt;~50). ‘clenshaw’ is a fast and numerically stable method.</p>
</div></blockquote>
<p><strong>sparse</strong> : bool {False, True}</p>
<blockquote>
<div><p>Tells the default solver whether or not to keep the input density
matrix in sparse format.  As the dimensions of the density matrix
grow, setthing this flag can result in increased performance.</p>
</div></blockquote>
<p><strong>parfor</strong> : bool {False, True}</p>
<blockquote>
<div><p>Flag for calculating the Laguerre polynomial based Wigner function
method=’laguerre’ in parallel using the parfor function.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>W</strong> : array</p>
<blockquote>
<div><p>Values representing the Wigner function calculated over the specified
range [xvec,yvec].</p>
</div></blockquote>
<p><strong>yvex</strong> : array</p>
<blockquote class="last">
<div><p>FFT ONLY. Returns the y-coordinate values calculated via the Fourier
transform.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The ‘fft’ method accepts only an xvec input for the x-coordinate.
The y-coordinates are calculated internally.</p>
<p class="rubric">References</p>
<p>Ulf Leonhardt,
Measuring the Quantum State of Light, (Cambridge University Press, 1997)</p>
</dd></dl>

</div>
<div class="section" id="graphs-and-visualization">
<h3>Graphs and Visualization<a class="headerlink" href="#graphs-and-visualization" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-qutip.visualization"></span><p>Functions for visualizing results of quantum dynamics simulations,
visualizations of quantum states and processes.</p>
<dl class="function">
<dt id="qutip.visualization.hinton">
<code class="descname">hinton</code><span class="sig-paren">(</span><em>rho</em>, <em>xlabels=None</em>, <em>ylabels=None</em>, <em>title=None</em>, <em>ax=None</em>, <em>cmap=None</em>, <em>label_top=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#hinton"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.hinton" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a Hinton diagram for visualizing a density matrix or superoperator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : qobj</p>
<blockquote>
<div><p>Input density matrix or superoperator.</p>
</div></blockquote>
<p><strong>xlabels</strong> : list of strings or False</p>
<blockquote>
<div><p>list of x labels</p>
</div></blockquote>
<p><strong>ylabels</strong> : list of strings or False</p>
<blockquote>
<div><p>list of y labels</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>title of the plot (optional)</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>cmap</strong> : a matplotlib colormap instance</p>
<blockquote>
<div><p>Color map to use when plotting.</p>
</div></blockquote>
<p><strong>label_top</strong> : bool</p>
<blockquote>
<div><p>If True, x-axis labels will be placed on top, otherwise
they will appear below the plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote>
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>Input argument is not a quantum object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.matrix_histogram">
<code class="descname">matrix_histogram</code><span class="sig-paren">(</span><em>M</em>, <em>xlabels=None</em>, <em>ylabels=None</em>, <em>title=None</em>, <em>limits=None</em>, <em>colorbar=True</em>, <em>fig=None</em>, <em>ax=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#matrix_histogram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.matrix_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a histogram for the matrix M, with the given x and y labels and title.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>M</strong> : Matrix of Qobj</p>
<blockquote>
<div><p>The matrix to visualize</p>
</div></blockquote>
<p><strong>xlabels</strong> : list of strings</p>
<blockquote>
<div><p>list of x labels</p>
</div></blockquote>
<p><strong>ylabels</strong> : list of strings</p>
<blockquote>
<div><p>list of y labels</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>title of the plot (optional)</p>
</div></blockquote>
<p><strong>limits</strong> : list/array with two float numbers</p>
<blockquote>
<div><p>The z-axis limits [min, max] (optional)</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote>
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>Input argument is not valid.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.matrix_histogram_complex">
<code class="descname">matrix_histogram_complex</code><span class="sig-paren">(</span><em>M</em>, <em>xlabels=None</em>, <em>ylabels=None</em>, <em>title=None</em>, <em>limits=None</em>, <em>phase_limits=None</em>, <em>colorbar=True</em>, <em>fig=None</em>, <em>ax=None</em>, <em>threshold=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#matrix_histogram_complex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.matrix_histogram_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a histogram for the amplitudes of matrix M, using the argument
of each element for coloring the bars, with the given x and y labels
and title.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>M</strong> : Matrix of Qobj</p>
<blockquote>
<div><p>The matrix to visualize</p>
</div></blockquote>
<p><strong>xlabels</strong> : list of strings</p>
<blockquote>
<div><p>list of x labels</p>
</div></blockquote>
<p><strong>ylabels</strong> : list of strings</p>
<blockquote>
<div><p>list of y labels</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>title of the plot (optional)</p>
</div></blockquote>
<p><strong>limits</strong> : list/array with two float numbers</p>
<blockquote>
<div><p>The z-axis limits [min, max] (optional)</p>
</div></blockquote>
<p><strong>phase_limits</strong> : list/array with two float numbers</p>
<blockquote>
<div><p>The phase-axis (colorbar) limits [min, max] (optional)</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>threshold: float (None)</strong></p>
<blockquote>
<div><p>Threshold for when bars of smaller height should be transparent. If
not set, all bars are colored according to the color map.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote>
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>Input argument is not valid.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_energy_levels">
<code class="descname">plot_energy_levels</code><span class="sig-paren">(</span><em>H_list</em>, <em>N=0</em>, <em>labels=None</em>, <em>show_ylabels=False</em>, <em>figsize=(8</em>, <em>12)</em>, <em>fig=None</em>, <em>ax=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_energy_levels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_energy_levels" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the energy level diagrams for a list of Hamiltonians. Include
up to N energy levels. For each element in H_list, the energy
levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,
where n is the index of an element in H_list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H_list</strong> : List of Qobj</p>
<blockquote>
<div><blockquote>
<div><p>A list of Hamiltonians.</p>
</div></blockquote>
<dl class="docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">List of string</span></dt>
<dd><p class="first last">A list of labels for each Hamiltonian</p>
</dd>
<dt>show_ylabels <span class="classifier-delimiter">:</span> <span class="classifier">Bool (default False)</span></dt>
<dd><p class="first last">Show y labels to the left of energy levels of the initial
Hamiltonian.</p>
</dd>
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of energy levels to plot</p>
</dd>
<dt>figsize <span class="classifier-delimiter">:</span> <span class="classifier">tuple (int,int)</span></dt>
<dd><p class="first last">The size of the figure (width, height).</p>
</dd>
<dt>fig <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib Figure instance</span></dt>
<dd><p class="first last">The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt>ax <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib axes instance</span></dt>
<dd><p class="first last">The axes context in which the plot will be drawn.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote>
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>Input argument is not valid.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_fock_distribution">
<code class="descname">plot_fock_distribution</code><span class="sig-paren">(</span><em>rho</em>, <em>offset=0</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(8</em>, <em>6)</em>, <em>title=None</em>, <em>unit_y_range=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_fock_distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_fock_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the Fock distribution for a density matrix (or ket) that describes
an oscillator mode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></code></p>
<blockquote>
<div><p>The density matrix (or ket) of the state to visualize.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib Figure instance</p>
<blockquote>
<div><p>The Figure canvas in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>An optional title for the figure.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_wigner_fock_distribution">
<code class="descname">plot_wigner_fock_distribution</code><span class="sig-paren">(</span><em>rho</em>, <em>fig=None</em>, <em>axes=None</em>, <em>figsize=(8</em>, <em>4)</em>, <em>cmap=None</em>, <em>alpha_max=7.5</em>, <em>colorbar=False</em>, <em>method=’iterative’</em>, <em>projection=‘2d’</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_wigner_fock_distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_wigner_fock_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the Fock distribution and the Wigner function for a density matrix
(or ket) that describes an oscillator mode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></code></p>
<blockquote>
<div><p>The density matrix (or ket) of the state to visualize.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib Figure instance</p>
<blockquote>
<div><p>The Figure canvas in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>axes</strong> : a list of two matplotlib axes instances</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</div></blockquote>
<p><strong>cmap</strong> : a matplotlib cmap instance</p>
<blockquote>
<div><p>The colormap.</p>
</div></blockquote>
<p><strong>alpha_max</strong> : float</p>
<blockquote>
<div><p>The span of the x and y coordinates (both [-alpha_max, alpha_max]).</p>
</div></blockquote>
<p><strong>colorbar</strong> : bool</p>
<blockquote>
<div><p>Whether (True) or not (False) a colorbar should be attached to the
Wigner function graph.</p>
</div></blockquote>
<p><strong>method</strong> : string {‘iterative’, ‘laguerre’, ‘fft’}</p>
<blockquote>
<div><p>The method used for calculating the wigner function. See the
documentation for qutip.wigner for details.</p>
</div></blockquote>
<p><strong>projection: string {‘2d’, ‘3d’}</strong></p>
<blockquote>
<div><p>Specify whether the Wigner function is to be plotted as a
contour graph (‘2d’) or surface plot (‘3d’).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_wigner">
<code class="descname">plot_wigner</code><span class="sig-paren">(</span><em>rho</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(8</em>, <em>4)</em>, <em>cmap=None</em>, <em>alpha_max=7.5</em>, <em>colorbar=False</em>, <em>method=’iterative’</em>, <em>projection=‘2d’</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_wigner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the the Wigner function for a density matrix (or ket) that describes
an oscillator mode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : <code class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></code></p>
<blockquote>
<div><p>The density matrix (or ket) of the state to visualize.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib Figure instance</p>
<blockquote>
<div><p>The Figure canvas in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</div></blockquote>
<p><strong>cmap</strong> : a matplotlib cmap instance</p>
<blockquote>
<div><p>The colormap.</p>
</div></blockquote>
<p><strong>alpha_max</strong> : float</p>
<blockquote>
<div><p>The span of the x and y coordinates (both [-alpha_max, alpha_max]).</p>
</div></blockquote>
<p><strong>colorbar</strong> : bool</p>
<blockquote>
<div><p>Whether (True) or not (False) a colorbar should be attached to the
Wigner function graph.</p>
</div></blockquote>
<p><strong>method</strong> : string {‘iterative’, ‘laguerre’, ‘fft’}</p>
<blockquote>
<div><p>The method used for calculating the wigner function. See the
documentation for qutip.wigner for details.</p>
</div></blockquote>
<p><strong>projection: string {‘2d’, ‘3d’}</strong></p>
<blockquote>
<div><p>Specify whether the Wigner function is to be plotted as a
contour graph (‘2d’) or surface plot (‘3d’).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.sphereplot">
<code class="descname">sphereplot</code><span class="sig-paren">(</span><em>theta</em>, <em>phi</em>, <em>values</em>, <em>fig=None</em>, <em>ax=None</em>, <em>save=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#sphereplot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.sphereplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a matrix of values on a sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : float</p>
<blockquote>
<div><p>Angle with respect to z-axis</p>
</div></blockquote>
<p><strong>phi</strong> : float</p>
<blockquote>
<div><p>Angle in x-y plane</p>
</div></blockquote>
<p><strong>values</strong> : array</p>
<blockquote>
<div><p>Data set to be plotted</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib Figure instance</p>
<blockquote>
<div><p>The Figure canvas in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>save</strong> : bool {False , True}</p>
<blockquote>
<div><p>Whether to save the figure or not</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_schmidt">
<code class="descname">plot_schmidt</code><span class="sig-paren">(</span><em>ket</em>, <em>splitting=None</em>, <em>labels_iteration=(3</em>, <em>2)</em>, <em>theme=’light’</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(6</em>, <em>6)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_schmidt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_schmidt" title="Permalink to this definition">¶</a></dt>
<dd><p>Plotting scheme related to Schmidt decomposition.
Converts a state into a matrix (A_ij -&gt; A_i^j),
where rows are first particles and columns - last.</p>
<p>See also: plot_qubism with how=’before_after’ for a similar plot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ket</strong> : Qobj</p>
<blockquote>
<div><p>Pure state for plotting.</p>
</div></blockquote>
<p><strong>splitting</strong> : int</p>
<blockquote>
<div><p>Plot for a number of first particles versus the rest.
If not given, it is (number of particles + 1) // 2.</p>
</div></blockquote>
<p><strong>theme</strong> : ‘light’ (default) or ‘dark’</p>
<blockquote>
<div><p>Set coloring theme for mapping complex values into colors.
See: complex_array_to_rgb.</p>
</div></blockquote>
<p><strong>labels_iteration</strong> : int or pair of ints (default (3,2))</p>
<blockquote>
<div><p>Number of particles to be shown as tick labels,
for first (vertical) and last (horizontal) particles, respectively.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib figure instance</p>
<blockquote>
<div><p>The figure canvas on which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axis instance</p>
<blockquote>
<div><p>The axis context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_qubism">
<code class="descname">plot_qubism</code><span class="sig-paren">(</span><em>ket</em>, <em>theme=’light’</em>, <em>how=’pairs’</em>, <em>grid_iteration=1</em>, <em>legend_iteration=0</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(6</em>, <em>6)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_qubism"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_qubism" title="Permalink to this definition">¶</a></dt>
<dd><p>Qubism plot for pure states of many qudits.
Works best for spin chains, especially with even number of particles
of the same dimension.
Allows to see entanglement between first 2*k particles and the rest.</p>
<p>More information:</p>
<blockquote>
<div>J. Rodriguez-Laguna, P. Migdal,
M. Ibanez Berganza, M. Lewenstein, G. Sierra,
“Qubism: self-similar visualization of many-body wavefunctions”,
New J. Phys. 14 053028 (2012), arXiv:1112.3560,
http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access)</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ket</strong> : Qobj</p>
<blockquote>
<div><p>Pure state for plotting.</p>
</div></blockquote>
<p><strong>theme</strong> : ‘light’ (default) or ‘dark’</p>
<blockquote>
<div><p>Set coloring theme for mapping complex values into colors.
See: complex_array_to_rgb.</p>
</div></blockquote>
<p><strong>how</strong> : ‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’</p>
<blockquote>
<div><p>Type of Qubism plotting.
Options:</p>
<blockquote>
<div><p>‘pairs’ - typical coordinates,
‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,
‘before_after’ - related to Schmidt plot (see also: plot_schmidt).</p>
</div></blockquote>
</div></blockquote>
<p><strong>grid_iteration</strong> : int (default 1)</p>
<blockquote>
<div><p>Helper lines to be drawn on plot.
Show tiles for 2*grid_iteration particles vs all others.</p>
</div></blockquote>
<p><strong>legend_iteration</strong> : int (default 0) or ‘grid_iteration’ or ‘all’</p>
<blockquote>
<div><p>Show labels for first 2*legend_iteration particles.
Option ‘grid_iteration’ sets the same number of particles</p>
<blockquote>
<div><p>as for grid_iteration.</p>
</div></blockquote>
<p>Option ‘all’ makes label for all particles.
Typically it should be 0, 1, 2 or perhaps 3.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib figure instance</p>
<blockquote>
<div><p>The figure canvas on which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axis instance</p>
<blockquote>
<div><p>The axis context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_expectation_values">
<code class="descname">plot_expectation_values</code><span class="sig-paren">(</span><em>results</em>, <em>ylabels=[]</em>, <em>title=None</em>, <em>show_legend=False</em>, <em>fig=None</em>, <em>axes=None</em>, <em>figsize=(8</em>, <em>4)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_expectation_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_expectation_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the results (expectation values) for an evolution solver.
<cite>results</cite> is assumed to be an instance of Result, or a list of Result
instances.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>results</strong> : (list of) <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal"><span class="pre">qutip.solver.Result</span></code></a></p>
<blockquote>
<div><p>List of results objects returned by any of the QuTiP evolution solvers.</p>
</div></blockquote>
<p><strong>ylabels</strong> : list of strings</p>
<blockquote>
<div><p>The y-axis labels. List should be of the same length as <cite>results</cite>.</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>The title of the figure.</p>
</div></blockquote>
<p><strong>show_legend</strong> : bool</p>
<blockquote>
<div><p>Whether or not to show the legend.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib Figure instance</p>
<blockquote>
<div><p>The Figure canvas in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>axes</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_spin_distribution_2d">
<code class="descname">plot_spin_distribution_2d</code><span class="sig-paren">(</span><em>P</em>, <em>THETA</em>, <em>PHI</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(8</em>, <em>8)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_spin_distribution_2d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_spin_distribution_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a spin distribution function (given as meshgrid data) with a 2D
projection where the surface of the unit sphere is mapped on the unit disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>P</strong> : matrix</p>
<blockquote>
<div><p>Distribution values as a meshgrid matrix.</p>
</div></blockquote>
<p><strong>THETA</strong> : matrix</p>
<blockquote>
<div><p>Meshgrid matrix for the theta coordinate.</p>
</div></blockquote>
<p><strong>PHI</strong> : matrix</p>
<blockquote>
<div><p>Meshgrid matrix for the phi coordinate.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib figure instance</p>
<blockquote>
<div><p>The figure canvas on which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axis instance</p>
<blockquote>
<div><p>The axis context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_spin_distribution_3d">
<code class="descname">plot_spin_distribution_3d</code><span class="sig-paren">(</span><em>P</em>, <em>THETA</em>, <em>PHI</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(8</em>, <em>6)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_spin_distribution_3d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_spin_distribution_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a matrix of values on a sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>P</strong> : matrix</p>
<blockquote>
<div><p>Distribution values as a meshgrid matrix.</p>
</div></blockquote>
<p><strong>THETA</strong> : matrix</p>
<blockquote>
<div><p>Meshgrid matrix for the theta coordinate.</p>
</div></blockquote>
<p><strong>PHI</strong> : matrix</p>
<blockquote>
<div><p>Meshgrid matrix for the phi coordinate.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib figure instance</p>
<blockquote>
<div><p>The figure canvas on which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axis instance</p>
<blockquote>
<div><p>The axis context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-qutip.orbital"></span><dl class="function">
<dt id="qutip.orbital.orbital">
<code class="descname">orbital</code><span class="sig-paren">(</span><em>theta</em>, <em>phi</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/orbital.html#orbital"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.orbital.orbital" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates an angular wave function on a sphere.
<code class="docutils literal"><span class="pre">psi</span> <span class="pre">=</span> <span class="pre">orbital(theta,phi,ket1,ket2,...)</span></code> calculates
the angular wave function on a sphere at the mesh of points
defined by theta and phi which is
<span class="math">\(\sum_{lm} c_{lm} Y_{lm}(theta,phi)\)</span> where <span class="math">\(C_{lm}\)</span> are the
coefficients specified by the list of kets. Each ket has 2l+1 components
for some integer l.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : list/array</p>
<blockquote>
<div><p>Polar angles</p>
</div></blockquote>
<p><strong>phi</strong> : list/array</p>
<blockquote>
<div><p>Azimuthal angles</p>
</div></blockquote>
<p><strong>args</strong> : list/array</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">list</span></code> of ket vectors.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><code class="docutils literal"><span class="pre">array</span></code> for angular wave function</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.tomography">
<span id="quantum-process-tomography"></span><h3>Quantum Process Tomography<a class="headerlink" href="#module-qutip.tomography" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.tomography.qpt">
<code class="descname">qpt</code><span class="sig-paren">(</span><em>U</em>, <em>op_basis_list</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tomography.html#qpt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tomography.qpt" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the quantum process tomography chi matrix for a given (possibly
nonunitary) transformation matrix U, which transforms a density matrix in
vector form according to:</p>
<blockquote>
<div><p>vec(rho) = U * vec(rho0)</p>
<p>or</p>
<p>rho = vec2mat(U * mat2vec(rho0))</p>
</div></blockquote>
<p>U can be calculated for an open quantum system using the QuTiP propagator
function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : Qobj</p>
<blockquote>
<div><p>Transformation operator. Can be calculated using QuTiP propagator
function.</p>
</div></blockquote>
<p><strong>op_basis_list</strong> : list</p>
<blockquote>
<div><p>A list of Qobj’s representing the basis states.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>chi</strong> : array</p>
<blockquote class="last">
<div><p>QPT chi matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.tomography.qpt_plot">
<code class="descname">qpt_plot</code><span class="sig-paren">(</span><em>chi</em>, <em>lbls_list</em>, <em>title=None</em>, <em>fig=None</em>, <em>axes=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tomography.html#qpt_plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tomography.qpt_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the quantum process tomography chi matrix. Plot the real and
imaginary parts separately.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chi</strong> : array</p>
<blockquote>
<div><p>Input QPT chi matrix.</p>
</div></blockquote>
<p><strong>lbls_list</strong> : list</p>
<blockquote>
<div><p>List of labels for QPT plot axes.</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>Plot title.</p>
</div></blockquote>
<p><strong>fig</strong> : figure instance</p>
<blockquote>
<div><p>User defined figure instance used for generating QPT plot.</p>
</div></blockquote>
<p><strong>axes</strong> : list of figure axis instance</p>
<blockquote>
<div><p>User defined figure axis instance (list of two axes) used for
generating QPT plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.tomography.qpt_plot_combined">
<code class="descname">qpt_plot_combined</code><span class="sig-paren">(</span><em>chi</em>, <em>lbls_list</em>, <em>title=None</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(8</em>, <em>6)</em>, <em>threshold=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tomography.html#qpt_plot_combined"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tomography.qpt_plot_combined" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the quantum process tomography chi matrix. Plot bars with
height and color corresponding to the absolute value and phase,
respectively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chi</strong> : array</p>
<blockquote>
<div><p>Input QPT chi matrix.</p>
</div></blockquote>
<p><strong>lbls_list</strong> : list</p>
<blockquote>
<div><p>List of labels for QPT plot axes.</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>Plot title.</p>
</div></blockquote>
<p><strong>fig</strong> : figure instance</p>
<blockquote>
<div><p>User defined figure instance used for generating QPT plot.</p>
</div></blockquote>
<p><strong>ax</strong> : figure axis instance</p>
<blockquote>
<div><p>User defined figure axis instance used for generating QPT plot
(alternative to the fig argument).</p>
</div></blockquote>
<p><strong>threshold: float (None)</strong></p>
<blockquote>
<div><p>Threshold for when bars of smaller height should be transparent. If
not set, all bars are colored according to the color map.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="quantum-information-processing">
<span id="functions-qip"></span><h2>Quantum Information Processing<a class="headerlink" href="#quantum-information-processing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.qip.gates">
<span id="gates"></span><h3>Gates<a class="headerlink" href="#module-qutip.qip.gates" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.qip.gates.rx">
<code class="descname">rx</code><span class="sig-paren">(</span><em>phi</em>, <em>N=None</em>, <em>target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#rx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.rx" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator sigmax with angle phi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object for operator describing the rotation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.ry">
<code class="descname">ry</code><span class="sig-paren">(</span><em>phi</em>, <em>N=None</em>, <em>target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#ry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.ry" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator sigmay with angle phi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object for operator describing the rotation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.rz">
<code class="descname">rz</code><span class="sig-paren">(</span><em>phi</em>, <em>N=None</em>, <em>target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#rz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.rz" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator sigmaz with angle phi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object for operator describing the rotation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.sqrtnot">
<code class="descname">sqrtnot</code><span class="sig-paren">(</span><em>N=None</em>, <em>target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#sqrtnot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.sqrtnot" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit square root NOT gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object for operator describing the square root NOT gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.snot">
<code class="descname">snot</code><span class="sig-paren">(</span><em>N=None</em>, <em>target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#snot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.snot" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the SNOT (Hadamard) gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>snot_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of SNOT gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">snot</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.70710678+0.j  0.70710678+0.j]</span>
<span class="go"> [ 0.70710678+0.j -0.70710678+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.phasegate">
<code class="descname">phasegate</code><span class="sig-paren">(</span><em>theta</em>, <em>N=None</em>, <em>target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#phasegate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.phasegate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns quantum object representing the phase shift gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : float</p>
<blockquote>
<div><p>Phase rotation angle.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>phase_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of phase shift gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phasegate</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.00000000+0.j          0.00000000+0.j        ]</span>
<span class="go"> [ 0.00000000+0.j          0.70710678+0.70710678j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.cphase">
<code class="descname">cphase</code><span class="sig-paren">(</span><em>theta</em>, <em>N=2</em>, <em>control=0</em>, <em>target=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#cphase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.cphase" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns quantum object representing the controlled phase shift gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : float</p>
<blockquote>
<div><p>Phase rotation angle.</p>
</div></blockquote>
<p><strong>N</strong> : integer</p>
<blockquote>
<div><p>The number of qubits in the target space.</p>
</div></blockquote>
<p><strong>control</strong> : integer</p>
<blockquote>
<div><p>The index of the control qubit.</p>
</div></blockquote>
<p><strong>target</strong> : integer</p>
<blockquote>
<div><p>The index of the target qubit.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>U</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of controlled phase gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.cnot">
<code class="descname">cnot</code><span class="sig-paren">(</span><em>N=None</em>, <em>control=0</em>, <em>target=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#cnot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.cnot" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the CNOT gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cnot_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of CNOT gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cnot</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.csign">
<code class="descname">csign</code><span class="sig-paren">(</span><em>N=None</em>, <em>control=0</em>, <em>target=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#csign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.csign" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the CSIGN gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>csign_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of CSIGN gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">csign</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  -1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.berkeley">
<code class="descname">berkeley</code><span class="sig-paren">(</span><em>N=None, targets=[0, 1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#berkeley"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.berkeley" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the Berkeley gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>berkeley_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of Berkeley gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">berkeley</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ cos(pi/8).+0.j  0.+0.j           0.+0.j           0.+sin(pi/8).j]</span>
<span class="go">     [ 0.+0.j          cos(3pi/8).+0.j  0.+sin(3pi/8).j  0.+0.j]</span>
<span class="go">     [ 0.+0.j          0.+sin(3pi/8).j  cos(3pi/8).+0.j  0.+0.j]</span>
<span class="go">     [ 0.+sin(pi/8).j  0.+0.j           0.+0.j           cos(pi/8).+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.swapalpha">
<code class="descname">swapalpha</code><span class="sig-paren">(</span><em>alpha, N=None, targets=[0, 1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#swapalpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.swapalpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the SWAPalpha gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>swapalpha_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of SWAPalpha gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">swapalpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.+0.j  0.+0.j                    0.+0.j                    0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.5*(1 + exp(j*pi*alpha)  0.5*(1 - exp(j*pi*alpha)  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.5*(1 - exp(j*pi*alpha)  0.5*(1 + exp(j*pi*alpha)  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j                    0.+0.j                    1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.swap">
<code class="descname">swap</code><span class="sig-paren">(</span><em>N=None, targets=[0, 1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#swap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the SWAP gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>swap_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of SWAP gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">swap</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.iswap">
<code class="descname">iswap</code><span class="sig-paren">(</span><em>N=None, targets=[0, 1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#iswap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.iswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the iSWAP gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>iswap_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of iSWAP gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iswap</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+1.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+1.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.sqrtswap">
<code class="descname">sqrtswap</code><span class="sig-paren">(</span><em>N=None, targets=[0, 1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#sqrtswap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.sqrtswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the square root SWAP gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sqrtswap_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of square root SWAP gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.sqrtiswap">
<code class="descname">sqrtiswap</code><span class="sig-paren">(</span><em>N=None, targets=[0, 1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#sqrtiswap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.sqrtiswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the square root iSWAP gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sqrtiswap_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of square root iSWAP gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sqrtiswap</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.00000000+0.j   0.00000000+0.j          0.00000000+0.j          0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j   0.70710678+0.j          0.00000000-0.70710678j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j   0.00000000-0.70710678j       0.70710678+0.j          0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j   0.00000000+0.j          0.00000000+0.j          1.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.fredkin">
<code class="descname">fredkin</code><span class="sig-paren">(</span><em>N=None, control=0, targets=[1, 2]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#fredkin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.fredkin" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the Fredkin gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fredkin_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of Fredkin gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fredkin</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.toffoli">
<code class="descname">toffoli</code><span class="sig-paren">(</span><em>N=None, controls=[0, 1], target=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#toffoli"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.toffoli" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the Toffoli gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>toff_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of Toffoli gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">toffoli</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.rotation">
<code class="descname">rotation</code><span class="sig-paren">(</span><em>op</em>, <em>phi</em>, <em>N=None</em>, <em>target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#rotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator op with angle phi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object for operator describing the rotation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.controlled_gate">
<code class="descname">controlled_gate</code><span class="sig-paren">(</span><em>U</em>, <em>N=2</em>, <em>control=0</em>, <em>target=1</em>, <em>control_value=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#controlled_gate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.controlled_gate" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an N-qubit controlled gate from a single-qubit gate U with the given
control and target qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : Qobj</p>
<blockquote>
<div><p>Arbitrary single-qubit gate.</p>
</div></blockquote>
<p><strong>N</strong> : integer</p>
<blockquote>
<div><p>The number of qubits in the target space.</p>
</div></blockquote>
<p><strong>control</strong> : integer</p>
<blockquote>
<div><p>The index of the first control qubit.</p>
</div></blockquote>
<p><strong>target</strong> : integer</p>
<blockquote>
<div><p>The index of the target qubit.</p>
</div></blockquote>
<p><strong>control_value</strong> : integer (1)</p>
<blockquote>
<div><p>The state of the control qubit that activates the gate U.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representing the controlled-U gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.globalphase">
<code class="descname">globalphase</code><span class="sig-paren">(</span><em>theta</em>, <em>N=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#globalphase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.globalphase" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns quantum object representing the global phase shift gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : float</p>
<blockquote>
<div><p>Phase rotation angle.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>phase_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of global phase shift gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phasegate</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.70710678+0.70710678j          0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j          0.70710678+0.70710678j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.hadamard_transform">
<code class="descname">hadamard_transform</code><span class="sig-paren">(</span><em>N=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#hadamard_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.hadamard_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the N-qubit Hadamard gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>q</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of the N-qubit Hadamard gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_sequence_product">
<code class="descname">gate_sequence_product</code><span class="sig-paren">(</span><em>U_list</em>, <em>left_to_right=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#gate_sequence_product"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.gate_sequence_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the overall unitary matrix for a given list of unitary operations</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U_list</strong> : list</p>
<blockquote>
<div><p>List of gates implementing the quantum circuit.</p>
</div></blockquote>
<p><strong>left_to_right</strong> : Boolean</p>
<blockquote>
<div><p>Check if multiplication is to be done from left to right.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>U_overall</strong> : qobj</p>
<blockquote class="last">
<div><p>Overall unitary matrix of a given quantum circuit.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_expand_1toN">
<code class="descname">gate_expand_1toN</code><span class="sig-paren">(</span><em>U</em>, <em>N</em>, <em>target</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#gate_expand_1toN"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.gate_expand_1toN" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Qobj representing a one-qubit gate that act on a system with N
qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : Qobj</p>
<blockquote>
<div><p>The one-qubit gate</p>
</div></blockquote>
<p><strong>N</strong> : integer</p>
<blockquote>
<div><p>The number of qubits in the target space.</p>
</div></blockquote>
<p><strong>target</strong> : integer</p>
<blockquote>
<div><p>The index of the target qubit.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of N-qubit gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_expand_2toN">
<code class="descname">gate_expand_2toN</code><span class="sig-paren">(</span><em>U</em>, <em>N</em>, <em>control=None</em>, <em>target=None</em>, <em>targets=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#gate_expand_2toN"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.gate_expand_2toN" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Qobj representing a two-qubit gate that act on a system with N
qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : Qobj</p>
<blockquote>
<div><p>The two-qubit gate</p>
</div></blockquote>
<p><strong>N</strong> : integer</p>
<blockquote>
<div><p>The number of qubits in the target space.</p>
</div></blockquote>
<p><strong>control</strong> : integer</p>
<blockquote>
<div><p>The index of the control qubit.</p>
</div></blockquote>
<p><strong>target</strong> : integer</p>
<blockquote>
<div><p>The index of the target qubit.</p>
</div></blockquote>
<p><strong>targets</strong> : list</p>
<blockquote>
<div><p>List of target qubits.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of N-qubit gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_expand_3toN">
<code class="descname">gate_expand_3toN</code><span class="sig-paren">(</span><em>U, N, controls=[0, 1], target=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#gate_expand_3toN"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.gate_expand_3toN" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Qobj representing a three-qubit gate that act on a system with N
qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : Qobj</p>
<blockquote>
<div><p>The three-qubit gate</p>
</div></blockquote>
<p><strong>N</strong> : integer</p>
<blockquote>
<div><p>The number of qubits in the target space.</p>
</div></blockquote>
<p><strong>controls</strong> : list</p>
<blockquote>
<div><p>The list of the control qubits.</p>
</div></blockquote>
<p><strong>target</strong> : integer</p>
<blockquote>
<div><p>The index of the target qubit.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of N-qubit gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.qip.qubits">
<span id="qubits"></span><h3>Qubits<a class="headerlink" href="#module-qutip.qip.qubits" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.qip.qubits.qubit_states">
<code class="descname">qubit_states</code><span class="sig-paren">(</span><em>N=1, states=[0]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/qubits.html#qubit_states"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.qubits.qubit_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to define initial state of the qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : Integer</p>
<blockquote>
<div><p>Number of qubits in the register.</p>
</div></blockquote>
<p><strong>states</strong> : List</p>
<blockquote>
<div><p>Initial state of each qubit.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>qstates</strong> : Qobj</p>
<blockquote class="last">
<div><p>List of qubits.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.qip.algorithms.qft">
<span id="algorithms"></span><h3>Algorithms<a class="headerlink" href="#module-qutip.qip.algorithms.qft" title="Permalink to this headline">¶</a></h3>
<p>This module provides the circuit implementation for Quantum Fourier Transform.</p>
<dl class="function">
<dt id="qutip.qip.algorithms.qft.qft">
<code class="descname">qft</code><span class="sig-paren">(</span><em>N=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/algorithms/qft.html#qft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.algorithms.qft.qft" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum Fourier Transform operator on N qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of qubits.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">QFT: qobj</p>
<blockquote class="last">
<div><p>Quantum Fourier transform operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.algorithms.qft.qft_steps">
<code class="descname">qft_steps</code><span class="sig-paren">(</span><em>N=1</em>, <em>swapping=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/algorithms/qft.html#qft_steps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.algorithms.qft.qft_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum Fourier Transform operator on N qubits returning the individual
steps as unitary matrices operating from left to right.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N: int</strong></p>
<blockquote>
<div><p>Number of qubits.</p>
</div></blockquote>
<p><strong>swap: boolean</strong></p>
<blockquote>
<div><p>Flag indicating sequence of swap gates to be applied at the end or not.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">U_step_list: list of qobj</p>
<blockquote class="last">
<div><p>List of Hadamard and controlled rotation gates implementing QFT.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.algorithms.qft.qft_gate_sequence">
<code class="descname">qft_gate_sequence</code><span class="sig-paren">(</span><em>N=1</em>, <em>swapping=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/algorithms/qft.html#qft_gate_sequence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.algorithms.qft.qft_gate_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum Fourier Transform operator on N qubits returning the gate sequence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N: int</strong></p>
<blockquote>
<div><p>Number of qubits.</p>
</div></blockquote>
<p><strong>swap: boolean</strong></p>
<blockquote>
<div><p>Flag indicating sequence of swap gates to be applied at the end or not.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">qc: instance of QubitCircuit</p>
<blockquote class="last">
<div><p>Gate sequence of Hadamard and controlled rotation gates implementing
QFT.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-qutip.nonmarkov.transfertensor">
<span id="non-markovian-solvers"></span><span id="functions-non-markov"></span><h2>non-Markovian Solvers<a class="headerlink" href="#module-qutip.nonmarkov.transfertensor" title="Permalink to this headline">¶</a></h2>
<p>This module contains an implementation of the non-Markovian transfer tensor
method (TTM), introduced in [1].</p>
<p>[1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014)</p>
<dl class="function">
<dt id="qutip.nonmarkov.transfertensor.ttmsolve">
<code class="descname">ttmsolve</code><span class="sig-paren">(</span><em>dynmaps</em>, <em>rho0</em>, <em>times</em>, <em>e_ops=[]</em>, <em>learningtimes=None</em>, <em>tensors=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/nonmarkov/transfertensor.html#ttmsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.nonmarkov.transfertensor.ttmsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve time-evolution using the Transfer Tensor Method, based on a set of
precomputed dynamical maps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dynmaps</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>List of precomputed dynamical maps (superoperators),
or a callback function that returns the
superoperator at a given time.</p>
</div></blockquote>
<p><strong>rho0</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a></p>
<blockquote>
<div><p>Initial density matrix or state vector (ket).</p>
</div></blockquote>
<p><strong>times</strong> : array_like</p>
<blockquote>
<div><p>list of times <span class="math">\(t_n\)</span> at which to compute <span class="math">\(\rho(t_n)\)</span>.
Must be uniformily spaced.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></code></a> / callback function</p>
<blockquote>
<div><p>single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>learningtimes</strong> : array_like</p>
<blockquote>
<div><p>list of times <span class="math">\(t_k\)</span> for which we have knowledge of the dynamical
maps <span class="math">\(E(t_k)\)</span>.</p>
</div></blockquote>
<p><strong>tensors</strong> : array_like</p>
<blockquote>
<div><p>optional list of precomputed tensors <span class="math">\(T_k\)</span></p>
</div></blockquote>
<p><strong>kwargs</strong> : dictionary</p>
<blockquote>
<div><p>Optional keyword arguments. See
<code class="xref py py-class docutils literal"><span class="pre">qutip.nonmarkov.ttm.TTMSolverOptions</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">output: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal"><span class="pre">qutip.solver.Result</span></code></a></p>
<blockquote class="last">
<div><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal"><span class="pre">qutip.solver.Result</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.control.pulseoptim">
<span id="optimal-control"></span><span id="functions-control"></span><h2>Optimal control<a class="headerlink" href="#module-qutip.control.pulseoptim" title="Permalink to this headline">¶</a></h2>
<p>Wrapper functions that will manage the creation of the objects,
build the configuration, and execute the algorithm required to optimise
a set of ctrl pulses for a given (quantum) system.
The fidelity error is some measure of distance of the system evolution
from the given target evolution in the time allowed for the evolution.
The functions minimise this fidelity error wrt the piecewise control
amplitudes in the timeslots</p>
<p>There are currently two quantum control pulse optmisations algorithms
implemented in this library. There are accessible through the methods
in this module. Both the algorithms use the scipy.optimize methods
to minimise the fidelity error with respect to to variables that define
the pulse.</p>
<div class="section" id="grape">
<h3>GRAPE<a class="headerlink" href="#grape" title="Permalink to this headline">¶</a></h3>
<p>The default algorithm (as it was implemented here first) is GRAPE
GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such
as BFGS to minimise the fidelity error. This makes convergence very quick
when an exact gradient can be calculated, but this limits the factors that can
taken into account in the fidelity.</p>
</div>
<div class="section" id="crab">
<h3>CRAB<a class="headerlink" href="#crab" title="Permalink to this headline">¶</a></h3>
<p>The CRAB [3][4] algorithm was developed at the University of Ulm.
In full it is the Chopped RAndom Basis algorithm.
The main difference is that it reduces the number of optimisation variables
by defining the control pulses by expansions of basis functions,
where the variables are the coefficients. Typically a Fourier series is chosen,
i.e. the variables are the Fourier coefficients.
Therefore it does not need to compute an explicit gradient.
By default it uses the Nelder-Mead method for fidelity error minimisation.</p>
<p class="rubric">References</p>
<ol class="arabic simple">
<li>N Khaneja et. al.
Optimal control of coupled spin dynamics: Design of NMR pulse sequences
by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).</li>
<li>Shai Machnes et.al
DYNAMO - Dynamic Framework for Quantum Optimal Control
arXiv.1011.4874</li>
<li>Doria, P., Calarco, T. &amp; Montangero, S.
Optimal Control Technique for Many-Body Quantum Dynamics.
Phys. Rev. Lett. 106, 1–4 (2011).</li>
<li>Caneva, T., Calarco, T. &amp; Montangero, S.
Chopped random-basis quantum optimization.
Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011).</li>
</ol>
<dl class="function">
<dt id="qutip.control.pulseoptim.optimize_pulse">
<code class="descname">optimize_pulse</code><span class="sig-paren">(</span><em>drift</em>, <em>ctrls</em>, <em>initial</em>, <em>target</em>, <em>num_tslots=None</em>, <em>evo_time=None</em>, <em>tau=None</em>, <em>amp_lbound=None</em>, <em>amp_ubound=None</em>, <em>fid_err_targ=1e-10</em>, <em>min_grad=1e-10</em>, <em>max_iter=500</em>, <em>max_wall_time=180</em>, <em>alg=’GRAPE’</em>, <em>alg_params=None</em>, <em>optim_params=None</em>, <em>optim_method=’DEF’</em>, <em>method_params=None</em>, <em>optim_alg=None</em>, <em>max_metric_corr=None</em>, <em>accuracy_factor=None</em>, <em>dyn_type=’GEN_MAT’</em>, <em>dyn_params=None</em>, <em>prop_type=’DEF’</em>, <em>prop_params=None</em>, <em>fid_type=’DEF’</em>, <em>fid_params=None</em>, <em>phase_option=None</em>, <em>fid_err_scale_factor=None</em>, <em>tslot_type=’DEF’</em>, <em>tslot_params=None</em>, <em>amp_update_mode=None</em>, <em>init_pulse_type=’DEF’</em>, <em>init_pulse_params=None</em>, <em>pulse_scaling=1.0</em>, <em>pulse_offset=0.0</em>, <em>ramping_pulse_type=None</em>, <em>ramping_pulse_params=None</em>, <em>log_level=0</em>, <em>out_file_ext=None</em>, <em>gen_stats=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulseoptim.html#optimize_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulseoptim.optimize_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise a control pulse to minimise the fidelity error.
The dynamics of the system in any given timeslot are governed
by the combined dynamics generator,
i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]
The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes
Starting from an intital (typically random) pulse,
a multivariable optimisation algorithm attempts to determines the
optimal values for the control pulse to minimise the fidelity error
The fidelity error is some measure of distance of the system evolution
from the given target evolution in the time allowed for the evolution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>drift</strong> : Qobj or list of Qobj</p>
<blockquote>
<div><p>the underlying dynamics generator of the system
can provide list (of length num_tslots) for time dependent drift</p>
</div></blockquote>
<p><strong>ctrls</strong> : List of Qobj</p>
<blockquote>
<div><p>a list of control dynamics generators. These are scaled by
the amplitudes to alter the overall dynamics</p>
</div></blockquote>
<p><strong>initial</strong> : Qobj</p>
<blockquote>
<div><p>starting point for the evolution.
Typically the identity matrix</p>
</div></blockquote>
<p><strong>target</strong> : Qobj</p>
<blockquote>
<div><p>target transformation, e.g. gate or state, for the time evolution</p>
</div></blockquote>
<p><strong>num_tslots</strong> : integer or None</p>
<blockquote>
<div><p>number of timeslots.
None implies that timeslots will be given in the tau array</p>
</div></blockquote>
<p><strong>evo_time</strong> : float or None</p>
<blockquote>
<div><p>total time for the evolution
None implies that timeslots will be given in the tau array</p>
</div></blockquote>
<p><strong>tau</strong> : array[num_tslots] of floats or None</p>
<blockquote>
<div><p>durations for the timeslots.
if this is given then num_tslots and evo_time are dervived
from it
None implies that timeslot durations will be equal and
calculated as evo_time/num_tslots</p>
</div></blockquote>
<p><strong>amp_lbound</strong> : float or list of floats</p>
<blockquote>
<div><p>lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</div></blockquote>
<p><strong>amp_ubound</strong> : float or list of floats</p>
<blockquote>
<div><p>upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</div></blockquote>
<p><strong>fid_err_targ</strong> : float</p>
<blockquote>
<div><p>Fidelity error target. Pulse optimisation will
terminate when the fidelity error falls below this value</p>
</div></blockquote>
<p><strong>mim_grad</strong> : float</p>
<blockquote>
<div><p>Minimum gradient. When the sum of the squares of the
gradients wrt to the control amplitudes falls below this
value, the optimisation terminates, assuming local minima</p>
</div></blockquote>
<p><strong>max_iter</strong> : integer</p>
<blockquote>
<div><p>Maximum number of iterations of the optimisation algorithm</p>
</div></blockquote>
<p><strong>max_wall_time</strong> : float</p>
<blockquote>
<div><p>Maximum allowed elapsed time for the  optimisation algorithm</p>
</div></blockquote>
<p><strong>alg</strong> : string</p>
<blockquote>
<div><p>Algorithm to use in pulse optimisation.
Options are:</p>
<blockquote>
<div><p>‘GRAPE’ (default) - GRadient Ascent Pulse Engineering
‘CRAB’ - Chopped RAndom Basis</p>
</div></blockquote>
</div></blockquote>
<p><strong>alg_params</strong> : Dictionary</p>
<blockquote>
<div><p>options that are specific to the algorithm see above</p>
</div></blockquote>
<p><strong>optim_params</strong> : Dictionary</p>
<blockquote>
<div><p>The key value pairs are the attribute name and value
used to set attribute values
Note: attributes are created if they do not exist already,
and are overwritten if they do.
Note: method_params are applied afterwards and so may override these</p>
</div></blockquote>
<p><strong>optim_method</strong> : string</p>
<blockquote>
<div><p>a scipy.optimize.minimize method that will be used to optimise
the pulse for minimum fidelity error
Note that FMIN, FMIN_BFGS &amp; FMIN_L_BFGS_B will all result
in calling these specific scipy.optimize methods
Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards
capatibility reasons.
Supplying DEF will given alg dependent result:</p>
<blockquote>
<div><p>GRAPE - Default optim_method is FMIN_L_BFGS_B
CRAB - Default optim_method is FMIN</p>
</div></blockquote>
</div></blockquote>
<p><strong>method_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the optim_method.
Note that where there is an attribute of the
Optimizer object or the termination_conditions matching the key
that attribute. Otherwise, and in some case also,
they are assumed to be method_options
for the scipy.optimize.minimize method.</p>
</div></blockquote>
<p><strong>optim_alg</strong> : string</p>
<blockquote>
<div><p>Deprecated. Use optim_method.</p>
</div></blockquote>
<p><strong>max_metric_corr</strong> : integer</p>
<blockquote>
<div><p>Deprecated. Use method_params instead</p>
</div></blockquote>
<p><strong>accuracy_factor</strong> : float</p>
<blockquote>
<div><p>Deprecated. Use method_params instead</p>
</div></blockquote>
<p><strong>dyn_type</strong> : string</p>
<blockquote>
<div><p>Dynamics type, i.e. the type of matrix used to describe
the dynamics. Options are UNIT, GEN_MAT, SYMPL
(see Dynamics classes for details)</p>
</div></blockquote>
<p><strong>dyn_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the Dynamics object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>prop_type</strong> : string</p>
<blockquote>
<div><p>Propagator type i.e. the method used to calculate the
propagtors and propagtor gradient for each timeslot
options are DEF, APPROX, DIAG, FRECHET, AUG_MAT
DEF will use the default for the specific dyn_type
(see PropagatorComputer classes for details)</p>
</div></blockquote>
<p><strong>prop_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the PropagatorComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>fid_type</strong> : string</p>
<blockquote>
<div><p>Fidelity error (and fidelity error gradient) computation method
Options are DEF, UNIT, TRACEDIFF, TD_APPROX
DEF will use the default for the specific dyn_type
(See FidelityComputer classes for details)</p>
</div></blockquote>
<p><strong>fid_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the FidelityComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>phase_option</strong> : string</p>
<blockquote>
<div><p>Deprecated. Pass in fid_params instead.</p>
</div></blockquote>
<p><strong>fid_err_scale_factor</strong> : float</p>
<blockquote>
<div><p>Deprecated. Use scale_factor key in fid_params instead.</p>
</div></blockquote>
<p><strong>tslot_type</strong> : string</p>
<blockquote>
<div><p>Method for computing the dynamics generators, propagators and
evolution in the timeslots.
Options: DEF, UPDATE_ALL, DYNAMIC
UPDATE_ALL is the only one that currently works
(See TimeslotComputer classes for details)</p>
</div></blockquote>
<p><strong>tslot_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the TimeslotComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>amp_update_mode</strong> : string</p>
<blockquote>
<div><p>Deprecated. Use tslot_type instead.</p>
</div></blockquote>
<p><strong>init_pulse_type</strong> : string</p>
<blockquote>
<div><p>type / shape of pulse(s) used to initialise the
the control amplitudes.
Options (GRAPE) include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW</p>
</div></blockquote>
<p>DEF is RND
(see PulseGen classes for details)
For the CRAB the this the guess_pulse_type.</p>
</div></blockquote>
<p><strong>init_pulse_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the initial / guess pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>pulse_scaling</strong> : float</p>
<blockquote>
<div><p>Linear scale factor for generated initial / guess pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</div></blockquote>
<p><strong>pulse_offset</strong> : float</p>
<blockquote>
<div><p>Linear offset for the pulse. That is this value will be added
to any initial / guess pulses generated.</p>
</div></blockquote>
<p><strong>ramping_pulse_type</strong> : string</p>
<blockquote>
<div><p>Type of pulse used to modulate the control pulse.
It’s intended use for a ramping modulation, which is often required in
experimental setups.
This is only currently implemented in CRAB.
GAUSSIAN_EDGE was added for this purpose.</p>
</div></blockquote>
<p><strong>ramping_pulse_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the ramping pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>log_level</strong> : integer</p>
<blockquote>
<div><p>level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</div></blockquote>
<p><strong>out_file_ext</strong> : string or None</p>
<blockquote>
<div><p>files containing the initial and final control pulse
amplitudes are saved to the current directory.
The default name will be postfixed with this extension
Setting this to None will suppress the output of files</p>
</div></blockquote>
<p><strong>gen_stats</strong> : boolean</p>
<blockquote>
<div><p>if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>opt</strong> : OptimResult</p>
<blockquote class="last">
<div><p>Returns instance of OptimResult, which has attributes giving the
reason for termination, final fidelity error, final evolution
final amplitudes, statistics etc</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.control.pulseoptim.optimize_pulse_unitary">
<code class="descname">optimize_pulse_unitary</code><span class="sig-paren">(</span><em>H_d</em>, <em>H_c</em>, <em>U_0</em>, <em>U_targ</em>, <em>num_tslots=None</em>, <em>evo_time=None</em>, <em>tau=None</em>, <em>amp_lbound=None</em>, <em>amp_ubound=None</em>, <em>fid_err_targ=1e-10</em>, <em>min_grad=1e-10</em>, <em>max_iter=500</em>, <em>max_wall_time=180</em>, <em>alg=’GRAPE’</em>, <em>alg_params=None</em>, <em>optim_params=None</em>, <em>optim_method=’DEF’</em>, <em>method_params=None</em>, <em>optim_alg=None</em>, <em>max_metric_corr=None</em>, <em>accuracy_factor=None</em>, <em>phase_option=’PSU’</em>, <em>dyn_params=None</em>, <em>prop_params=None</em>, <em>fid_params=None</em>, <em>tslot_type=’DEF’</em>, <em>tslot_params=None</em>, <em>amp_update_mode=None</em>, <em>init_pulse_type=’DEF’</em>, <em>init_pulse_params=None</em>, <em>pulse_scaling=1.0</em>, <em>pulse_offset=0.0</em>, <em>ramping_pulse_type=None</em>, <em>ramping_pulse_params=None</em>, <em>log_level=0</em>, <em>out_file_ext=None</em>, <em>gen_stats=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulseoptim.html#optimize_pulse_unitary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulseoptim.optimize_pulse_unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise a control pulse to minimise the fidelity error, assuming that
the dynamics of the system are generated by unitary operators.
This function is simply a wrapper for optimize_pulse, where the
appropriate options for unitary dynamics are chosen and the parameter
names are in the format familiar to unitary dynamics
The dynamics of the system  in any given timeslot are governed
by the combined Hamiltonian,
i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]
The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes
Starting from an intital (typically random) pulse,
a multivariable optimisation algorithm attempts to determines the
optimal values for the control pulse to minimise the fidelity error
The maximum fidelity for a unitary system is 1, i.e. when the
time evolution resulting from the pulse is equivalent to the target.
And therefore the fidelity error is 1 - fidelity</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H_d</strong> : Qobj or list of Qobj</p>
<blockquote>
<div><p>Drift (aka system) the underlying Hamiltonian of the system
can provide list (of length num_tslots) for time dependent drift</p>
</div></blockquote>
<p><strong>H_c</strong> : Qobj</p>
<blockquote>
<div><p>a list of control Hamiltonians. These are scaled by
the amplitudes to alter the overall dynamics</p>
</div></blockquote>
<p><strong>U_0</strong> : Qobj</p>
<blockquote>
<div><p>starting point for the evolution.
Typically the identity matrix</p>
</div></blockquote>
<p><strong>U_targ</strong> : Qobj</p>
<blockquote>
<div><p>target transformation, e.g. gate or state, for the time evolution</p>
</div></blockquote>
<p><strong>num_tslots</strong> : integer or None</p>
<blockquote>
<div><p>number of timeslots.
None implies that timeslots will be given in the tau array</p>
</div></blockquote>
<p><strong>evo_time</strong> : float or None</p>
<blockquote>
<div><p>total time for the evolution
None implies that timeslots will be given in the tau array</p>
</div></blockquote>
<p><strong>tau</strong> : array[num_tslots] of floats or None</p>
<blockquote>
<div><p>durations for the timeslots.
if this is given then num_tslots and evo_time are dervived
from it
None implies that timeslot durations will be equal and
calculated as evo_time/num_tslots</p>
</div></blockquote>
<p><strong>amp_lbound</strong> : float or list of floats</p>
<blockquote>
<div><p>lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</div></blockquote>
<p><strong>amp_ubound</strong> : float or list of floats</p>
<blockquote>
<div><p>upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</div></blockquote>
<p><strong>fid_err_targ</strong> : float</p>
<blockquote>
<div><p>Fidelity error target. Pulse optimisation will
terminate when the fidelity error falls below this value</p>
</div></blockquote>
<p><strong>mim_grad</strong> : float</p>
<blockquote>
<div><p>Minimum gradient. When the sum of the squares of the
gradients wrt to the control amplitudes falls below this
value, the optimisation terminates, assuming local minima</p>
</div></blockquote>
<p><strong>max_iter</strong> : integer</p>
<blockquote>
<div><p>Maximum number of iterations of the optimisation algorithm</p>
</div></blockquote>
<p><strong>max_wall_time</strong> : float</p>
<blockquote>
<div><p>Maximum allowed elapsed time for the  optimisation algorithm</p>
</div></blockquote>
<p><strong>alg</strong> : string</p>
<blockquote>
<div><p>Algorithm to use in pulse optimisation.
Options are:</p>
<blockquote>
<div><p>‘GRAPE’ (default) - GRadient Ascent Pulse Engineering
‘CRAB’ - Chopped RAndom Basis</p>
</div></blockquote>
</div></blockquote>
<p><strong>alg_params</strong> : Dictionary</p>
<blockquote>
<div><p>options that are specific to the algorithm see above</p>
</div></blockquote>
<p><strong>optim_params</strong> : Dictionary</p>
<blockquote>
<div><p>The key value pairs are the attribute name and value
used to set attribute values
Note: attributes are created if they do not exist already,
and are overwritten if they do.
Note: method_params are applied afterwards and so may override these</p>
</div></blockquote>
<p><strong>optim_method</strong> : string</p>
<blockquote>
<div><p>a scipy.optimize.minimize method that will be used to optimise
the pulse for minimum fidelity error
Note that FMIN, FMIN_BFGS &amp; FMIN_L_BFGS_B will all result
in calling these specific scipy.optimize methods
Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards
capatibility reasons.
Supplying DEF will given alg dependent result:</p>
<blockquote>
<div><p>GRAPE - Default optim_method is FMIN_L_BFGS_B
CRAB - Default optim_method is FMIN</p>
</div></blockquote>
</div></blockquote>
<p><strong>method_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the optim_method.
Note that where there is an attribute of the
Optimizer object or the termination_conditions matching the key
that attribute. Otherwise, and in some case also,
they are assumed to be method_options
for the scipy.optimize.minimize method.</p>
</div></blockquote>
<p><strong>optim_alg</strong> : string</p>
<blockquote>
<div><p>Deprecated. Use optim_method.</p>
</div></blockquote>
<p><strong>max_metric_corr</strong> : integer</p>
<blockquote>
<div><p>Deprecated. Use method_params instead</p>
</div></blockquote>
<p><strong>accuracy_factor</strong> : float</p>
<blockquote>
<div><p>Deprecated. Use method_params instead</p>
</div></blockquote>
<p><strong>phase_option</strong> : string</p>
<blockquote>
<div><p>determines how global phase is treated in fidelity
calculations (fid_type=’UNIT’ only). Options:</p>
<blockquote>
<div><p>PSU - global phase ignored
SU - global phase included</p>
</div></blockquote>
</div></blockquote>
<p><strong>dyn_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the Dynamics object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>prop_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the PropagatorComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>fid_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the FidelityComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>tslot_type</strong> : string</p>
<blockquote>
<div><p>Method for computing the dynamics generators, propagators and
evolution in the timeslots.
Options: DEF, UPDATE_ALL, DYNAMIC
UPDATE_ALL is the only one that currently works
(See TimeslotComputer classes for details)</p>
</div></blockquote>
<p><strong>tslot_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the TimeslotComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>amp_update_mode</strong> : string</p>
<blockquote>
<div><p>Deprecated. Use tslot_type instead.</p>
</div></blockquote>
<p><strong>init_pulse_type</strong> : string</p>
<blockquote>
<div><p>type / shape of pulse(s) used to initialise the
the control amplitudes.
Options (GRAPE) include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW
DEF is RND</p>
</div></blockquote>
<p>(see PulseGen classes for details)
For the CRAB the this the guess_pulse_type.</p>
</div></blockquote>
<p><strong>init_pulse_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the initial / guess pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>pulse_scaling</strong> : float</p>
<blockquote>
<div><p>Linear scale factor for generated initial / guess pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</div></blockquote>
<p><strong>pulse_offset</strong> : float</p>
<blockquote>
<div><p>Linear offset for the pulse. That is this value will be added
to any initial / guess pulses generated.</p>
</div></blockquote>
<p><strong>ramping_pulse_type</strong> : string</p>
<blockquote>
<div><p>Type of pulse used to modulate the control pulse.
It’s intended use for a ramping modulation, which is often required in
experimental setups.
This is only currently implemented in CRAB.
GAUSSIAN_EDGE was added for this purpose.</p>
</div></blockquote>
<p><strong>ramping_pulse_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the ramping pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>log_level</strong> : integer</p>
<blockquote>
<div><p>level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</div></blockquote>
<p><strong>out_file_ext</strong> : string or None</p>
<blockquote>
<div><p>files containing the initial and final control pulse
amplitudes are saved to the current directory.
The default name will be postfixed with this extension
Setting this to None will suppress the output of files</p>
</div></blockquote>
<p><strong>gen_stats</strong> : boolean</p>
<blockquote>
<div><p>if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>opt</strong> : OptimResult</p>
<blockquote class="last">
<div><p>Returns instance of OptimResult, which has attributes giving the
reason for termination, final fidelity error, final evolution
final amplitudes, statistics etc</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.control.pulseoptim.create_pulse_optimizer">
<code class="descname">create_pulse_optimizer</code><span class="sig-paren">(</span><em>drift</em>, <em>ctrls</em>, <em>initial</em>, <em>target</em>, <em>num_tslots=None</em>, <em>evo_time=None</em>, <em>tau=None</em>, <em>amp_lbound=None</em>, <em>amp_ubound=None</em>, <em>fid_err_targ=1e-10</em>, <em>min_grad=1e-10</em>, <em>max_iter=500</em>, <em>max_wall_time=180</em>, <em>alg=’GRAPE’</em>, <em>alg_params=None</em>, <em>optim_params=None</em>, <em>optim_method=’DEF’</em>, <em>method_params=None</em>, <em>optim_alg=None</em>, <em>max_metric_corr=None</em>, <em>accuracy_factor=None</em>, <em>dyn_type=’GEN_MAT’</em>, <em>dyn_params=None</em>, <em>prop_type=’DEF’</em>, <em>prop_params=None</em>, <em>fid_type=’DEF’</em>, <em>fid_params=None</em>, <em>phase_option=None</em>, <em>fid_err_scale_factor=None</em>, <em>tslot_type=’DEF’</em>, <em>tslot_params=None</em>, <em>amp_update_mode=None</em>, <em>init_pulse_type=’DEF’</em>, <em>init_pulse_params=None</em>, <em>pulse_scaling=1.0</em>, <em>pulse_offset=0.0</em>, <em>ramping_pulse_type=None</em>, <em>ramping_pulse_params=None</em>, <em>log_level=0</em>, <em>gen_stats=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulseoptim.html#create_pulse_optimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulseoptim.create_pulse_optimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the objects of the appropriate subclasses
required for the pulse optmisation based on the parameters given
Note this method may be preferable to calling optimize_pulse
if more detailed configuration is required before running the
optmisation algorthim, or the algorithm will be run many times,
for instances when trying to finding global the optimum or
minimum time optimisation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>drift</strong> : Qobj or list of Qobj</p>
<blockquote>
<div><p>the underlying dynamics generator of the system
can provide list (of length num_tslots) for time dependent drift</p>
</div></blockquote>
<p><strong>ctrls</strong> : List of Qobj</p>
<blockquote>
<div><p>a list of control dynamics generators. These are scaled by
the amplitudes to alter the overall dynamics</p>
</div></blockquote>
<p><strong>initial</strong> : Qobj</p>
<blockquote>
<div><p>starting point for the evolution.
Typically the identity matrix</p>
</div></blockquote>
<p><strong>target</strong> : Qobj</p>
<blockquote>
<div><p>target transformation, e.g. gate or state, for the time evolution</p>
</div></blockquote>
<p><strong>num_tslots</strong> : integer or None</p>
<blockquote>
<div><p>number of timeslots.
None implies that timeslots will be given in the tau array</p>
</div></blockquote>
<p><strong>evo_time</strong> : float or None</p>
<blockquote>
<div><p>total time for the evolution
None implies that timeslots will be given in the tau array</p>
</div></blockquote>
<p><strong>tau</strong> : array[num_tslots] of floats or None</p>
<blockquote>
<div><p>durations for the timeslots.
if this is given then num_tslots and evo_time are dervived
from it
None implies that timeslot durations will be equal and
calculated as evo_time/num_tslots</p>
</div></blockquote>
<p><strong>amp_lbound</strong> : float or list of floats</p>
<blockquote>
<div><p>lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</div></blockquote>
<p><strong>amp_ubound</strong> : float or list of floats</p>
<blockquote>
<div><p>upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</div></blockquote>
<p><strong>fid_err_targ</strong> : float</p>
<blockquote>
<div><p>Fidelity error target. Pulse optimisation will
terminate when the fidelity error falls below this value</p>
</div></blockquote>
<p><strong>mim_grad</strong> : float</p>
<blockquote>
<div><p>Minimum gradient. When the sum of the squares of the
gradients wrt to the control amplitudes falls below this
value, the optimisation terminates, assuming local minima</p>
</div></blockquote>
<p><strong>max_iter</strong> : integer</p>
<blockquote>
<div><p>Maximum number of iterations of the optimisation algorithm</p>
</div></blockquote>
<p><strong>max_wall_time</strong> : float</p>
<blockquote>
<div><p>Maximum allowed elapsed time for the optimisation algorithm</p>
</div></blockquote>
<p><strong>alg</strong> : string</p>
<blockquote>
<div><p>Algorithm to use in pulse optimisation.
Options are:</p>
<blockquote>
<div><p>‘GRAPE’ (default) - GRadient Ascent Pulse Engineering
‘CRAB’ - Chopped RAndom Basis</p>
</div></blockquote>
</div></blockquote>
<p><strong>alg_params</strong> : Dictionary</p>
<blockquote>
<div><p>options that are specific to the algorithm see above</p>
</div></blockquote>
<p><strong>optim_params</strong> : Dictionary</p>
<blockquote>
<div><p>The key value pairs are the attribute name and value
used to set attribute values
Note: attributes are created if they do not exist already,
and are overwritten if they do.
Note: method_params are applied afterwards and so may override these</p>
</div></blockquote>
<p><strong>optim_method</strong> : string</p>
<blockquote>
<div><p>a scipy.optimize.minimize method that will be used to optimise
the pulse for minimum fidelity error
Note that FMIN, FMIN_BFGS &amp; FMIN_L_BFGS_B will all result
in calling these specific scipy.optimize methods
Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards
capatibility reasons.
Supplying DEF will given alg dependent result:</p>
<blockquote>
<div><ul class="simple">
<li>GRAPE - Default optim_method is FMIN_L_BFGS_B</li>
<li>CRAB - Default optim_method is Nelder-Mead</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>method_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the optim_method.
Note that where there is an attribute of the
Optimizer object or the termination_conditions matching the key
that attribute. Otherwise, and in some case also,
they are assumed to be method_options
for the scipy.optimize.minimize method.</p>
</div></blockquote>
<p><strong>optim_alg</strong> : string</p>
<blockquote>
<div><p>Deprecated. Use optim_method.</p>
</div></blockquote>
<p><strong>max_metric_corr</strong> : integer</p>
<blockquote>
<div><p>Deprecated. Use method_params instead</p>
</div></blockquote>
<p><strong>accuracy_factor</strong> : float</p>
<blockquote>
<div><p>Deprecated. Use method_params instead</p>
</div></blockquote>
<p><strong>dyn_type</strong> : string</p>
<blockquote>
<div><p>Dynamics type, i.e. the type of matrix used to describe
the dynamics. Options are UNIT, GEN_MAT, SYMPL
(see Dynamics classes for details)</p>
</div></blockquote>
<p><strong>dyn_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the Dynamics object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>prop_type</strong> : string</p>
<blockquote>
<div><p>Propagator type i.e. the method used to calculate the
propagtors and propagtor gradient for each timeslot
options are DEF, APPROX, DIAG, FRECHET, AUG_MAT
DEF will use the default for the specific dyn_type
(see PropagatorComputer classes for details)</p>
</div></blockquote>
<p><strong>prop_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the PropagatorComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>fid_type</strong> : string</p>
<blockquote>
<div><p>Fidelity error (and fidelity error gradient) computation method
Options are DEF, UNIT, TRACEDIFF, TD_APPROX
DEF will use the default for the specific dyn_type
(See FidelityComputer classes for details)</p>
</div></blockquote>
<p><strong>fid_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the FidelityComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>phase_option</strong> : string</p>
<blockquote>
<div><p>Deprecated. Pass in fid_params instead.</p>
</div></blockquote>
<p><strong>fid_err_scale_factor</strong> : float</p>
<blockquote>
<div><p>Deprecated. Use scale_factor key in fid_params instead.</p>
</div></blockquote>
<p><strong>tslot_type</strong> : string</p>
<blockquote>
<div><p>Method for computing the dynamics generators, propagators and
evolution in the timeslots.
Options: DEF, UPDATE_ALL, DYNAMIC
UPDATE_ALL is the only one that currently works
(See TimeslotComputer classes for details)</p>
</div></blockquote>
<p><strong>tslot_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the TimeslotComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>amp_update_mode</strong> : string</p>
<blockquote>
<div><p>Deprecated. Use tslot_type instead.</p>
</div></blockquote>
<p><strong>init_pulse_type</strong> : string</p>
<blockquote>
<div><p>type / shape of pulse(s) used to initialise the
the control amplitudes.
Options (GRAPE) include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW
DEF is RND</p>
</div></blockquote>
<p>(see PulseGen classes for details)
For the CRAB the this the guess_pulse_type.</p>
</div></blockquote>
<p><strong>init_pulse_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the initial / guess pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>pulse_scaling</strong> : float</p>
<blockquote>
<div><p>Linear scale factor for generated initial / guess pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</div></blockquote>
<p><strong>pulse_offset</strong> : float</p>
<blockquote>
<div><p>Linear offset for the pulse. That is this value will be added
to any initial / guess pulses generated.</p>
</div></blockquote>
<p><strong>ramping_pulse_type</strong> : string</p>
<blockquote>
<div><p>Type of pulse used to modulate the control pulse.
It’s intended use for a ramping modulation, which is often required in
experimental setups.
This is only currently implemented in CRAB.
GAUSSIAN_EDGE was added for this purpose.</p>
</div></blockquote>
<p><strong>ramping_pulse_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the ramping pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>log_level</strong> : integer</p>
<blockquote>
<div><p>level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</div></blockquote>
<p><strong>gen_stats</strong> : boolean</p>
<blockquote>
<div><p>if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>opt</strong> : Optimizer</p>
<blockquote class="last">
<div><p>Instance of an Optimizer, through which the
Config, Dynamics, PulseGen, and TerminationConditions objects
can be accessed as attributes.
The PropagatorComputer, FidelityComputer and TimeslotComputer objects
can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer
The optimisation can be run through the optimizer.run_optimization</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.control.pulseoptim.opt_pulse_crab">
<code class="descname">opt_pulse_crab</code><span class="sig-paren">(</span><em>drift</em>, <em>ctrls</em>, <em>initial</em>, <em>target</em>, <em>num_tslots=None</em>, <em>evo_time=None</em>, <em>tau=None</em>, <em>amp_lbound=None</em>, <em>amp_ubound=None</em>, <em>fid_err_targ=1e-05</em>, <em>max_iter=500</em>, <em>max_wall_time=180</em>, <em>alg_params=None</em>, <em>num_coeffs=None</em>, <em>init_coeff_scaling=1.0</em>, <em>optim_params=None</em>, <em>optim_method=’fmin’</em>, <em>method_params=None</em>, <em>dyn_type=’GEN_MAT’</em>, <em>dyn_params=None</em>, <em>prop_type=’DEF’</em>, <em>prop_params=None</em>, <em>fid_type=’DEF’</em>, <em>fid_params=None</em>, <em>tslot_type=’DEF’</em>, <em>tslot_params=None</em>, <em>guess_pulse_type=None</em>, <em>guess_pulse_params=None</em>, <em>guess_pulse_scaling=1.0</em>, <em>guess_pulse_offset=0.0</em>, <em>guess_pulse_action=’MODULATE’</em>, <em>ramping_pulse_type=None</em>, <em>ramping_pulse_params=None</em>, <em>log_level=0</em>, <em>out_file_ext=None</em>, <em>gen_stats=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulseoptim.html#opt_pulse_crab"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulseoptim.opt_pulse_crab" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise a control pulse to minimise the fidelity error.
The dynamics of the system in any given timeslot are governed
by the combined dynamics generator,
i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]
The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes.
The CRAB algorithm uses basis function coefficents as the variables to
optimise. It does NOT use any gradient function.
A multivariable optimisation algorithm attempts to determines the
optimal values for the control pulse to minimise the fidelity error
The fidelity error is some measure of distance of the system evolution
from the given target evolution in the time allowed for the evolution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>drift</strong> : Qobj or list of Qobj</p>
<blockquote>
<div><p>the underlying dynamics generator of the system
can provide list (of length num_tslots) for time dependent drift</p>
</div></blockquote>
<p><strong>ctrls</strong> : List of Qobj</p>
<blockquote>
<div><p>a list of control dynamics generators. These are scaled by
the amplitudes to alter the overall dynamics</p>
</div></blockquote>
<p><strong>initial</strong> : Qobj</p>
<blockquote>
<div><p>starting point for the evolution.
Typically the identity matrix</p>
</div></blockquote>
<p><strong>target</strong> : Qobj</p>
<blockquote>
<div><p>target transformation, e.g. gate or state, for the time evolution</p>
</div></blockquote>
<p><strong>num_tslots</strong> : integer or None</p>
<blockquote>
<div><p>number of timeslots.
None implies that timeslots will be given in the tau array</p>
</div></blockquote>
<p><strong>evo_time</strong> : float or None</p>
<blockquote>
<div><p>total time for the evolution
None implies that timeslots will be given in the tau array</p>
</div></blockquote>
<p><strong>tau</strong> : array[num_tslots] of floats or None</p>
<blockquote>
<div><p>durations for the timeslots.
if this is given then num_tslots and evo_time are dervived
from it
None implies that timeslot durations will be equal and
calculated as evo_time/num_tslots</p>
</div></blockquote>
<p><strong>amp_lbound</strong> : float or list of floats</p>
<blockquote>
<div><p>lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</div></blockquote>
<p><strong>amp_ubound</strong> : float or list of floats</p>
<blockquote>
<div><p>upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</div></blockquote>
<p><strong>fid_err_targ</strong> : float</p>
<blockquote>
<div><p>Fidelity error target. Pulse optimisation will
terminate when the fidelity error falls below this value</p>
</div></blockquote>
<p><strong>max_iter</strong> : integer</p>
<blockquote>
<div><p>Maximum number of iterations of the optimisation algorithm</p>
</div></blockquote>
<p><strong>max_wall_time</strong> : float</p>
<blockquote>
<div><p>Maximum allowed elapsed time for the  optimisation algorithm</p>
</div></blockquote>
<p><strong>alg_params</strong> : Dictionary</p>
<blockquote>
<div><p>options that are specific to the algorithm see above</p>
</div></blockquote>
<p><strong>optim_params</strong> : Dictionary</p>
<blockquote>
<div><p>The key value pairs are the attribute name and value
used to set attribute values
Note: attributes are created if they do not exist already,
and are overwritten if they do.
Note: method_params are applied afterwards and so may override these</p>
</div></blockquote>
<p><strong>coeff_scaling</strong> : float</p>
<blockquote>
<div><p>Linear scale factor for the random basis coefficients
By default these range from -1.0 to 1.0
Note this is overridden by alg_params (if given there)</p>
</div></blockquote>
<p><strong>num_coeffs</strong> : integer</p>
<blockquote>
<div><p>Number of coefficients used for each basis function
Note this is calculated automatically based on the dimension of the
dynamics if not given. It is crucial to the performane of the
algorithm that it is set as low as possible, while still giving
high enough frequencies.
Note this is overridden by alg_params (if given there)</p>
</div></blockquote>
<p><strong>optim_method</strong> : string</p>
<blockquote>
<div><p>Multi-variable optimisation method
The only tested options are ‘fmin’ and ‘Nelder-mead’
In theory any non-gradient method implemented in
scipy.optimize.mininize could be used.</p>
</div></blockquote>
<p><strong>method_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the optim_method.
Note that where there is an attribute of the
Optimizer object or the termination_conditions matching the key
that attribute. Otherwise, and in some case also,
they are assumed to be method_options
for the scipy.optimize.minimize method.
The commonly used parameter are:</p>
<blockquote>
<div><p>xtol - limit on variable change for convergence
ftol - limit on fidelity error change for convergence</p>
</div></blockquote>
</div></blockquote>
<p><strong>dyn_type</strong> : string</p>
<blockquote>
<div><p>Dynamics type, i.e. the type of matrix used to describe
the dynamics. Options are UNIT, GEN_MAT, SYMPL
(see Dynamics classes for details)</p>
</div></blockquote>
<p><strong>dyn_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the Dynamics object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>prop_type</strong> : string</p>
<blockquote>
<div><p>Propagator type i.e. the method used to calculate the
propagtors and propagtor gradient for each timeslot
options are DEF, APPROX, DIAG, FRECHET, AUG_MAT
DEF will use the default for the specific dyn_type
(see PropagatorComputer classes for details)</p>
</div></blockquote>
<p><strong>prop_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the PropagatorComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>fid_type</strong> : string</p>
<blockquote>
<div><p>Fidelity error (and fidelity error gradient) computation method
Options are DEF, UNIT, TRACEDIFF, TD_APPROX
DEF will use the default for the specific dyn_type
(See FidelityComputer classes for details)</p>
</div></blockquote>
<p><strong>fid_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the FidelityComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>tslot_type</strong> : string</p>
<blockquote>
<div><p>Method for computing the dynamics generators, propagators and
evolution in the timeslots.
Options: DEF, UPDATE_ALL, DYNAMIC
UPDATE_ALL is the only one that currently works
(See TimeslotComputer classes for details)</p>
</div></blockquote>
<p><strong>tslot_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the TimeslotComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>guess_pulse_type</strong> : string</p>
<blockquote>
<div><p>type / shape of pulse(s) used modulate the control amplitudes.
Options include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN</p>
</div></blockquote>
<p>Default is None</p>
</div></blockquote>
<p><strong>guess_pulse_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the guess pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>guess_pulse_action</strong> : string</p>
<blockquote>
<div><p>Determines how the guess pulse is applied to the pulse generated
by the basis expansion.
Options are: MODULATE, ADD
Default is MODULATE</p>
</div></blockquote>
<p><strong>pulse_scaling</strong> : float</p>
<blockquote>
<div><p>Linear scale factor for generated guess pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</div></blockquote>
<p><strong>pulse_offset</strong> : float</p>
<blockquote>
<div><p>Linear offset for the pulse. That is this value will be added
to any guess pulses generated.</p>
</div></blockquote>
<p><strong>ramping_pulse_type</strong> : string</p>
<blockquote>
<div><p>Type of pulse used to modulate the control pulse.
It’s intended use for a ramping modulation, which is often required in
experimental setups.
This is only currently implemented in CRAB.
GAUSSIAN_EDGE was added for this purpose.</p>
</div></blockquote>
<p><strong>ramping_pulse_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the ramping pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>log_level</strong> : integer</p>
<blockquote>
<div><p>level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</div></blockquote>
<p><strong>out_file_ext</strong> : string or None</p>
<blockquote>
<div><p>files containing the initial and final control pulse
amplitudes are saved to the current directory.
The default name will be postfixed with this extension
Setting this to None will suppress the output of files</p>
</div></blockquote>
<p><strong>gen_stats</strong> : boolean</p>
<blockquote>
<div><p>if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>opt</strong> : OptimResult</p>
<blockquote class="last">
<div><p>Returns instance of OptimResult, which has attributes giving the
reason for termination, final fidelity error, final evolution
final amplitudes, statistics etc</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.control.pulseoptim.opt_pulse_crab_unitary">
<code class="descname">opt_pulse_crab_unitary</code><span class="sig-paren">(</span><em>H_d</em>, <em>H_c</em>, <em>U_0</em>, <em>U_targ</em>, <em>num_tslots=None</em>, <em>evo_time=None</em>, <em>tau=None</em>, <em>amp_lbound=None</em>, <em>amp_ubound=None</em>, <em>fid_err_targ=1e-05</em>, <em>max_iter=500</em>, <em>max_wall_time=180</em>, <em>alg_params=None</em>, <em>num_coeffs=None</em>, <em>init_coeff_scaling=1.0</em>, <em>optim_params=None</em>, <em>optim_method=’fmin’</em>, <em>method_params=None</em>, <em>phase_option=’PSU’</em>, <em>dyn_params=None</em>, <em>prop_params=None</em>, <em>fid_params=None</em>, <em>tslot_type=’DEF’</em>, <em>tslot_params=None</em>, <em>guess_pulse_type=None</em>, <em>guess_pulse_params=None</em>, <em>guess_pulse_scaling=1.0</em>, <em>guess_pulse_offset=0.0</em>, <em>guess_pulse_action=’MODULATE’</em>, <em>ramping_pulse_type=None</em>, <em>ramping_pulse_params=None</em>, <em>log_level=0</em>, <em>out_file_ext=None</em>, <em>gen_stats=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulseoptim.html#opt_pulse_crab_unitary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulseoptim.opt_pulse_crab_unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise a control pulse to minimise the fidelity error, assuming that
the dynamics of the system are generated by unitary operators.
This function is simply a wrapper for optimize_pulse, where the
appropriate options for unitary dynamics are chosen and the parameter
names are in the format familiar to unitary dynamics
The dynamics of the system  in any given timeslot are governed
by the combined Hamiltonian,
i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]
The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes</p>
<p>The CRAB algorithm uses basis function coefficents as the variables to
optimise. It does NOT use any gradient function.
A multivariable optimisation algorithm attempts to determines the
optimal values for the control pulse to minimise the fidelity error
The fidelity error is some measure of distance of the system evolution
from the given target evolution in the time allowed for the evolution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H_d</strong> : Qobj or list of Qobj</p>
<blockquote>
<div><p>Drift (aka system) the underlying Hamiltonian of the system
can provide list (of length num_tslots) for time dependent drift</p>
</div></blockquote>
<p><strong>H_c</strong> : Qobj</p>
<blockquote>
<div><p>a list of control Hamiltonians. These are scaled by
the amplitudes to alter the overall dynamics</p>
</div></blockquote>
<p><strong>U_0</strong> : Qobj</p>
<blockquote>
<div><p>starting point for the evolution.
Typically the identity matrix</p>
</div></blockquote>
<p><strong>U_targ</strong> : Qobj</p>
<blockquote>
<div><p>target transformation, e.g. gate or state, for the time evolution</p>
</div></blockquote>
<p><strong>num_tslots</strong> : integer or None</p>
<blockquote>
<div><p>number of timeslots.
None implies that timeslots will be given in the tau array</p>
</div></blockquote>
<p><strong>evo_time</strong> : float or None</p>
<blockquote>
<div><p>total time for the evolution
None implies that timeslots will be given in the tau array</p>
</div></blockquote>
<p><strong>tau</strong> : array[num_tslots] of floats or None</p>
<blockquote>
<div><p>durations for the timeslots.
if this is given then num_tslots and evo_time are dervived
from it
None implies that timeslot durations will be equal and
calculated as evo_time/num_tslots</p>
</div></blockquote>
<p><strong>amp_lbound</strong> : float or list of floats</p>
<blockquote>
<div><p>lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</div></blockquote>
<p><strong>amp_ubound</strong> : float or list of floats</p>
<blockquote>
<div><p>upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</div></blockquote>
<p><strong>fid_err_targ</strong> : float</p>
<blockquote>
<div><p>Fidelity error target. Pulse optimisation will
terminate when the fidelity error falls below this value</p>
</div></blockquote>
<p><strong>max_iter</strong> : integer</p>
<blockquote>
<div><p>Maximum number of iterations of the optimisation algorithm</p>
</div></blockquote>
<p><strong>max_wall_time</strong> : float</p>
<blockquote>
<div><p>Maximum allowed elapsed time for the  optimisation algorithm</p>
</div></blockquote>
<p><strong>alg_params</strong> : Dictionary</p>
<blockquote>
<div><p>options that are specific to the algorithm see above</p>
</div></blockquote>
<p><strong>optim_params</strong> : Dictionary</p>
<blockquote>
<div><p>The key value pairs are the attribute name and value
used to set attribute values
Note: attributes are created if they do not exist already,
and are overwritten if they do.
Note: method_params are applied afterwards and so may override these</p>
</div></blockquote>
<p><strong>coeff_scaling</strong> : float</p>
<blockquote>
<div><p>Linear scale factor for the random basis coefficients
By default these range from -1.0 to 1.0
Note this is overridden by alg_params (if given there)</p>
</div></blockquote>
<p><strong>num_coeffs</strong> : integer</p>
<blockquote>
<div><p>Number of coefficients used for each basis function
Note this is calculated automatically based on the dimension of the
dynamics if not given. It is crucial to the performane of the
algorithm that it is set as low as possible, while still giving
high enough frequencies.
Note this is overridden by alg_params (if given there)</p>
</div></blockquote>
<p><strong>optim_method</strong> : string</p>
<blockquote>
<div><p>Multi-variable optimisation method
The only tested options are ‘fmin’ and ‘Nelder-mead’
In theory any non-gradient method implemented in
scipy.optimize.mininize could be used.</p>
</div></blockquote>
<p><strong>method_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the optim_method.
Note that where there is an attribute of the
Optimizer object or the termination_conditions matching the key
that attribute. Otherwise, and in some case also,
they are assumed to be method_options
for the scipy.optimize.minimize method.
The commonly used parameter are:</p>
<blockquote>
<div><p>xtol - limit on variable change for convergence
ftol - limit on fidelity error change for convergence</p>
</div></blockquote>
</div></blockquote>
<p><strong>phase_option</strong> : string</p>
<blockquote>
<div><p>determines how global phase is treated in fidelity
calculations (fid_type=’UNIT’ only). Options:</p>
<blockquote>
<div><p>PSU - global phase ignored
SU - global phase included</p>
</div></blockquote>
</div></blockquote>
<p><strong>dyn_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the Dynamics object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>prop_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the PropagatorComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>fid_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the FidelityComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>tslot_type</strong> : string</p>
<blockquote>
<div><p>Method for computing the dynamics generators, propagators and
evolution in the timeslots.
Options: DEF, UPDATE_ALL, DYNAMIC
UPDATE_ALL is the only one that currently works
(See TimeslotComputer classes for details)</p>
</div></blockquote>
<p><strong>tslot_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the TimeslotComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>guess_pulse_type</strong> : string</p>
<blockquote>
<div><p>type / shape of pulse(s) used modulate the control amplitudes.
Options include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN</p>
</div></blockquote>
<p>Default is None</p>
</div></blockquote>
<p><strong>guess_pulse_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the guess pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>guess_pulse_action</strong> : string</p>
<blockquote>
<div><p>Determines how the guess pulse is applied to the pulse generated
by the basis expansion.
Options are: MODULATE, ADD
Default is MODULATE</p>
</div></blockquote>
<p><strong>pulse_scaling</strong> : float</p>
<blockquote>
<div><p>Linear scale factor for generated guess pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</div></blockquote>
<p><strong>pulse_offset</strong> : float</p>
<blockquote>
<div><p>Linear offset for the pulse. That is this value will be added
to any guess pulses generated.</p>
</div></blockquote>
<p><strong>ramping_pulse_type</strong> : string</p>
<blockquote>
<div><p>Type of pulse used to modulate the control pulse.
It’s intended use for a ramping modulation, which is often required in
experimental setups.
This is only currently implemented in CRAB.
GAUSSIAN_EDGE was added for this purpose.</p>
</div></blockquote>
<p><strong>ramping_pulse_params</strong> : dict</p>
<blockquote>
<div><p>Parameters for the ramping pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</div></blockquote>
<p><strong>log_level</strong> : integer</p>
<blockquote>
<div><p>level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</div></blockquote>
<p><strong>out_file_ext</strong> : string or None</p>
<blockquote>
<div><p>files containing the initial and final control pulse
amplitudes are saved to the current directory.
The default name will be postfixed with this extension
Setting this to None will suppress the output of files</p>
</div></blockquote>
<p><strong>gen_stats</strong> : boolean</p>
<blockquote>
<div><p>if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>opt</strong> : OptimResult</p>
<blockquote class="last">
<div><p>Returns instance of OptimResult, which has attributes giving the
reason for termination, final fidelity error, final evolution
final amplitudes, statistics etc</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<span class="target" id="module-qutip.control.pulsegen"></span><p>Pulse generator - Generate pulses for the timeslots
Each class defines a gen_pulse function that produces a float array of
size num_tslots. Each class produces a differ type of pulse.
See the class and gen_pulse function descriptions for details</p>
<dl class="function">
<dt id="qutip.control.pulsegen.create_pulse_gen">
<code class="descname">create_pulse_gen</code><span class="sig-paren">(</span><em>pulse_type=’RND’</em>, <em>dyn=None</em>, <em>pulse_params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#create_pulse_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.create_pulse_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a pulse generator object matching the given type.
The pulse generators each produce a different type of pulse,
see the gen_pulse function description for details.
These are the random pulse options:</p>
<blockquote>
<div>RND - Independent random value in each timeslot
RNDFOURIER - Fourier series with random coefficients
RNDWAVES - Summation of random waves
RNDWALK1 - Random change in amplitude each timeslot
RNDWALK2 - Random change in amp gradient each timeslot</div></blockquote>
<p>These are the other non-periodic options:</p>
<blockquote>
<div>LIN - Linear, i.e. contant gradient over the time
ZERO - special case of the LIN pulse, where the gradient is 0</div></blockquote>
<p>These are the periodic options</p>
<blockquote>
<div>SINE - Sine wave
SQUARE - Square wave
SAW - Saw tooth wave
TRIANGLE - Triangular wave</div></blockquote>
<p>If a Dynamics object is passed in then this is used in instantiate
the PulseGen, meaning that some timeslot and amplitude properties
are copied over.</p>
</dd></dl>

</div>
<div class="section" id="utilitiy-functions">
<h2>Utilitiy Functions<a class="headerlink" href="#utilitiy-functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.graph">
<span id="graph-theory-routines"></span><span id="functions-graph"></span><h3>Graph Theory Routines<a class="headerlink" href="#module-qutip.graph" title="Permalink to this headline">¶</a></h3>
<p>This module contains a collection of graph theory routines used mainly
to reorder matrices for iterative steady state solvers.</p>
<dl class="function">
<dt id="qutip.graph.breadth_first_search">
<code class="descname">breadth_first_search</code><span class="sig-paren">(</span><em>A</em>, <em>start</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/graph.html#breadth_first_search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.breadth_first_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting
from a given node (row).  Takes Qobjs and CSR or CSC matrices as inputs.</p>
<p>This function requires a matrix with symmetric structure.
Use A+trans(A) if original matrix is not symmetric or not sure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : csc_matrix, csr_matrix</p>
<blockquote>
<div><p>Input graph in CSC or CSR matrix format</p>
</div></blockquote>
<p><strong>start</strong> : int</p>
<blockquote>
<div><p>Staring node for BFS traversal.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>order</strong> : array</p>
<blockquote>
<div><p>Order in which nodes are traversed from starting node.</p>
</div></blockquote>
<p><strong>levels</strong> : array</p>
<blockquote class="last">
<div><p>Level of the nodes in the order that they are traversed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.graph.graph_degree">
<code class="descname">graph_degree</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/graph.html#graph_degree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.graph_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the degree for the nodes (rows) of a symmetric
graph in sparse CSR or CSC format, or a qobj.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj, csr_matrix, csc_matrix</p>
<blockquote>
<div><p>Input quantum object or csr_matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>degree</strong> : array</p>
<blockquote class="last">
<div><p>Array of integers giving the degree for each node (row).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.graph.reverse_cuthill_mckee">
<code class="descname">reverse_cuthill_mckee</code><span class="sig-paren">(</span><em>A</em>, <em>sym=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/graph.html#reverse_cuthill_mckee"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.reverse_cuthill_mckee" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the permutation array that orders a sparse CSR or CSC matrix
in Reverse-Cuthill McKee ordering. Since the input matrix must be
symmetric, this routine works on the matrix A+Trans(A) if the sym flag is
set to False (Default).</p>
<p>It is assumed by default (<em>sym=False</em>) that the input matrix is not
symmetric. This is because it is faster to do A+Trans(A) than it is to
check for symmetry for a generic matrix. If you are guaranteed that the
matrix is symmetric in structure (values of matrix element do not matter)
then set <em>sym=True</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : csc_matrix, csr_matrix</p>
<blockquote>
<div><p>Input sparse CSC or CSR sparse matrix format.</p>
</div></blockquote>
<p><strong>sym</strong> : bool {False, True}</p>
<blockquote>
<div><p>Flag to set whether input matrix is symmetric.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>perm</strong> : array</p>
<blockquote class="last">
<div><p>Array of permuted row and column indices.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This routine is used primarily for internal reordering of Lindblad
superoperators for use in iterative solver routines.</p>
<p class="rubric">References</p>
<p>E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric
Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,
(1969).</p>
</dd></dl>

<dl class="function">
<dt id="qutip.graph.maximum_bipartite_matching">
<code class="descname">maximum_bipartite_matching</code><span class="sig-paren">(</span><em>A</em>, <em>perm_type=’row’</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/graph.html#maximum_bipartite_matching"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.maximum_bipartite_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of row or column permutations that removes nonzero
elements from the diagonal of a nonsingular square CSC sparse matrix. Such
a permutation is always possible provided that the matrix is nonsingular.
This function looks at the structure of the matrix only.</p>
<p>The input matrix will be converted to CSC matrix format if
necessary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : sparse matrix</p>
<blockquote>
<div><p>Input matrix</p>
</div></blockquote>
<p><strong>perm_type</strong> : str {‘row’, ‘column’}</p>
<blockquote>
<div><p>Type of permutation to generate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>perm</strong> : array</p>
<blockquote class="last">
<div><p>Array of row or column permutations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function relies on a maximum cardinality bipartite matching algorithm
based on a breadth-first search (BFS) of the underlying graph[1]_.</p>
<p class="rubric">References</p>
<p>I. S. Duff, K. Kaya, and B. Ucar, “Design, Implementation, and
Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.
38, no. 2, (2011).</p>
</dd></dl>

<dl class="function">
<dt id="qutip.graph.weighted_bipartite_matching">
<code class="descname">weighted_bipartite_matching</code><span class="sig-paren">(</span><em>A</em>, <em>perm_type=’row’</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/graph.html#weighted_bipartite_matching"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.weighted_bipartite_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of row permutations that attempts to maximize
the product of the ABS values of the diagonal elements in
a nonsingular square CSC sparse matrix. Such a permutation is
always possible provided that the matrix is nonsingular.</p>
<p>This function looks at both the structure and ABS values of the
underlying matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : csc_matrix</p>
<blockquote>
<div><p>Input matrix</p>
</div></blockquote>
<p><strong>perm_type</strong> : str {‘row’, ‘column’}</p>
<blockquote>
<div><p>Type of permutation to generate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>perm</strong> : array</p>
<blockquote class="last">
<div><p>Array of row or column permutations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function uses a weighted maximum cardinality bipartite matching
algorithm based on breadth-first search (BFS).  The columns are weighted
according to the element of max ABS value in the associated rows and
are traversed in descending order by weight.  When performing the BFS
traversal, the row associated to a given column is the one with maximum
weight. Unlike other techniques[1]_, this algorithm does not guarantee the
product of the diagonal is maximized.  However, this limitation is offset
by the substantially faster runtime of this method.</p>
<p class="rubric">References</p>
<p>I. S. Duff and J. Koster, “The design and use of algorithms for
permuting large entries to the diagonal of sparse matrices”, SIAM J.
Matrix Anal. and Applics. 20, no. 4, 889 (1997).</p>
</dd></dl>

</div>
<div class="section" id="module-qutip.utilities">
<span id="utility-functions"></span><span id="functions-utilities"></span><h3>Utility Functions<a class="headerlink" href="#module-qutip.utilities" title="Permalink to this headline">¶</a></h3>
<p>This module contains utility functions that are commonly needed in other
qutip modules.</p>
<dl class="function">
<dt id="qutip.utilities.n_thermal">
<code class="descname">n_thermal</code><span class="sig-paren">(</span><em>w</em>, <em>w_th</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/utilities.html#n_thermal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.utilities.n_thermal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of photons in thermal equilibrium for an harmonic
oscillator mode with frequency ‘w’, at the temperature described by
‘w_th’ where <span class="math">\(\omega_{\rm th} = k_BT/\hbar\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>w</strong> : <em>float</em> or <em>array</em></p>
<blockquote>
<div><p>Frequency of the oscillator.</p>
</div></blockquote>
<p><strong>w_th</strong> : <em>float</em></p>
<blockquote>
<div><p>The temperature in units of frequency (or the same units as <cite>w</cite>).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>n_avg</strong> : <em>float</em> or <em>array</em></p>
<blockquote class="last">
<div><p>Return the number of average photons in thermal equilibrium for a
an oscillator with the given frequency and temperature.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.utilities.linspace_with">
<code class="descname">linspace_with</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em>, <em>num=50</em>, <em>elems=[]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/utilities.html#linspace_with"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.utilities.linspace_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of numbers sampled over specified interval
with additional elements added.</p>
<p>Returns <cite>num</cite> spaced array with elements from <cite>elems</cite> inserted
if not already included in set.</p>
<p>Returned sample array is not evenly spaced if addtional elements
are added.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>start</strong> : int</p>
<blockquote>
<div><p>The starting value of the sequence.</p>
</div></blockquote>
<p><strong>stop</strong> : int</p>
<blockquote>
<div><p>The stoping values of the sequence.</p>
</div></blockquote>
<p><strong>num</strong> : int, optional</p>
<blockquote>
<div><p>Number of samples to generate.</p>
</div></blockquote>
<p><strong>elems</strong> : list/ndarray, optional</p>
<blockquote>
<div><p>Requested elements to include in array</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>samples</strong> : ndadrray</p>
<blockquote class="last">
<div><p>Original equally spaced sample array with additional
elements added.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.utilities.clebsch">
<code class="descname">clebsch</code><span class="sig-paren">(</span><em>j1</em>, <em>j2</em>, <em>j3</em>, <em>m1</em>, <em>m2</em>, <em>m3</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/utilities.html#clebsch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.utilities.clebsch" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Clebsch-Gordon coefficient
for coupling (j1,m1) and (j2,m2) to give (j3,m3).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>j1</strong> : float</p>
<blockquote>
<div><p>Total angular momentum 1.</p>
</div></blockquote>
<p><strong>j2</strong> : float</p>
<blockquote>
<div><p>Total angular momentum 2.</p>
</div></blockquote>
<p><strong>j3</strong> : float</p>
<blockquote>
<div><p>Total angular momentum 3.</p>
</div></blockquote>
<p><strong>m1</strong> : float</p>
<blockquote>
<div><p>z-component of angular momentum 1.</p>
</div></blockquote>
<p><strong>m2</strong> : float</p>
<blockquote>
<div><p>z-component of angular momentum 2.</p>
</div></blockquote>
<p><strong>m3</strong> : float</p>
<blockquote>
<div><p>z-component of angular momentum 3.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cg_coeff</strong> : float</p>
<blockquote class="last">
<div><p>Requested Clebsch-Gordan coefficient.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.utilities.convert_unit">
<code class="descname">convert_unit</code><span class="sig-paren">(</span><em>value</em>, <em>orig=’meV’</em>, <em>to=’GHz’</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/utilities.html#convert_unit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.utilities.convert_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an energy from unit <cite>orig</cite> to unit <cite>to</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>value</strong> : float / array</p>
<blockquote>
<div><p>The energy in the old unit.</p>
</div></blockquote>
<p><strong>orig</strong> : string</p>
<blockquote>
<div><p>The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”)</p>
</div></blockquote>
<p><strong>to</strong> : string</p>
<blockquote>
<div><p>The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>value_new_unit</strong> : float / array</p>
<blockquote class="last">
<div><p>The energy in the new unit.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.fileio">
<span id="file-i-o-functions"></span><span id="functions-fileio"></span><h3>File I/O Functions<a class="headerlink" href="#module-qutip.fileio" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.fileio.file_data_read">
<code class="descname">file_data_read</code><span class="sig-paren">(</span><em>filename</em>, <em>sep=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/fileio.html#file_data_read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.fileio.file_data_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves an array of data from the requested file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Name of file containing reqested data.</p>
</div></blockquote>
<p><strong>sep</strong> : str</p>
<blockquote>
<div><p>Seperator used to store data.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>data</strong> : array_like</p>
<blockquote class="last">
<div><p>Data from selected file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.fileio.file_data_store">
<code class="descname">file_data_store</code><span class="sig-paren">(</span><em>filename</em>, <em>data</em>, <em>numtype=’complex’</em>, <em>numformat=’decimal’</em>, <em>sep=’</em>, <em>’</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/fileio.html#file_data_store"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.fileio.file_data_store" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores a matrix of data to a file to be read by an external program.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Name of data file to be stored, including extension.</p>
</div></blockquote>
<p><strong>data: array_like</strong></p>
<blockquote>
<div><p>Data to be written to file.</p>
</div></blockquote>
<p><strong>numtype</strong> : str {‘complex, ‘real’}</p>
<blockquote>
<div><p>Type of numerical data.</p>
</div></blockquote>
<p><strong>numformat</strong> : str {‘decimal’,’exp’}</p>
<blockquote>
<div><p>Format for written data.</p>
</div></blockquote>
<p><strong>sep</strong> : str</p>
<blockquote class="last">
<div><p>Single-character field seperator.  Usually a tab, space, comma,
or semicolon.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.fileio.qload">
<code class="descname">qload</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/fileio.html#qload"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.fileio.qload" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads data file from file named ‘filename.qu’ in current directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>name</strong> : str</p>
<blockquote>
<div><p>Name of data file to be loaded.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>qobject</strong> : instance / array_like</p>
<blockquote class="last">
<div><p>Object retrieved from requested file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.fileio.qsave">
<code class="descname">qsave</code><span class="sig-paren">(</span><em>data</em>, <em>name=’qutip_data’</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/fileio.html#qsave"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.fileio.qsave" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves given data to file named ‘filename.qu’ in current directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : instance/array_like</p>
<blockquote>
<div><p>Input Python object to be stored.</p>
</div></blockquote>
<p><strong>filename</strong> : str</p>
<blockquote class="last">
<div><p>Name of output data file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.parallel">
<span id="parallelization"></span><span id="functions-parallel"></span><h3>Parallelization<a class="headerlink" href="#module-qutip.parallel" title="Permalink to this headline">¶</a></h3>
<p>This function provides functions for parallel execution of loops and function
mappings, using the builtin Python module multiprocessing.</p>
<dl class="function">
<dt id="qutip.parallel.parfor">
<code class="descname">parfor</code><span class="sig-paren">(</span><em>func</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/parallel.html#parfor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.parallel.parfor" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes a multi-variable function in parallel on the local machine.</p>
<p>Parallel execution of a for-loop over function <cite>func</cite> for multiple input
arguments and keyword arguments.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">From QuTiP 3.1, we recommend to use <code class="xref py py-func docutils literal"><span class="pre">qutip.parallel_map</span></code>
instead of this function.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>func</strong> : function_type</p>
<blockquote>
<div><p>A function to run in parallel on the local machine. The function ‘func’
accepts a series of arguments that are passed to the function as
variables. In general, the function can have multiple input variables,
and these arguments must be passed in the same order as they are
defined in the function definition.  In addition, the user can pass
multiple keyword arguments to the function.</p>
</div></blockquote>
<p><strong>The following keyword argument is reserved:</strong></p>
<p><strong>num_cpus</strong> : int</p>
<blockquote>
<div><p>Number of CPU’s to use.  Default uses maximum number of CPU’s.
Performance degrades if num_cpus is larger than the physical CPU
count of your machine.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : list</p>
<blockquote class="last">
<div><p>A <code class="docutils literal"><span class="pre">list</span></code> with length equal to number of input parameters
containing the output from <cite>func</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.parallel.parallel_map">
<code class="descname">parallel_map</code><span class="sig-paren">(</span><em>task</em>, <em>values</em>, <em>task_args=()</em>, <em>task_kwargs={}</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/parallel.html#parallel_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.parallel.parallel_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel execution of a mapping of <cite>values</cite> to the function <cite>task</cite>. This
is functionally equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">task_args</span><span class="p">,</span> <span class="o">**</span><span class="n">task_kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>task</strong> : a Python function</p>
<blockquote>
<div><p>The function that is to be called for each value in <code class="docutils literal"><span class="pre">task_vec</span></code>.</p>
</div></blockquote>
<p><strong>values</strong> : array / list</p>
<blockquote>
<div><p>The list or array of values for which the <code class="docutils literal"><span class="pre">task</span></code> function is to be
evaluated.</p>
</div></blockquote>
<p><strong>task_args</strong> : list / dictionary</p>
<blockquote>
<div><p>The optional additional argument to the <code class="docutils literal"><span class="pre">task</span></code> function.</p>
</div></blockquote>
<p><strong>task_kwargs</strong> : list / dictionary</p>
<blockquote>
<div><p>The optional additional keyword argument to the <code class="docutils literal"><span class="pre">task</span></code> function.</p>
</div></blockquote>
<p><strong>progress_bar</strong> : ProgressBar</p>
<blockquote>
<div><p>Progress bar class instance for showing progress.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : list</p>
<blockquote class="last">
<div><p>The result list contains the value of
<code class="docutils literal"><span class="pre">task(value,</span> <span class="pre">*task_args,</span> <span class="pre">**task_kwargs)</span></code> for
each value in <code class="docutils literal"><span class="pre">values</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.parallel.serial_map">
<code class="descname">serial_map</code><span class="sig-paren">(</span><em>task</em>, <em>values</em>, <em>task_args=()</em>, <em>task_kwargs={}</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/parallel.html#serial_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.parallel.serial_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Serial mapping function with the same call signature as parallel_map, for
easy switching between serial and parallel execution. This
is functionally equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">task_args</span><span class="p">,</span> <span class="o">**</span><span class="n">task_kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
</pre></div>
</div>
<p>This function work as a drop-in replacement of <code class="xref py py-func docutils literal"><span class="pre">qutip.parallel_map</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>task</strong> : a Python function</p>
<blockquote>
<div><p>The function that is to be called for each value in <code class="docutils literal"><span class="pre">task_vec</span></code>.</p>
</div></blockquote>
<p><strong>values</strong> : array / list</p>
<blockquote>
<div><p>The list or array of values for which the <code class="docutils literal"><span class="pre">task</span></code> function is to be
evaluated.</p>
</div></blockquote>
<p><strong>task_args</strong> : list / dictionary</p>
<blockquote>
<div><p>The optional additional argument to the <code class="docutils literal"><span class="pre">task</span></code> function.</p>
</div></blockquote>
<p><strong>task_kwargs</strong> : list / dictionary</p>
<blockquote>
<div><p>The optional additional keyword argument to the <code class="docutils literal"><span class="pre">task</span></code> function.</p>
</div></blockquote>
<p><strong>progress_bar</strong> : ProgressBar</p>
<blockquote>
<div><p>Progress bar class instance for showing progress.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : list</p>
<blockquote class="last">
<div><p>The result list contains the value of
<code class="docutils literal"><span class="pre">task(value,</span> <span class="pre">*task_args,</span> <span class="pre">**task_kwargs)</span></code> for each
value in <code class="docutils literal"><span class="pre">values</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.ipynbtools">
<span id="ipython-notebook-tools"></span><span id="functions-ipython"></span><h3>IPython Notebook Tools<a class="headerlink" href="#module-qutip.ipynbtools" title="Permalink to this headline">¶</a></h3>
<p>This module contains utility functions for using QuTiP with IPython notebooks.</p>
<dl class="function">
<dt id="qutip.ipynbtools.parfor">
<code class="descname">parfor</code><span class="sig-paren">(</span><em>task</em>, <em>task_vec</em>, <em>args=None</em>, <em>client=None</em>, <em>view=None</em>, <em>show_scheduling=False</em>, <em>show_progressbar=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/ipynbtools.html#parfor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.ipynbtools.parfor" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the function <code class="docutils literal"><span class="pre">tast</span></code> for each value in <code class="docutils literal"><span class="pre">task_vec</span></code> using a cluster
of IPython engines. The function <code class="docutils literal"><span class="pre">task</span></code> should have the signature
<code class="docutils literal"><span class="pre">task(value,</span> <span class="pre">args)</span></code> or <code class="docutils literal"><span class="pre">task(value)</span></code> if <code class="docutils literal"><span class="pre">args=None</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">client</span></code> and <code class="docutils literal"><span class="pre">view</span></code> are the IPython.parallel client and
load-balanced view that will be used in the parfor execution. If these
are <code class="docutils literal"><span class="pre">None</span></code>, new instances will be created.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>task: a Python function</strong></p>
<blockquote>
<div><p>The function that is to be called for each value in <code class="docutils literal"><span class="pre">task_vec</span></code>.</p>
</div></blockquote>
<p><strong>task_vec: array / list</strong></p>
<blockquote>
<div><p>The list or array of values for which the <code class="docutils literal"><span class="pre">task</span></code> function is to be
evaluated.</p>
</div></blockquote>
<p><strong>args: list / dictionary</strong></p>
<blockquote>
<div><p>The optional additional argument to the <code class="docutils literal"><span class="pre">task</span></code> function. For example
a dictionary with parameter values.</p>
</div></blockquote>
<p><strong>client: IPython.parallel.Client</strong></p>
<blockquote>
<div><p>The IPython.parallel Client instance that will be used in the
parfor execution.</p>
</div></blockquote>
<p><strong>view: a IPython.parallel.Client view</strong></p>
<blockquote>
<div><p>The view that is to be used in scheduling the tasks on the IPython
cluster. Preferably a load-balanced view, which is obtained from the
IPython.parallel.Client instance client by calling,
view = client.load_balanced_view().</p>
</div></blockquote>
<p><strong>show_scheduling: bool {False, True}, default False</strong></p>
<blockquote>
<div><p>Display a graph showing how the tasks (the evaluation of <code class="docutils literal"><span class="pre">task</span></code> for
for the value in <code class="docutils literal"><span class="pre">task_vec1</span></code>) was scheduled on the IPython engine
cluster.</p>
</div></blockquote>
<p><strong>show_progressbar: bool {False, True}, default False</strong></p>
<blockquote>
<div><p>Display a HTML-based progress bar duing the execution of the parfor
loop.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : list</p>
<blockquote class="last">
<div><p>The result list contains the value of <code class="docutils literal"><span class="pre">task(value,</span> <span class="pre">args)</span></code> for each
value in <code class="docutils literal"><span class="pre">task_vec</span></code>, that is, it should be equivalent to
<code class="docutils literal"><span class="pre">[task(v,</span> <span class="pre">args)</span> <span class="pre">for</span> <span class="pre">v</span> <span class="pre">in</span> <span class="pre">task_vec]</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.ipynbtools.parallel_map">
<code class="descname">parallel_map</code><span class="sig-paren">(</span><em>task</em>, <em>values</em>, <em>task_args=None</em>, <em>task_kwargs=None</em>, <em>client=None</em>, <em>view=None</em>, <em>progress_bar=None</em>, <em>show_scheduling=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/ipynbtools.html#parallel_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.ipynbtools.parallel_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the function <code class="docutils literal"><span class="pre">task</span></code> for each value in <code class="docutils literal"><span class="pre">values</span></code> using a cluster
of IPython engines. The function <code class="docutils literal"><span class="pre">task</span></code> should have the signature
<code class="docutils literal"><span class="pre">task(value,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">client</span></code> and <code class="docutils literal"><span class="pre">view</span></code> are the IPython.parallel client and
load-balanced view that will be used in the parfor execution. If these
are <code class="docutils literal"><span class="pre">None</span></code>, new instances will be created.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>task: a Python function</strong></p>
<blockquote>
<div><p>The function that is to be called for each value in <code class="docutils literal"><span class="pre">task_vec</span></code>.</p>
</div></blockquote>
<p><strong>values: array / list</strong></p>
<blockquote>
<div><p>The list or array of values for which the <code class="docutils literal"><span class="pre">task</span></code> function is to be
evaluated.</p>
</div></blockquote>
<p><strong>task_args: list / dictionary</strong></p>
<blockquote>
<div><p>The optional additional argument to the <code class="docutils literal"><span class="pre">task</span></code> function.</p>
</div></blockquote>
<p><strong>task_kwargs: list / dictionary</strong></p>
<blockquote>
<div><p>The optional additional keyword argument to the <code class="docutils literal"><span class="pre">task</span></code> function.</p>
</div></blockquote>
<p><strong>client: IPython.parallel.Client</strong></p>
<blockquote>
<div><p>The IPython.parallel Client instance that will be used in the
parfor execution.</p>
</div></blockquote>
<p><strong>view: a IPython.parallel.Client view</strong></p>
<blockquote>
<div><p>The view that is to be used in scheduling the tasks on the IPython
cluster. Preferably a load-balanced view, which is obtained from the
IPython.parallel.Client instance client by calling,
view = client.load_balanced_view().</p>
</div></blockquote>
<p><strong>show_scheduling: bool {False, True}, default False</strong></p>
<blockquote>
<div><p>Display a graph showing how the tasks (the evaluation of <code class="docutils literal"><span class="pre">task</span></code> for
for the value in <code class="docutils literal"><span class="pre">task_vec1</span></code>) was scheduled on the IPython engine
cluster.</p>
</div></blockquote>
<p><strong>show_progressbar: bool {False, True}, default False</strong></p>
<blockquote>
<div><p>Display a HTML-based progress bar during the execution of the parfor
loop.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : list</p>
<blockquote class="last">
<div><p>The result list contains the value of
<code class="docutils literal"><span class="pre">task(value,</span> <span class="pre">task_args,</span> <span class="pre">task_kwargs)</span></code> for each
value in <code class="docutils literal"><span class="pre">values</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.ipynbtools.version_table">
<code class="descname">version_table</code><span class="sig-paren">(</span><em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/ipynbtools.html#version_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.ipynbtools.version_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Print an HTML-formatted table with version numbers for QuTiP and its
dependencies. Use it in a IPython notebook to show which versions of
different packages that were used to run the notebook. This should make it
possible to reproduce the environment and the calculation later on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">version_table: string</p>
<blockquote class="last">
<div><p>Return an HTML-formatted string containing version information for
QuTiP dependencies.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip">
<span id="miscellaneous"></span><span id="functions-misc"></span><h3>Miscellaneous<a class="headerlink" href="#module-qutip" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.about">
<code class="descname">about</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/about.html#about"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.about" title="Permalink to this definition">¶</a></dt>
<dd><p>About box for QuTiP. Gives version numbers for
QuTiP, NumPy, SciPy, Cython, and MatPlotLib.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.simdiag">
<code class="descname">simdiag</code><span class="sig-paren">(</span><em>ops</em>, <em>evals=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/simdiag.html#simdiag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.simdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulateous diagonalization of communting Hermitian matrices..</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ops</strong> : list/array</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">list</span></code> or <code class="docutils literal"><span class="pre">array</span></code> of qobjs representing commuting Hermitian
operators.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>eigs</strong> : tuple</p>
<blockquote class="last">
<div><p>Tuple of arrays representing eigvecs and eigvals of quantum objects
corresponding to simultaneous eigenvectors and eigenvalues for each
operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../changelog.html" class="btn btn-neutral float-right" title="Change Log" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.
      Last updated on Jul 14, 2017.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'4.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>