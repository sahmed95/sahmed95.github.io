


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>qutip.stochastic &mdash; QuTiP 4.1 Documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="QuTiP 4.1 Documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> QuTiP: Quantum Toolbox in Python
          

          
          </a>

          
            
            
              <div class="version">
                4.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../frontmatter.html">Frontmatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guide/guide.html">Users Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/apidoc.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../biblio.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">QuTiP: Quantum Toolbox in Python</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>qutip.stochastic</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for qutip.stochastic</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1"># This file is part of QuTiP: Quantum Toolbox in Python.</span>
<span class="c1">#</span>
<span class="c1">#    Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.</span>
<span class="c1">#    All rights reserved.</span>
<span class="c1">#</span>
<span class="c1">#    Redistribution and use in source and binary forms, with or without</span>
<span class="c1">#    modification, are permitted provided that the following conditions are</span>
<span class="c1">#    met:</span>
<span class="c1">#</span>
<span class="c1">#    1. Redistributions of source code must retain the above copyright notice,</span>
<span class="c1">#       this list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1">#    2. Redistributions in binary form must reproduce the above copyright</span>
<span class="c1">#       notice, this list of conditions and the following disclaimer in the</span>
<span class="c1">#       documentation and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="c1">#    3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names</span>
<span class="c1">#       of its contributors may be used to endorse or promote products derived</span>
<span class="c1">#       from this software without specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1">#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="c1">#    &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="c1">#    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A</span>
<span class="c1">#    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="c1">#    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="c1">#    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="c1">#    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="c1">#    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="c1">#    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="c1">#    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="c1">#    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1">#</span>
<span class="c1">#    Significant parts of this code were contributed by Denis Vasilyev.</span>
<span class="c1">#</span>
<span class="c1">###############################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains functions for solving stochastic schrodinger and master</span>
<span class="sd">equations. The API should not be considered stable, and is subject to change</span>
<span class="sd">when we work more on optimizing this module for performance and features.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ssesolve&#39;</span><span class="p">,</span> <span class="s1">&#39;ssepdpsolve&#39;</span><span class="p">,</span> <span class="s1">&#39;smesolve&#39;</span><span class="p">,</span> <span class="s1">&#39;smepdpsolve&#39;</span><span class="p">]</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">from</span> <span class="nn">scipy.linalg.blas</span> <span class="k">import</span> <span class="n">get_blas_funcs</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">get_blas_funcs</span><span class="p">(</span><span class="s2">&quot;znrm2&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="k">import</span> <span class="n">norm</span>

<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="k">import</span> <span class="n">RandomState</span>

<span class="kn">from</span> <span class="nn">qutip.qobj</span> <span class="k">import</span> <span class="n">Qobj</span><span class="p">,</span> <span class="n">isket</span>
<span class="kn">from</span> <span class="nn">qutip.states</span> <span class="k">import</span> <span class="n">ket2dm</span>
<span class="kn">from</span> <span class="nn">qutip.solver</span> <span class="k">import</span> <span class="n">Result</span>
<span class="kn">from</span> <span class="nn">qutip.expect</span> <span class="k">import</span> <span class="n">expect</span><span class="p">,</span> <span class="n">expect_rho_vec</span>
<span class="kn">from</span> <span class="nn">qutip.superoperator</span> <span class="k">import</span> <span class="p">(</span><span class="n">spre</span><span class="p">,</span> <span class="n">spost</span><span class="p">,</span> <span class="n">mat2vec</span><span class="p">,</span> <span class="n">vec2mat</span><span class="p">,</span>
                                 <span class="n">liouvillian</span><span class="p">,</span> <span class="n">lindblad_dissipator</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">qutip.cy.spmatfuncs</span> <span class="k">import</span> <span class="n">cy_expect_psi_csr</span><span class="p">,</span> <span class="n">spmv</span><span class="p">,</span> <span class="n">cy_expect_rho_vec</span>
<span class="kn">from</span> <span class="nn">qutip.cy.stochastic</span> <span class="k">import</span> <span class="p">(</span><span class="n">cy_d1_rho_photocurrent</span><span class="p">,</span>
                                 <span class="n">cy_d2_rho_photocurrent</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">qutip.parallel</span> <span class="k">import</span> <span class="n">serial_map</span>
<span class="kn">from</span> <span class="nn">qutip.ui.progressbar</span> <span class="k">import</span> <span class="n">TextProgressBar</span>
<span class="kn">from</span> <span class="nn">qutip.solver</span> <span class="k">import</span> <span class="n">Options</span><span class="p">,</span> <span class="n">_solver_safety_check</span>
<span class="kn">from</span> <span class="nn">qutip.settings</span> <span class="k">import</span> <span class="n">debug</span>


<span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">qutip.logging_utils</span>
    <span class="kn">import</span> <span class="nn">inspect</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">logging_utils</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span>


<div class="viewcode-block" id="StochasticSolverOptions"><a class="viewcode-back" href="../../apidoc/classes.html#qutip.stochastic.StochasticSolverOptions">[docs]</a><span class="k">class</span> <span class="nc">StochasticSolverOptions</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class of options for stochastic solvers such as</span>
<span class="sd">    :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc.</span>
<span class="sd">    Options can be specified either as arguments to the constructor::</span>

<span class="sd">        sso = StochasticSolverOptions(nsubsteps=100, ...)</span>

<span class="sd">    or by changing the class attributes after creation::</span>

<span class="sd">        sso = StochasticSolverOptions()</span>
<span class="sd">        sso.nsubsteps = 1000</span>

<span class="sd">    The stochastic solvers :func:`qutip.stochastic.ssesolve`,</span>
<span class="sd">    :func:`qutip.stochastic.smesolve`, :func:`qutip.stochastic.ssepdpsolve` and</span>
<span class="sd">    :func:`qutip.stochastic.smepdpsolve` all take the same keyword arguments as</span>
<span class="sd">    the constructor of these class, and internally they use these arguments to</span>
<span class="sd">    construct an instance of this class, so it is rarely needed to explicitly</span>
<span class="sd">    create an instance of this class.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    H : :class:`qutip.Qobj`</span>
<span class="sd">        System Hamiltonian.</span>

<span class="sd">    state0 : :class:`qutip.Qobj`</span>
<span class="sd">        Initial state vector (ket) or density matrix.</span>

<span class="sd">    times : *list* / *array*</span>
<span class="sd">        List of times for :math:`t`. Must be uniformly spaced.</span>

<span class="sd">    c_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        List of deterministic collapse operators.</span>

<span class="sd">    sc_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        List of stochastic collapse operators. Each stochastic collapse</span>
<span class="sd">        operator will give a deterministic and stochastic contribution</span>
<span class="sd">        to the equation of motion according to how the d1 and d2 functions</span>
<span class="sd">        are defined.</span>

<span class="sd">    e_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        Single operator or list of operators for which to evaluate</span>
<span class="sd">        expectation values.</span>

<span class="sd">    m_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        List of operators representing the measurement operators. The expected</span>
<span class="sd">        format is a nested list with one measurement operator for each</span>
<span class="sd">        stochastic increament, for each stochastic collapse operator.</span>

<span class="sd">    args : dict / list</span>
<span class="sd">        List of dictionary of additional problem-specific parameters.</span>
<span class="sd">        Implicit methods can adjust tolerance via args = {&#39;tol&#39;:value}</span>

<span class="sd">    ntraj : int</span>
<span class="sd">        Number of trajectors.</span>

<span class="sd">    nsubsteps : int</span>
<span class="sd">        Number of sub steps between each time-spep given in `times`.</span>

<span class="sd">    d1 : function</span>
<span class="sd">        Function for calculating the operator-valued coefficient to the</span>
<span class="sd">        deterministic increment dt.</span>

<span class="sd">    d2 : function</span>
<span class="sd">        Function for calculating the operator-valued coefficient to the</span>
<span class="sd">        stochastic increment(s) dW_n, where n is in [0, d2_len[.</span>

<span class="sd">    d2_len : int (default 1)</span>
<span class="sd">        The number of stochastic increments in the process.</span>

<span class="sd">    dW_factors : array</span>
<span class="sd">        Array of length d2_len, containing scaling factors for each</span>
<span class="sd">        measurement operator in m_ops.</span>

<span class="sd">    rhs : function</span>
<span class="sd">        Function for calculating the deterministic and stochastic contributions</span>
<span class="sd">        to the right-hand side of the stochastic differential equation. This</span>
<span class="sd">        only needs to be specified when implementing a custom SDE solver.</span>

<span class="sd">    generate_A_ops : function</span>
<span class="sd">        Function that generates a list of pre-computed operators or super-</span>
<span class="sd">        operators. These precomputed operators are used in some d1 and d2</span>
<span class="sd">        functions.</span>

<span class="sd">    generate_noise : function</span>
<span class="sd">        Function for generate an array of pre-computed noise signal.</span>

<span class="sd">    homogeneous : bool (True)</span>
<span class="sd">        Wheter or not the stochastic process is homogenous. Inhomogenous</span>
<span class="sd">        processes are only supported for poisson distributions.</span>

<span class="sd">    solver : string</span>
<span class="sd">        Name of the solver method to use for solving the stochastic</span>
<span class="sd">        equations. Valid values are: </span>
<span class="sd">        1/2 order algorithms: &#39;euler-maruyama&#39;, &#39;fast-euler-maruyama&#39;,</span>
<span class="sd">        &#39;pc-euler&#39; is a predictor-corrector method which is more </span>
<span class="sd">        stable than explicit methods,</span>
<span class="sd">        1 order algorithms: &#39;milstein&#39;, &#39;fast-milstein&#39;, &#39;platen&#39;,</span>
<span class="sd">        &#39;milstein-imp&#39; is semi-implicit Milstein method,</span>
<span class="sd">        3/2 order algorithms: &#39;taylor15&#39;, </span>
<span class="sd">        &#39;taylor15-imp&#39; is semi-implicit Taylor 1.5 method.</span>
<span class="sd">        Implicit methods can adjust tolerance via args = {&#39;tol&#39;:value},</span>
<span class="sd">        default is {&#39;tol&#39;:1e-6}</span>

<span class="sd">    method : string (&#39;homodyne&#39;, &#39;heterodyne&#39;, &#39;photocurrent&#39;)</span>
<span class="sd">        The name of the type of measurement process that give rise to the</span>
<span class="sd">        stochastic equation to solve. Specifying a method with this keyword</span>
<span class="sd">        argument is a short-hand notation for using pre-defined d1 and d2</span>
<span class="sd">        functions for the corresponding stochastic processes.</span>

<span class="sd">    distribution : string (&#39;normal&#39;, &#39;poission&#39;)</span>
<span class="sd">        The name of the distribution used for the stochastic increments.</span>

<span class="sd">    store_measurements : bool (default False)</span>
<span class="sd">        Whether or not to store the measurement results in the</span>
<span class="sd">        :class:`qutip.solver.SolverResult` instance returned by the solver.</span>

<span class="sd">    noise : array</span>
<span class="sd">        Vector specifying the noise.</span>

<span class="sd">    normalize : bool (default True)</span>
<span class="sd">        Whether or not to normalize the wave function during the evolution.</span>

<span class="sd">    options : :class:`qutip.solver.Options`</span>
<span class="sd">        Generic solver options.</span>

<span class="sd">    map_func: function</span>
<span class="sd">        A map function or managing the calls to single-trajactory solvers.</span>

<span class="sd">    map_kwargs: dictionary</span>
<span class="sd">        Optional keyword arguments to the map_func function function.</span>

<span class="sd">    progress_bar : :class:`qutip.ui.BaseProgressBar`</span>
<span class="sd">        Optional progress bar class instance.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">state0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">c_ops</span><span class="o">=</span><span class="p">[],</span> <span class="n">sc_ops</span><span class="o">=</span><span class="p">[],</span>
                 <span class="n">e_ops</span><span class="o">=</span><span class="p">[],</span> <span class="n">m_ops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ntraj</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nsubsteps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">d1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d2_len</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dW_factors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">generate_A_ops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">generate_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">homogeneous</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">solver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">distribution</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span>
                 <span class="n">store_measurement</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">map_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">map_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">options</span> <span class="o">=</span> <span class="n">Options</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">progress_bar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">progress_bar</span> <span class="o">=</span> <span class="n">TextProgressBar</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="n">H</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d1</span> <span class="o">=</span> <span class="n">d1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d2</span> <span class="o">=</span> <span class="n">d2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d2_len</span> <span class="o">=</span> <span class="n">d2_len</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dW_factors</span> <span class="o">=</span> <span class="n">dW_factors</span> <span class="k">if</span> <span class="n">dW_factors</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">d2_len</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state0</span> <span class="o">=</span> <span class="n">state0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_ops</span> <span class="o">=</span> <span class="n">c_ops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sc_ops</span> <span class="o">=</span> <span class="n">sc_ops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_ops</span> <span class="o">=</span> <span class="n">e_ops</span>

        <span class="k">if</span> <span class="n">m_ops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">m_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="n">c</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d2_len</span><span class="p">)]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sc_ops</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">m_ops</span> <span class="o">=</span> <span class="n">m_ops</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ntraj</span> <span class="o">=</span> <span class="n">ntraj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsubsteps</span> <span class="o">=</span> <span class="n">nsubsteps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="n">distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">homogeneous</span> <span class="o">=</span> <span class="n">homogeneous</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">rhs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">progress_bar</span> <span class="o">=</span> <span class="n">progress_bar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_measurement</span> <span class="o">=</span> <span class="n">store_measurement</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_states</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">store_states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">noise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span> <span class="o">=</span> <span class="n">normalize</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">generate_noise</span> <span class="o">=</span> <span class="n">generate_noise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_A_ops</span> <span class="o">=</span> <span class="n">generate_A_ops</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ntraj</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">map_func</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">map_func</span> <span class="o">=</span> <span class="n">map_func</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">map_func</span> <span class="o">=</span> <span class="n">serial_map</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">map_kwargs</span> <span class="o">=</span> <span class="n">map_kwargs</span> <span class="k">if</span> <span class="n">map_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span></div>


<div class="viewcode-block" id="ssesolve"><a class="viewcode-back" href="../../apidoc/functions.html#qutip.stochastic.ssesolve">[docs]</a><span class="k">def</span> <span class="nf">ssesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">sc_ops</span><span class="o">=</span><span class="p">[],</span> <span class="n">e_ops</span><span class="o">=</span><span class="p">[],</span> <span class="n">_safe_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve the stochastic Schrödinger equation. Dispatch to specific solvers</span>
<span class="sd">    depending on the value of the `solver` keyword argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    H : :class:`qutip.Qobj`</span>
<span class="sd">        System Hamiltonian.</span>

<span class="sd">    psi0 : :class:`qutip.Qobj`</span>
<span class="sd">        Initial state vector (ket).</span>

<span class="sd">    times : *list* / *array*</span>
<span class="sd">        List of times for :math:`t`. Must be uniformly spaced.</span>

<span class="sd">    sc_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        List of stochastic collapse operators. Each stochastic collapse</span>
<span class="sd">        operator will give a deterministic and stochastic contribution</span>
<span class="sd">        to the equation of motion according to how the d1 and d2 functions</span>
<span class="sd">        are defined.</span>

<span class="sd">    e_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        Single operator or list of operators for which to evaluate</span>
<span class="sd">        expectation values.</span>

<span class="sd">    kwargs : *dictionary*</span>
<span class="sd">        Optional keyword arguments. See</span>
<span class="sd">        :class:`qutip.stochastic.StochasticSolverOptions`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    output: :class:`qutip.solver.SolverResult`</span>
<span class="sd">        An instance of the class :class:`qutip.solver.SolverResult`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e_ops</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">e_ops_dict</span> <span class="o">=</span> <span class="n">e_ops</span>
        <span class="n">e_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">e_ops</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">e_ops_dict</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">_safe_mode</span><span class="p">:</span>
        <span class="n">_solver_safety_check</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">sc_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">)</span>
    
    <span class="n">sso</span> <span class="o">=</span> <span class="n">StochasticSolverOptions</span><span class="p">(</span><span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">state0</span><span class="o">=</span><span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span>
                                  <span class="n">sc_ops</span><span class="o">=</span><span class="n">sc_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span> <span class="o">=</span> <span class="n">_generate_psi_A_ops</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">d1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">d2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;homodyne&#39;</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d1</span> <span class="o">=</span> <span class="n">d1_psi_homodyne</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2</span> <span class="o">=</span> <span class="n">d2_psi_homodyne</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="s1">&#39;normal&#39;</span>
            <span class="k">if</span> <span class="s2">&quot;dW_factors&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">dW_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;m_ops&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="n">c</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">()]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;heterodyne&#39;</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d1</span> <span class="o">=</span> <span class="n">d1_psi_heterodyne</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2</span> <span class="o">=</span> <span class="n">d2_psi_heterodyne</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="s1">&#39;normal&#39;</span>
            <span class="k">if</span> <span class="s2">&quot;dW_factors&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">dW_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
            <span class="k">if</span> <span class="s2">&quot;m_ops&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">c</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">()),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">())]</span>
                             <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;photocurrent&#39;</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d1</span> <span class="o">=</span> <span class="n">d1_psi_photocurrent</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2</span> <span class="o">=</span> <span class="n">d2_psi_photocurrent</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="s1">&#39;poisson&#39;</span>

            <span class="k">if</span> <span class="s2">&quot;dW_factors&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">dW_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;m_ops&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unrecognized method &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;poisson&#39;</span><span class="p">:</span>
        <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;euler-maruyama&#39;</span> <span class="ow">or</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_psi_euler_maruyama</span>

    <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;platen&#39;</span><span class="p">:</span>
        <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_psi_platen</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unrecognized solver &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">_ssesolve_generic</span><span class="p">(</span><span class="n">sso</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">progress_bar</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">e_ops_dict</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span> <span class="n">res</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                      <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">e_ops_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())}</span>

    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="smesolve"><a class="viewcode-back" href="../../apidoc/functions.html#qutip.stochastic.smesolve">[docs]</a><span class="k">def</span> <span class="nf">smesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">rho0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="o">=</span><span class="p">[],</span> <span class="n">sc_ops</span><span class="o">=</span><span class="p">[],</span> <span class="n">e_ops</span><span class="o">=</span><span class="p">[],</span> 
            <span class="n">_safe_mode</span><span class="o">=</span><span class="kc">True</span> <span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve stochastic master equation. Dispatch to specific solvers</span>
<span class="sd">    depending on the value of the `solver` keyword argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    H : :class:`qutip.Qobj`</span>
<span class="sd">        System Hamiltonian.</span>

<span class="sd">    rho0 : :class:`qutip.Qobj`</span>
<span class="sd">        Initial density matrix or state vector (ket).</span>

<span class="sd">    times : *list* / *array*</span>
<span class="sd">        List of times for :math:`t`. Must be uniformly spaced.</span>

<span class="sd">    c_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        Deterministic collapse operator which will contribute with a standard</span>
<span class="sd">        Lindblad type of dissipation.</span>

<span class="sd">    sc_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        List of stochastic collapse operators. Each stochastic collapse</span>
<span class="sd">        operator will give a deterministic and stochastic contribution</span>
<span class="sd">        to the eqaution of motion according to how the d1 and d2 functions</span>
<span class="sd">        are defined.</span>

<span class="sd">    e_ops : list of :class:`qutip.Qobj` / callback function single</span>
<span class="sd">        single operator or list of operators for which to evaluate</span>
<span class="sd">        expectation values.</span>

<span class="sd">    kwargs : *dictionary*</span>
<span class="sd">        Optional keyword arguments. See</span>
<span class="sd">        :class:`qutip.stochastic.StochasticSolverOptions`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    output: :class:`qutip.solver.SolverResult`</span>

<span class="sd">        An instance of the class :class:`qutip.solver.SolverResult`.</span>

<span class="sd">    TODO</span>
<span class="sd">    ----</span>
<span class="sd">        Add checks for commuting jump operators in Milstein method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">isket</span><span class="p">(</span><span class="n">rho0</span><span class="p">):</span>
        <span class="n">rho0</span> <span class="o">=</span> <span class="n">ket2dm</span><span class="p">(</span><span class="n">rho0</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e_ops</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">e_ops_dict</span> <span class="o">=</span> <span class="n">e_ops</span>
        <span class="n">e_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">e_ops</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">e_ops_dict</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">_safe_mode</span><span class="p">:</span>
        <span class="n">_solver_safety_check</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">rho0</span><span class="p">,</span> <span class="n">c_ops</span><span class="o">+</span><span class="n">sc_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">)</span>

    <span class="n">sso</span> <span class="o">=</span> <span class="n">StochasticSolverOptions</span><span class="p">(</span><span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">state0</span><span class="o">=</span><span class="n">rho0</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="o">=</span><span class="n">c_ops</span><span class="p">,</span>
                                  <span class="n">sc_ops</span><span class="o">=</span><span class="n">sc_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">d1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">d2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;homodyne&#39;</span> <span class="ow">or</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d1</span> <span class="o">=</span> <span class="n">d1_rho_homodyne</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2</span> <span class="o">=</span> <span class="n">d2_rho_homodyne</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="s1">&#39;normal&#39;</span>
            <span class="k">if</span> <span class="s2">&quot;dW_factors&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">dW_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="p">)])</span>
            <span class="k">if</span> <span class="s2">&quot;m_ops&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="n">c</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">()]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;heterodyne&#39;</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d1</span> <span class="o">=</span> <span class="n">d1_rho_heterodyne</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2</span> <span class="o">=</span> <span class="n">d2_rho_heterodyne</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="s1">&#39;normal&#39;</span>
            <span class="k">if</span> <span class="s2">&quot;dW_factors&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">dW_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
            <span class="k">if</span> <span class="s2">&quot;m_ops&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">c</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">()),</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">())]</span>
                             <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;photocurrent&#39;</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d1</span> <span class="o">=</span> <span class="n">cy_d1_rho_photocurrent</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2</span> <span class="o">=</span> <span class="n">cy_d2_rho_photocurrent</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="s1">&#39;poisson&#39;</span>

            <span class="k">if</span> <span class="s2">&quot;dW_factors&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">dW_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;m_ops&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unrecognized method &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;poisson&#39;</span><span class="p">:</span>
        <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span> <span class="o">=</span> <span class="n">_generate_rho_A_ops</span>

    <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;euler-maruyama&#39;</span> <span class="ow">or</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_euler_maruyama</span>

        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;milstein&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;homodyne&#39;</span> <span class="ow">or</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_milstein_homodyne_single</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_milstein_homodyne</span>

            <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;heterodyne&#39;</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_milstein_homodyne</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">):</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">sc</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">sc</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;fast-euler-maruyama&#39;</span> <span class="ow">and</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;homodyne&#39;</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_euler_homodyne_fast</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span> <span class="o">=</span> <span class="n">_generate_A_ops_Euler</span>

        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;fast-milstein&#39;</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span> <span class="o">=</span> <span class="n">_generate_A_ops_Milstein</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">generate_noise</span> <span class="o">=</span> <span class="n">_generate_noise_Milstein</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;homodyne&#39;</span> <span class="ow">or</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_milstein_homodyne_single_fast</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_milstein_homodyne_two_fast</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_milstein_homodyne_fast</span>

            <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;heterodyne&#39;</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">):</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">sc</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">sc</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_milstein_homodyne_two_fast</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_milstein_homodyne_fast</span>
                 
        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;taylor15&#39;</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span> <span class="o">=</span> <span class="n">_generate_A_ops_simple</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">generate_noise</span> <span class="o">=</span> <span class="n">_generate_noise_Taylor_15</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;homodyne&#39;</span> <span class="ow">or</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_taylor_15_one</span>
                <span class="c1">#elif len(sc_ops) == 2:</span>
                <span class="c1">#    sso.rhs = _rhs_rho_taylor_15_two</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Only one stochastic operator is supported&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Only homodyne is available&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;milstein-imp&#39;</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span> <span class="o">=</span> <span class="n">_generate_A_ops_implicit</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">generate_noise</span> <span class="o">=</span> <span class="n">_generate_noise_Milstein</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">args</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;tol&#39;</span><span class="p">:</span><span class="mf">1e-6</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;homodyne&#39;</span> <span class="ow">or</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_milstein_implicit</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Only one stochastic operator is supported&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Only homodyne is available&quot;</span><span class="p">)</span> 

        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;taylor15-imp&#39;</span><span class="p">:</span>  
            <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span> <span class="o">=</span> <span class="n">_generate_A_ops_implicit</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">generate_noise</span> <span class="o">=</span> <span class="n">_generate_noise_Taylor_15</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">args</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;tol&#39;</span><span class="p">:</span><span class="mf">1e-6</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;homodyne&#39;</span> <span class="ow">or</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_taylor_15_implicit</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Only one stochastic operator is supported&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Only homodyne is available&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;pc-euler&#39;</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span> <span class="o">=</span> <span class="n">_generate_A_ops_Milstein</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">generate_noise</span> <span class="o">=</span> <span class="n">_generate_noise_Milstein</span> <span class="c1"># could also work without this</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;homodyne&#39;</span> <span class="ow">or</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_pred_corr_homodyne_single</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Only one stochastic operator is supported&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Only homodyne is available&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unrecognized solver &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">_smesolve_generic</span><span class="p">(</span><span class="n">sso</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">progress_bar</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">e_ops_dict</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span> <span class="n">res</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                      <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">e_ops_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())}</span>

    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="ssepdpsolve"><a class="viewcode-back" href="../../apidoc/functions.html#qutip.stochastic.ssepdpsolve">[docs]</a><span class="k">def</span> <span class="nf">ssepdpsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A stochastic (piecewse deterministic process) PDP solver for wavefunction</span>
<span class="sd">    evolution. For most purposes, use :func:`qutip.mcsolve` instead for quantum</span>
<span class="sd">    trajectory simulations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    H : :class:`qutip.Qobj`</span>
<span class="sd">        System Hamiltonian.</span>

<span class="sd">    psi0 : :class:`qutip.Qobj`</span>
<span class="sd">        Initial state vector (ket).</span>

<span class="sd">    times : *list* / *array*</span>
<span class="sd">        List of times for :math:`t`. Must be uniformly spaced.</span>

<span class="sd">    c_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        Deterministic collapse operator which will contribute with a standard</span>
<span class="sd">        Lindblad type of dissipation.</span>

<span class="sd">    e_ops : list of :class:`qutip.Qobj` / callback function single</span>
<span class="sd">        single operator or list of operators for which to evaluate</span>
<span class="sd">        expectation values.</span>

<span class="sd">    kwargs : *dictionary*</span>
<span class="sd">        Optional keyword arguments. See</span>
<span class="sd">        :class:`qutip.stochastic.StochasticSolverOptions`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    output: :class:`qutip.solver.SolverResult`</span>

<span class="sd">        An instance of the class :class:`qutip.solver.SolverResult`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e_ops</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">e_ops_dict</span> <span class="o">=</span> <span class="n">e_ops</span>
        <span class="n">e_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">e_ops</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">e_ops_dict</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">sso</span> <span class="o">=</span> <span class="n">StochasticSolverOptions</span><span class="p">(</span><span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">state0</span><span class="o">=</span><span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="o">=</span><span class="n">c_ops</span><span class="p">,</span>
                                  <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">_ssepdpsolve_generic</span><span class="p">(</span><span class="n">sso</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">progress_bar</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">e_ops_dict</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span> <span class="n">res</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                      <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">e_ops_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())}</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="smepdpsolve"><a class="viewcode-back" href="../../apidoc/functions.html#qutip.stochastic.smepdpsolve">[docs]</a><span class="k">def</span> <span class="nf">smepdpsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">rho0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A stochastic (piecewse deterministic process) PDP solver for density matrix</span>
<span class="sd">    evolution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    H : :class:`qutip.Qobj`</span>
<span class="sd">        System Hamiltonian.</span>

<span class="sd">    rho0 : :class:`qutip.Qobj`</span>
<span class="sd">        Initial density matrix.</span>

<span class="sd">    times : *list* / *array*</span>
<span class="sd">        List of times for :math:`t`. Must be uniformly spaced.</span>

<span class="sd">    c_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        Deterministic collapse operator which will contribute with a standard</span>
<span class="sd">        Lindblad type of dissipation.</span>

<span class="sd">    sc_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        List of stochastic collapse operators. Each stochastic collapse</span>
<span class="sd">        operator will give a deterministic and stochastic contribution</span>
<span class="sd">        to the eqaution of motion according to how the d1 and d2 functions</span>
<span class="sd">        are defined.</span>

<span class="sd">    e_ops : list of :class:`qutip.Qobj` / callback function single</span>
<span class="sd">        single operator or list of operators for which to evaluate</span>
<span class="sd">        expectation values.</span>

<span class="sd">    kwargs : *dictionary*</span>
<span class="sd">        Optional keyword arguments. See</span>
<span class="sd">        :class:`qutip.stochastic.StochasticSolverOptions`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    output: :class:`qutip.solver.SolverResult`</span>

<span class="sd">        An instance of the class :class:`qutip.solver.SolverResult`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e_ops</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">e_ops_dict</span> <span class="o">=</span> <span class="n">e_ops</span>
        <span class="n">e_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">e_ops</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">e_ops_dict</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">sso</span> <span class="o">=</span> <span class="n">StochasticSolverOptions</span><span class="p">(</span><span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">state0</span><span class="o">=</span><span class="n">rho0</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="o">=</span><span class="n">c_ops</span><span class="p">,</span>
                                  <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">_smepdpsolve_generic</span><span class="p">(</span><span class="n">sso</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">progress_bar</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">e_ops_dict</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span> <span class="n">res</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                      <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">e_ops_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())}</span>
    <span class="k">return</span> <span class="n">res</span></div>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Generic parameterized stochastic Schrodinger equation solver</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">_ssesolve_generic</span><span class="p">(</span><span class="n">sso</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal function for carrying out a sse integration. Used by ssesolve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>

    <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
    <span class="n">sso</span><span class="o">.</span><span class="n">N_substeps</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">nsubsteps</span>
    <span class="n">sso</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_substeps</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">Result</span><span class="p">()</span>
    <span class="n">data</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="s2">&quot;ssesolve&quot;</span>
    <span class="n">data</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">data</span><span class="o">.</span><span class="n">measurement</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># pre-compute collapse operator combinations that are commonly needed</span>
    <span class="c1"># when evaluating the RHS of stochastic Schrodinger equations</span>
    <span class="n">sso</span><span class="o">.</span><span class="n">A_ops</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>

    <span class="n">map_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;progress_bar&#39;</span><span class="p">:</span> <span class="n">progress_bar</span><span class="p">}</span>
    <span class="n">map_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">map_kwargs</span><span class="p">)</span>

    <span class="n">task</span> <span class="o">=</span> <span class="n">_ssesolve_single_trajectory</span>
    <span class="n">task_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">sso</span><span class="p">,)</span>
    <span class="n">task_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">results</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">map_func</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span><span class="p">)),</span>
                           <span class="n">task_args</span><span class="p">,</span> <span class="n">task_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">map_kwargs</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
        <span class="n">states_list</span><span class="p">,</span> <span class="n">dW</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">expect</span><span class="p">,</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">result</span>
        <span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">states_list</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dW</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">measurement</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">+=</span> <span class="n">expect</span>
        <span class="n">data</span><span class="o">.</span><span class="n">ss</span> <span class="o">+=</span> <span class="n">ss</span>

    <span class="c1"># average density matrices</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">average_states</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
        <span class="n">data</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">([</span><span class="n">ket2dm</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">mm</span><span class="p">][</span><span class="n">n</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">mm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">)])</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
                       <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">times</span><span class="p">))]</span>

    <span class="c1"># average</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">/</span> <span class="n">nt</span>

    <span class="c1"># standard error</span>
    <span class="k">if</span> <span class="n">nt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">se</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ss</span> <span class="o">-</span> <span class="n">nt</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">nt</span> <span class="o">*</span> <span class="p">(</span><span class="n">nt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">se</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># convert complex data to real if hermitian</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:])</span>
                   <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">isherm</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:]</span>
                   <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_ssesolve_single_trajectory</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">sso</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal function. See ssesolve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">dt</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span>
    <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">d1</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">d2</span>
    <span class="n">d2_len</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span>
    <span class="n">e_ops</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span>
    <span class="n">H_data</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">data</span>
    <span class="n">A_ops</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">A_ops</span>

    <span class="n">expect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="n">psi_t</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">state0</span><span class="o">.</span><span class="n">full</span><span class="p">()</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">state0</span><span class="o">.</span><span class="n">dims</span>

    <span class="c1"># reseed the random number generator so that forked</span>
    <span class="c1"># processes do not get the same sequence of random numbers</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4294967295</span> <span class="o">//</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;normal&#39;</span><span class="p">:</span>
                <span class="n">dW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="o">*</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_substeps</span><span class="p">,</span>
                                    <span class="n">d2_len</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unsupported increment distribution for &#39;</span> <span class="o">+</span>
                                <span class="s1">&#39;homogeneous process.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">!=</span> <span class="s1">&#39;poisson&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unsupported increment distribution for &#39;</span> <span class="o">+</span>
                                <span class="s1">&#39;inhomogeneous process.&#39;</span><span class="p">)</span>

            <span class="n">dW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">A_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_substeps</span><span class="p">,</span> <span class="n">d2_len</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dW</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

    <span class="n">states_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">measurements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span><span class="p">),</span> <span class="n">d2_len</span><span class="p">),</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">e_ops</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e_idx</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">e_ops</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                      <span class="n">e</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span>
                                      <span class="n">e</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">expect</span><span class="p">[</span><span class="n">e_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s</span>
                <span class="n">ss</span><span class="p">[</span><span class="n">e_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">states_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Qobj</span><span class="p">(</span><span class="n">psi_t</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">N_substeps</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">noise</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a_idx</span><span class="p">,</span> <span class="n">A</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A_ops</span><span class="p">):</span>
                    <span class="c1"># dw_expect = norm(spmv(A[0], psi_t)) ** 2 * dt</span>
                    <span class="n">dw_expect</span> <span class="o">=</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                  <span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span>
                                                  <span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
                    <span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="n">dw_expect</span><span class="p">,</span>
                                                               <span class="n">d2_len</span><span class="p">)</span>

            <span class="n">psi_t</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span><span class="p">(</span><span class="n">H_data</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">j</span><span class="p">,</span>
                            <span class="n">A_ops</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dW</span><span class="p">[:,</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

            <span class="c1"># optionally renormalize the wave function</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">normalize</span><span class="p">:</span>
                <span class="n">psi_t</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">psi_t</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">store_measurement</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">m_idx</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">dW_idx</span><span class="p">,</span> <span class="n">dW_factor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">dW_factors</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="n">dW_idx</span><span class="p">]:</span>
                        <span class="n">m_data</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">dW_idx</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
                        <span class="n">m_expt</span> <span class="o">=</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span><span class="n">m_data</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                   <span class="n">m_data</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span>
                                                   <span class="n">m_data</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span>
                                                   <span class="n">psi_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">m_expt</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">mm</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_expt</span> <span class="o">+</span> <span class="n">dW_factor</span> <span class="o">*</span>
                          <span class="n">dW</span><span class="p">[</span><span class="n">m_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="n">dW_idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span>
                          <span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_substeps</span><span class="p">))</span>
                    <span class="n">measurements</span><span class="p">[</span><span class="n">t_idx</span><span class="p">,</span> <span class="n">m_idx</span><span class="p">,</span> <span class="n">dW_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">mm</span>

    <span class="k">if</span> <span class="n">d2_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">measurements</span> <span class="o">=</span> <span class="n">measurements</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">states_list</span><span class="p">,</span> <span class="n">dW</span><span class="p">,</span> <span class="n">measurements</span><span class="p">,</span> <span class="n">expect</span><span class="p">,</span> <span class="n">ss</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Generic parameterized stochastic master equation solver</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">_smesolve_generic</span><span class="p">(</span><span class="n">sso</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal function. See smesolve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>

    <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
    <span class="n">sso</span><span class="o">.</span><span class="n">N_substeps</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">nsubsteps</span>
    <span class="n">sso</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_substeps</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">Result</span><span class="p">()</span>
    <span class="n">data</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="s2">&quot;smesolve&quot;</span>
    <span class="n">data</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">data</span><span class="o">.</span><span class="n">measurement</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Liouvillian for the deterministic part.</span>
    <span class="c1"># needs to be modified for TD systems</span>
    <span class="n">sso</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">liouvillian</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">H</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">c_ops</span><span class="p">)</span>

    <span class="c1"># pre-compute suporoperator operator combinations that are commonly needed</span>
    <span class="c1"># when evaluating the RHS of stochastic master equations</span>
    <span class="n">sso</span><span class="o">.</span><span class="n">A_ops</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>

    <span class="c1"># use .data instead of Qobj ?</span>
    <span class="n">sso</span><span class="o">.</span><span class="n">s_e_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">spre</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span><span class="p">:</span>
        <span class="n">sso</span><span class="o">.</span><span class="n">s_m_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="n">spre</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">if</span> <span class="n">m</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">m_op</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">m_op</span> <span class="ow">in</span> <span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sso</span><span class="o">.</span><span class="n">s_m_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="n">spre</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span><span class="p">)]</span>
                       <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span><span class="p">]</span>

    <span class="n">map_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;progress_bar&#39;</span><span class="p">:</span> <span class="n">progress_bar</span><span class="p">}</span>
    <span class="n">map_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">map_kwargs</span><span class="p">)</span>

    <span class="n">task</span> <span class="o">=</span> <span class="n">_smesolve_single_trajectory</span>
    <span class="n">task_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">sso</span><span class="p">,)</span>
    <span class="n">task_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">results</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">map_func</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span><span class="p">)),</span>
                           <span class="n">task_args</span><span class="p">,</span> <span class="n">task_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">map_kwargs</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
        <span class="n">states_list</span><span class="p">,</span> <span class="n">dW</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">expect</span><span class="p">,</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">result</span>
        <span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">states_list</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dW</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">measurement</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">+=</span> <span class="n">expect</span>
        <span class="n">data</span><span class="o">.</span><span class="n">ss</span> <span class="o">+=</span> <span class="n">ss</span>

    <span class="c1"># average density matrices</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">average_states</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
        <span class="n">data</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">mm</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">mm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">)])</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
                       <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">times</span><span class="p">))]</span>

    <span class="c1"># average</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">/</span> <span class="n">nt</span>

    <span class="c1"># standard error</span>
    <span class="k">if</span> <span class="n">nt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">se</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ss</span> <span class="o">-</span> <span class="n">nt</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">nt</span> <span class="o">*</span> <span class="p">(</span><span class="n">nt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">se</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># convert complex data to real if hermitian</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:])</span>
                   <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">isherm</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:]</span>
                   <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_smesolve_single_trajectory</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">sso</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal function. See smesolve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">dt</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span>
    <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">d1</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">d2</span>
    <span class="n">d2_len</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span>
    <span class="n">L_data</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">data</span>
    <span class="n">N_substeps</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_substeps</span>
    <span class="n">N_store</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span>
    <span class="n">A_ops</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">A_ops</span>

    <span class="n">rho_t</span> <span class="o">=</span> <span class="n">mat2vec</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">state0</span><span class="o">.</span><span class="n">full</span><span class="p">())</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">state0</span><span class="o">.</span><span class="n">dims</span>

    <span class="n">expect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="c1"># reseed the random number generator so that forked</span>
    <span class="c1"># processes do not get the same sequence of random numbers</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4294967295</span> <span class="o">//</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">generate_noise</span><span class="p">:</span>
            <span class="n">dW</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">generate_noise</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A_ops</span><span class="p">),</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span>
                                    <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;normal&#39;</span><span class="p">:</span>
                <span class="n">dW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A_ops</span><span class="p">),</span> <span class="n">N_store</span><span class="p">,</span>
                                                   <span class="n">N_substeps</span><span class="p">,</span> <span class="n">d2_len</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unsupported increment distribution for &#39;</span> <span class="o">+</span>
                                <span class="s1">&#39;homogeneous process.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">!=</span> <span class="s1">&#39;poisson&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unsupported increment distribution for &#39;</span> <span class="o">+</span>
                                <span class="s1">&#39;inhomogeneous process.&#39;</span><span class="p">)</span>

            <span class="n">dW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">A_ops</span><span class="p">),</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span> <span class="n">d2_len</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dW</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

    <span class="n">states_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">measurements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">s_m_ops</span><span class="p">),</span> <span class="n">d2_len</span><span class="p">),</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">s_e_ops</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e_idx</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">s_e_ops</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">expect</span><span class="p">[</span><span class="n">e_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s</span>
                <span class="n">ss</span><span class="p">[</span><span class="n">e_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">store_states</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">sso</span><span class="o">.</span><span class="n">s_e_ops</span><span class="p">:</span>
            <span class="n">states_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Qobj</span><span class="p">(</span><span class="n">vec2mat</span><span class="p">(</span><span class="n">rho_t</span><span class="p">),</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">))</span>

        <span class="n">rho_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">rho_t</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_substeps</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">noise</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a_idx</span><span class="p">,</span> <span class="n">A</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A_ops</span><span class="p">):</span>
                    <span class="n">dw_expect</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
                    <span class="k">if</span> <span class="n">dw_expect</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="n">dw_expect</span><span class="p">,</span>
                                                                   <span class="n">d2_len</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">d2_len</span><span class="p">)</span>

            <span class="n">rho_t</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span><span class="p">(</span><span class="n">L_data</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">j</span><span class="p">,</span>
                            <span class="n">A_ops</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dW</span><span class="p">[:,</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">store_measurement</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">m_idx</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">s_m_ops</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">dW_idx</span><span class="p">,</span> <span class="n">dW_factor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">dW_factors</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="n">dW_idx</span><span class="p">]:</span>
                        <span class="n">m_expt</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">dW_idx</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rho_prev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">m_expt</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">measurements</span><span class="p">[</span><span class="n">t_idx</span><span class="p">,</span> <span class="n">m_idx</span><span class="p">,</span> <span class="n">dW_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_expt</span> <span class="o">+</span> <span class="n">dW_factor</span> <span class="o">*</span> \
                        <span class="n">dW</span><span class="p">[</span><span class="n">m_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="n">dW_idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">N_substeps</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">d2_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">measurements</span> <span class="o">=</span> <span class="n">measurements</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">states_list</span><span class="p">,</span> <span class="n">dW</span><span class="p">,</span> <span class="n">measurements</span><span class="p">,</span> <span class="n">expect</span><span class="p">,</span> <span class="n">ss</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Generic parameterized stochastic SE PDP solver</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">_ssepdpsolve_generic</span><span class="p">(</span><span class="n">sso</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For internal use. See ssepdpsolve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>

    <span class="n">N_store</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
    <span class="n">N_substeps</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">nsubsteps</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">N_substeps</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">Result</span><span class="p">()</span>
    <span class="n">data</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="s2">&quot;sepdpsolve&quot;</span>
    <span class="n">data</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">tlist</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">jump_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">data</span><span class="o">.</span><span class="n">jump_op_idx</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># effective hamiltonian for deterministic part</span>
    <span class="n">Heff</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">H</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sso</span><span class="o">.</span><span class="n">c_ops</span><span class="p">:</span>
        <span class="n">Heff</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">j</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">c</span>

    <span class="n">progress_bar</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span><span class="p">):</span>
        <span class="n">progress_bar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">psi_t</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">state0</span><span class="o">.</span><span class="n">full</span><span class="p">()</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="n">states_list</span><span class="p">,</span> <span class="n">jump_times</span><span class="p">,</span> <span class="n">jump_op_idx</span> <span class="o">=</span> \
            <span class="n">_ssepdpsolve_single_trajectory</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Heff</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">,</span>
                                           <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span>
                                           <span class="n">psi_t</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">state0</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
                                           <span class="n">sso</span><span class="o">.</span><span class="n">c_ops</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">states_list</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">jump_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jump_times</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">jump_op_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jump_op_idx</span><span class="p">)</span>

    <span class="n">progress_bar</span><span class="o">.</span><span class="n">finished</span><span class="p">()</span>

    <span class="c1"># average density matrices</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">average_states</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
        <span class="n">data</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">)])</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
                       <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">times</span><span class="p">))]</span>

    <span class="c1"># average</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">/</span> <span class="n">nt</span>

    <span class="c1"># standard error</span>
    <span class="k">if</span> <span class="n">nt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">se</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ss</span> <span class="o">-</span> <span class="n">nt</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">nt</span> <span class="o">*</span> <span class="p">(</span><span class="n">nt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">se</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># convert complex data to real if hermitian</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:])</span>
                   <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">isherm</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:]</span>
                   <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_ssepdpsolve_single_trajectory</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Heff</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span>
                                   <span class="n">psi_t</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal function. See ssepdpsolve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">states_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">phi_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">psi_t</span><span class="p">)</span>

    <span class="n">prng</span> <span class="o">=</span> <span class="n">RandomState</span><span class="p">()</span>  <span class="c1"># todo: seed it</span>
    <span class="n">r_jump</span><span class="p">,</span> <span class="n">r_op</span> <span class="o">=</span> <span class="n">prng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">jump_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">jump_op_idx</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">e_ops</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e_idx</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">e_ops</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">e_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s</span>
                <span class="n">data</span><span class="o">.</span><span class="n">ss</span><span class="p">[</span><span class="n">e_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">states_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Qobj</span><span class="p">(</span><span class="n">psi_t</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_substeps</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">norm</span><span class="p">(</span><span class="n">phi_t</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">r_jump</span><span class="p">:</span>
                <span class="c1"># jump occurs</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">psi_t</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">c_ops</span><span class="p">])</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">p</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">r_op</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># apply jump</span>
                <span class="n">psi_t</span> <span class="o">=</span> <span class="n">c_ops</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">psi_t</span>
                <span class="n">psi_t</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">psi_t</span><span class="p">)</span>
                <span class="n">phi_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">psi_t</span><span class="p">)</span>

                <span class="c1"># store info about jump</span>
                <span class="n">jump_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">jump_op_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

                <span class="c1"># get new random numbers for next jump</span>
                <span class="n">r_jump</span><span class="p">,</span> <span class="n">r_op</span> <span class="o">=</span> <span class="n">prng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

            <span class="c1"># deterministic evolution wihtout correction for norm decay</span>
            <span class="n">dphi_t</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Heff</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">phi_t</span><span class="p">)</span>

            <span class="c1"># deterministic evolution with correction for norm decay</span>
            <span class="n">dpsi_t</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Heff</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">psi_t</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">psi_t</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">c_ops</span><span class="p">])</span>
            <span class="n">dpsi_t</span> <span class="o">+=</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">A</span> <span class="o">*</span> <span class="n">psi_t</span>

            <span class="c1"># increment wavefunctions</span>
            <span class="n">phi_t</span> <span class="o">+=</span> <span class="n">dphi_t</span>
            <span class="n">psi_t</span> <span class="o">+=</span> <span class="n">dpsi_t</span>

            <span class="c1"># ensure that normalized wavefunction remains normalized</span>
            <span class="c1"># this allows larger time step than otherwise would be possible</span>
            <span class="n">psi_t</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">psi_t</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">states_list</span><span class="p">,</span> <span class="n">jump_times</span><span class="p">,</span> <span class="n">jump_op_idx</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Generic parameterized stochastic ME PDP solver</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">_smepdpsolve_generic</span><span class="p">(</span><span class="n">sso</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For internal use. See smepdpsolve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>

    <span class="n">N_store</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
    <span class="n">N_substeps</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">nsubsteps</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">N_substeps</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">Result</span><span class="p">()</span>
    <span class="n">data</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="s2">&quot;smepdpsolve&quot;</span>
    <span class="n">data</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">jump_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">data</span><span class="o">.</span><span class="n">jump_op_idx</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Liouvillian for the deterministic part.</span>
    <span class="c1"># needs to be modified for TD systems</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">liouvillian</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">H</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">c_ops</span><span class="p">)</span>

    <span class="n">progress_bar</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span><span class="p">):</span>
        <span class="n">progress_bar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">rho_t</span> <span class="o">=</span> <span class="n">mat2vec</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">rho0</span><span class="o">.</span><span class="n">full</span><span class="p">())</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="n">states_list</span><span class="p">,</span> <span class="n">jump_times</span><span class="p">,</span> <span class="n">jump_op_idx</span> <span class="o">=</span> \
            <span class="n">_smepdpsolve_single_trajectory</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">,</span>
                                           <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span>
                                           <span class="n">rho_t</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">rho0</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
                                           <span class="n">sso</span><span class="o">.</span><span class="n">c_ops</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">states_list</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">jump_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jump_times</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">jump_op_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jump_op_idx</span><span class="p">)</span>

    <span class="n">progress_bar</span><span class="o">.</span><span class="n">finished</span><span class="p">()</span>

    <span class="c1"># average density matrices</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">average_states</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
        <span class="n">data</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">)])</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
                       <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">times</span><span class="p">))]</span>

    <span class="c1"># average</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">/</span> <span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span>

    <span class="c1"># standard error</span>
    <span class="k">if</span> <span class="n">nt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">se</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ss</span> <span class="o">-</span> <span class="n">nt</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">nt</span> <span class="o">*</span> <span class="p">(</span><span class="n">nt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">se</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_smepdpsolve_single_trajectory</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span>
                                   <span class="n">rho_t</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal function. See smepdpsolve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">states_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">rho_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">rho_t</span><span class="p">)</span>
    <span class="n">sigma_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">rho_t</span><span class="p">)</span>

    <span class="n">prng</span> <span class="o">=</span> <span class="n">RandomState</span><span class="p">()</span>  <span class="c1"># todo: seed it</span>
    <span class="n">r_jump</span><span class="p">,</span> <span class="n">r_op</span> <span class="o">=</span> <span class="n">prng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">jump_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">jump_op_idx</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">e_ops</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e_idx</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">e_ops</span><span class="p">):</span>
                <span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">e_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">expect_rho_vec</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">states_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Qobj</span><span class="p">(</span><span class="n">vec2mat</span><span class="p">(</span><span class="n">rho_t</span><span class="p">),</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_substeps</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">sigma_t</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">r_jump</span><span class="p">:</span>
                <span class="c1"># jump occurs</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">expect</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">c_ops</span><span class="p">])</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">p</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">r_op</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># apply jump</span>
                <span class="n">rho_t</span> <span class="o">=</span> <span class="n">c_ops</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">rho_t</span> <span class="o">*</span> <span class="n">c_ops</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
                <span class="n">rho_t</span> <span class="o">/=</span> <span class="n">expect</span><span class="p">(</span><span class="n">c_ops</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">c_ops</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">)</span>
                <span class="n">sigma_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">rho_t</span><span class="p">)</span>

                <span class="c1"># store info about jump</span>
                <span class="n">jump_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">jump_op_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

                <span class="c1"># get new random numbers for next jump</span>
                <span class="n">r_jump</span><span class="p">,</span> <span class="n">r_op</span> <span class="o">=</span> <span class="n">prng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

            <span class="c1"># deterministic evolution wihtout correction for norm decay</span>
            <span class="n">dsigma_t</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sigma_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>

            <span class="c1"># deterministic evolution with correction for norm decay</span>
            <span class="n">drho_t</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>

            <span class="n">rho_t</span> <span class="o">+=</span> <span class="n">drho_t</span>

            <span class="c1"># increment density matrices</span>
            <span class="n">sigma_t</span> <span class="o">+=</span> <span class="n">dsigma_t</span>
            <span class="n">rho_t</span> <span class="o">+=</span> <span class="n">drho_t</span>

    <span class="k">return</span> <span class="n">states_list</span><span class="p">,</span> <span class="n">jump_times</span><span class="p">,</span> <span class="n">jump_op_idx</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Helper-functions for stochastic DE</span>
<span class="c1">#</span>
<span class="c1"># d1 = deterministic part of the contribution to the DE RHS function, to be</span>
<span class="c1">#      multiplied by the increament dt</span>
<span class="c1">#</span>
<span class="c1"># d1 = stochastic part of the contribution to the DE RHS function, to be</span>
<span class="c1">#      multiplied by the increament dW</span>
<span class="c1">#</span>


<span class="c1">#</span>
<span class="c1"># For SSE</span>
<span class="c1">#</span>

<span class="c1"># Function sigurature:</span>
<span class="c1">#</span>
<span class="c1"># def d(A, psi):</span>
<span class="c1">#</span>
<span class="c1">#     psi = wave function at the current time step</span>
<span class="c1">#</span>
<span class="c1">#     A[0] = c</span>
<span class="c1">#     A[1] = c + c.dag()</span>
<span class="c1">#     A[2] = c - c.dag()</span>
<span class="c1">#     A[3] = c.dag() * c</span>
<span class="c1">#</span>
<span class="c1">#     where c is a collapse operator. The combinations of c&#39;s stored in A are</span>
<span class="c1">#     precomputed before the time-evolution is started to avoid repeated</span>
<span class="c1">#     computations.</span>


<span class="k">def</span> <span class="nf">_generate_psi_A_ops</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">,</span> <span class="n">H</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    pre-compute superoperator operator combinations that are commonly needed</span>
<span class="sd">    when evaluating the RHS of stochastic schrodinger equations</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">A_ops</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c_idx</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">):</span>
        <span class="n">A_ops</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                      <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                      <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                      <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">A_ops</span>


<span class="k">def</span> <span class="nf">d1_psi_homodyne</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    OK</span>
<span class="sd">    Need to cythonize</span>

<span class="sd">    .. math::</span>

<span class="sd">        D_1(C, \psi) = \\frac{1}{2}(\\langle C + C^\\dagger\\rangle\\C psi -</span>
<span class="sd">        C^\\dagger C\\psi - \\frac{1}{4}\\langle C + C^\\dagger\\rangle^2\\psi)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">e1</span> <span class="o">*</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">psi</span><span class="p">)</span> <span class="o">-</span>
                  <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">psi</span><span class="p">)</span> <span class="o">-</span>
                  <span class="mf">0.25</span> <span class="o">*</span> <span class="n">e1</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">psi</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">d2_psi_homodyne</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    OK</span>
<span class="sd">    Need to cythonize</span>

<span class="sd">    .. math::</span>

<span class="sd">        D_2(\psi, t) = (C - \\frac{1}{2}\\langle C + C^\\dagger\\rangle)\\psi</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">psi</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">e1</span> <span class="o">*</span> <span class="n">psi</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">d1_psi_heterodyne</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Need to cythonize</span>

<span class="sd">    .. math::</span>

<span class="sd">        D_1(\psi, t) = -\\frac{1}{2}(C^\\dagger C -</span>
<span class="sd">        \\langle C^\\dagger \\rangle C +</span>
<span class="sd">        \\frac{1}{2}\\langle C \\rangle\\langle C^\\dagger \\rangle))\psi</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">e_C</span> <span class="o">=</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
    <span class="n">e_Cd</span> <span class="o">=</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">psi</span><span class="p">)</span> <span class="o">+</span>
            <span class="mf">0.5</span> <span class="o">*</span> <span class="n">e_Cd</span> <span class="o">*</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">psi</span><span class="p">)</span> <span class="o">-</span>
            <span class="mf">0.25</span> <span class="o">*</span> <span class="n">e_C</span> <span class="o">*</span> <span class="n">e_Cd</span> <span class="o">*</span> <span class="n">psi</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">d2_psi_heterodyne</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Need to cythonize</span>

<span class="sd">        X = \\frac{1}{2}(C + C^\\dagger)</span>

<span class="sd">        Y = \\frac{1}{2}(C - C^\\dagger)</span>

<span class="sd">        D_{2,1}(\psi, t) = \\sqrt(1/2) (C - \\langle X \\rangle) \\psi</span>

<span class="sd">        D_{2,2}(\psi, t) = -i\\sqrt(1/2) (C - \\langle Y \\rangle) \\psi</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">X</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">d2_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">psi</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span> <span class="o">*</span> <span class="n">psi</span><span class="p">)</span>
    <span class="n">d2_2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">psi</span><span class="p">)</span> <span class="o">-</span> <span class="n">Y</span> <span class="o">*</span> <span class="n">psi</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">d2_1</span><span class="p">,</span> <span class="n">d2_2</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">d1_psi_photocurrent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Need to cythonize.</span>

<span class="sd">    Note: requires poisson increments</span>

<span class="sd">    .. math::</span>

<span class="sd">        D_1(\psi, t) = - \\frac{1}{2}(C^\dagger C \psi - ||C\psi||^2 \psi)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">psi</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">norm</span><span class="p">(</span><span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">psi</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">psi</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">d2_psi_photocurrent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Need to cythonize</span>

<span class="sd">    Note: requires poisson increments</span>

<span class="sd">    .. math::</span>

<span class="sd">        D_2(\psi, t) = C\psi / ||C\psi|| - \psi</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">psi_1</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">psi</span><span class="p">)</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">psi_1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">psi_1</span> <span class="o">/</span> <span class="n">n1</span> <span class="o">-</span> <span class="n">psi</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="o">-</span> <span class="n">psi</span><span class="p">]</span>


<span class="c1">#</span>
<span class="c1"># For SME</span>
<span class="c1">#</span>

<span class="c1"># def d(A, rho_vec):</span>
<span class="c1">#</span>
<span class="c1">#     rho = density operator in vector form at the current time stemp</span>
<span class="c1">#</span>
<span class="c1">#     A[_idx_A_L] = spre(a) = A_L</span>
<span class="c1">#     A[_idx_A_R] = spost(a) = A_R</span>
<span class="c1">#     A[_idx_Ad_L] = spre(a.dag()) = Ad_L</span>
<span class="c1">#     A[_idx_Ad_R] = spost(a.dag()) = Ad_R</span>
<span class="c1">#     A[_idx_AdA_L] = spre(a.dag() * a) = (Ad A)_L</span>
<span class="c1">#     A[_idx_AdA_R] = spost(a.dag() * a) = (Ad A)_R</span>
<span class="c1">#     A[_idx_A_LxAd_R] = (spre(a) * spost(a.dag()) = A_L * Ad_R</span>
<span class="c1">#     A[_idx_LD] = lindblad_dissipator(a)</span>

<span class="n">_idx_A_L</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">_idx_A_R</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">_idx_Ad_L</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">_idx_Ad_R</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">_idx_AdA_L</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">_idx_AdA_R</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">_idx_A_LxAd_R</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">_idx_LD</span> <span class="o">=</span> <span class="mi">7</span>


<span class="k">def</span> <span class="nf">_generate_rho_A_ops</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    pre-compute superoperator operator combinations that are commonly needed</span>
<span class="sd">    when evaluating the RHS of stochastic master equations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c_idx</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sc</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">c</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">spre</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">spost</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">spre</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">spost</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">spre</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">spost</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">spre</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">spost</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">()))</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">lindblad_dissipator</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)])</span>

    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">_generate_A_ops_Euler</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    combine precomputed operators in one long operator for the Euler method</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span><span class="n">spre</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">spost</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sc</span><span class="p">]</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">L</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="p">[</span><span class="n">lindblad_dissipator</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sc</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">dt</span><span class="p">]</span>
    <span class="n">out1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">sp</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(),</span> <span class="n">sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
    <span class="c1"># the following hack is required for compatibility with old A_ops</span>
    <span class="n">out1</span> <span class="o">+=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># XXX: fix this!</span>
    <span class="n">out1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">out1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out1</span>


<span class="k">def</span> <span class="nf">_generate_A_ops_Milstein</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    combine precomputed operators in one long operator for the Milstein method</span>
<span class="sd">    with commuting stochastic jump operators.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">spre</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">spost</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sc</span><span class="p">]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="n">temp</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span><span class="n">temp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">temp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)]</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span><span class="n">temp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">temp</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">A_len</span><span class="p">,</span> <span class="n">A_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">]</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">L</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="p">[</span><span class="n">lindblad_dissipator</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sc</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">dt</span><span class="p">]</span>
    <span class="n">out1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">sp</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(),</span> <span class="n">sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
    <span class="c1"># the following hack is required for compatibility with old A_ops</span>
    <span class="n">out1</span> <span class="o">+=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># XXX: fix this!</span>
    <span class="n">out1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">out1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out1</span>


<span class="k">def</span> <span class="nf">_generate_A_ops_simple</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    pre-compute superoperator operator combinations that are commonly needed</span>
<span class="sd">    when evaluating the RHS of stochastic master equations</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">A_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">spre</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">spost</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sc</span><span class="p">]</span>
    <span class="n">tempL</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">lindblad_dissipator</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sc</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="c1"># Lagrangian</span>

    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="n">temp</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span><span class="n">tempL</span><span class="p">]</span>
    
    <span class="n">out1</span> <span class="o">=</span> <span class="p">[</span><span class="n">out</span><span class="p">]</span>
    <span class="c1"># the following hack is required for compatibility with old A_ops</span>
    <span class="n">out1</span> <span class="o">+=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">out1</span>
    
    
<span class="k">def</span> <span class="nf">_generate_A_ops_implicit</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    pre-compute superoperator operator combinations that are commonly needed</span>
<span class="sd">    when evaluating the RHS of stochastic master equations</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">A_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">spre</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">spost</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sc</span><span class="p">]</span>
    <span class="n">tempL</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">lindblad_dissipator</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sc</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="c1"># Lagrangian</span>

    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="n">temp</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">tempL</span><span class="p">]</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span><span class="n">tempL</span><span class="p">]</span>
    
    <span class="n">out1</span> <span class="o">=</span> <span class="p">[</span><span class="n">out</span><span class="p">]</span>
    <span class="c1"># the following hack is required for compatibility with old A_ops</span>
    <span class="n">out1</span> <span class="o">+=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">out1</span>


<span class="k">def</span> <span class="nf">_generate_noise_Milstein</span><span class="p">(</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span> <span class="n">d2_len</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    generate noise terms for the fast Milstein scheme</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dW_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sc_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">dW_temp</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dW_temp</span> <span class="o">*</span> <span class="n">dW_temp</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">*</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">dW_temp</span><span class="p">,</span>
             <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dW_temp</span> <span class="o">*</span> <span class="n">dW_temp</span> <span class="o">-</span>
                    <span class="n">dt</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))]</span> <span class="o">+</span>
            <span class="p">[[</span><span class="n">dW_temp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW_temp</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
              <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">sc_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">]])</span>

    <span class="k">return</span> <span class="n">noise</span>

<span class="k">def</span> <span class="nf">_generate_noise_Taylor_15</span><span class="p">(</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span> <span class="n">d2_len</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    generate noise terms for the strong Taylor 1.5 scheme</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">U1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
    <span class="n">U2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
    <span class="n">dW</span> <span class="o">=</span> <span class="n">U1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> 
    <span class="n">dZ</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dt</span><span class="o">**</span><span class="p">(</span><span class="mf">3.</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">U1</span> <span class="o">+</span> <span class="mf">1.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">U2</span><span class="p">)</span> 

    <span class="k">if</span> <span class="n">sc_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span> <span class="n">dW</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dW</span> <span class="o">*</span> <span class="n">dW</span> <span class="o">-</span> <span class="n">dt</span><span class="p">),</span> <span class="n">dZ</span><span class="p">,</span> <span class="n">dW</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">-</span> <span class="n">dZ</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span> <span class="o">*</span> <span class="n">dW</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">dW</span> <span class="p">])</span>                    
    
    <span class="k">elif</span> <span class="n">sc_len</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span> <span class="n">dW</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dW</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">dt</span><span class="p">),</span> <span class="n">dZ</span><span class="p">,</span> <span class="n">dW</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">-</span> <span class="n">dZ</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span> <span class="o">*</span> <span class="n">dW</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">dW</span><span class="p">]</span> 
                    <span class="o">+</span> <span class="p">[[</span><span class="n">dW</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">sc_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">]]</span>  <span class="c1"># Milstein</span>
                    <span class="o">+</span> <span class="p">[[</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">dW</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">dt</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">sc_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">m</span><span class="p">]])</span>

    <span class="c1">#else:</span>
        <span class="c1">#noise = np.vstack([ dW, 0.5 * (dW**2 - dt), dZ, dW * dt - dZ, 0.5 * (1./3. * dW**2 - dt) * dW] </span>
                    <span class="c1">#+ [[dW[n] * dW[m] for (n, m) in np.ndindex(sc_len, sc_len) if n &gt; m]]  # Milstein</span>
                    <span class="c1">#+ [[0.5 * dW[n] * (dW[m]**2 - dt) for (n, m) in np.ndindex(sc_len, sc_len) if n != m]]</span>
                    <span class="c1">#+ [[dW[n] * dW[m] * dW[k] for (n, m, k) in np.ndindex(sc_len, sc_len, sc_len) if n&gt;m&gt;k]])  </span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;too many stochastic operators&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">noise</span>


<span class="k">def</span> <span class="nf">sop_H</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the superoperator</span>

<span class="sd">    H[a] rho = a rho + rho a^\dagger - Tr[a rho + rho a^\dagger] rho</span>
<span class="sd">            -&gt; (A_L + Ad_R) rho_vec - E[(A_L + Ad_R) rho_vec] rho_vec</span>

<span class="sd">    Need to cythonize, add A_L + Ad_R to precomputed operators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">spmv</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">)</span> <span class="o">-</span> <span class="n">e1</span> <span class="o">*</span> <span class="n">rho_vec</span>


<span class="k">def</span> <span class="nf">sop_G</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the superoperator</span>

<span class="sd">    G[a] rho = a rho a^\dagger / Tr[a rho a^\dagger] - rho</span>
<span class="sd">            -&gt; A_L Ad_R rho_vec / Tr[A_L Ad_R rho_vec] - rho_vec</span>

<span class="sd">    Need to cythonize, add A_L + Ad_R to precomputed operators</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">e1</span> <span class="o">&gt;</span> <span class="mf">1e-15</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">rho_vec</span><span class="p">)</span> <span class="o">/</span> <span class="n">e1</span> <span class="o">-</span> <span class="n">rho_vec</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">rho_vec</span>


<span class="k">def</span> <span class="nf">d1_rho_homodyne</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    D1[a] rho = lindblad_dissipator(a) * rho</span>

<span class="sd">    Need to cythonize</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">rho_vec</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">d2_rho_homodyne</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    D2[a] rho = a rho + rho a^\dagger - Tr[a rho + rho a^\dagger]</span>
<span class="sd">              = (A_L + Ad_R) rho_vec - E[(A_L + Ad_R) rho_vec]</span>

<span class="sd">    Need to cythonize, add A_L + Ad_R to precomputed operators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">spmv</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">)</span> <span class="o">-</span> <span class="n">e1</span> <span class="o">*</span> <span class="n">rho_vec</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">d1_rho_heterodyne</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Need to cythonize, docstrings</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">rho_vec</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">d2_rho_heterodyne</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Need to cythonize, docstrings</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">d1</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">)</span> <span class="o">-</span> <span class="n">e1</span> <span class="o">*</span> <span class="n">rho_vec</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">)</span> <span class="o">-</span> <span class="n">e1</span> <span class="o">*</span> <span class="n">rho_vec</span>
    <span class="k">return</span> <span class="p">[</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">d1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">d2</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">d1_rho_photocurrent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Need to cythonize, add (AdA)_L + AdA_R to precomputed operators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_sum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">n_sum</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">e1</span> <span class="o">*</span> <span class="n">rho_vec</span> <span class="o">-</span> <span class="n">spmv</span><span class="p">(</span><span class="n">n_sum</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">d2_rho_photocurrent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Need to cythonize, add (AdA)_L + AdA_R to precomputed operators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">e1</span><span class="o">.</span><span class="n">real</span> <span class="o">&gt;</span> <span class="mf">1e-15</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">rho_vec</span><span class="p">)</span> <span class="o">/</span> <span class="n">e1</span> <span class="o">-</span> <span class="n">rho_vec</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="n">rho_vec</span><span class="p">]</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Deterministic part of the rho/psi update functions. TODO: Make these</span>
<span class="c1"># compatible with qutip&#39;s time-dependent hamiltonian and collapse operators</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">_rhs_psi_deterministic</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deterministic contribution to the density matrix change</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dpsi_t</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">H</span> <span class="o">*</span> <span class="n">psi_t</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpsi_t</span>


<span class="k">def</span> <span class="nf">_rhs_rho_deterministic</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deterministic contribution to the density matrix change</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">drho_t</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>

    <span class="k">return</span> <span class="n">drho_t</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Euler-Maruyama rhs functions for the stochastic Schrodinger and master</span>
<span class="c1"># equations</span>
<span class="c1">#</span>

<span class="k">def</span> <span class="nf">_rhs_psi_euler_maruyama</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A_ops</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Euler-Maruyama rhs function for wave function solver.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dW_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dW</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
    <span class="n">dpsi_t</span> <span class="o">=</span> <span class="n">_rhs_psi_deterministic</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">a_idx</span><span class="p">,</span> <span class="n">A</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A_ops</span><span class="p">):</span>
        <span class="n">d2_vec</span> <span class="o">=</span> <span class="n">d2</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="n">dpsi_t</span> <span class="o">+=</span> <span class="n">d1</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">+</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">d2_vec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dW_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">psi_t</span> <span class="o">+</span> <span class="n">dpsi_t</span>


<span class="k">def</span> <span class="nf">_rhs_rho_euler_maruyama</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A_ops</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Euler-Maruyama rhs function for density matrix solver.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dW_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dW</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>

    <span class="n">drho_t</span> <span class="o">=</span> <span class="n">_rhs_rho_deterministic</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">a_idx</span><span class="p">,</span> <span class="n">A</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A_ops</span><span class="p">):</span>
        <span class="n">d2_vec</span> <span class="o">=</span> <span class="n">d2</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">d1</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">d2_vec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span>
                          <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dW_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rho_t</span> <span class="o">+</span> <span class="n">drho_t</span>


<span class="k">def</span> <span class="nf">_rhs_rho_euler_homodyne_fast</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">ddW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fast Euler-Maruyama for homodyne detection.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dW</span> <span class="o">=</span> <span class="n">ddW</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">d_vec</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho_t</span><span class="p">))</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">d_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">axis1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">drho_t</span> <span class="o">=</span> <span class="n">d_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dW</span><span class="p">,</span> <span class="n">d_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">dW</span><span class="p">))</span> <span class="o">*</span> <span class="n">rho_t</span>
    <span class="k">return</span> <span class="n">drho_t</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Platen method</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">_rhs_psi_platen</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A_ops</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TODO: support multiple stochastic increments</span>

<span class="sd">    .. note::</span>

<span class="sd">        Experimental.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sqrt_dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>

    <span class="n">dpsi_t</span> <span class="o">=</span> <span class="n">_rhs_psi_deterministic</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">a_idx</span><span class="p">,</span> <span class="n">A</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A_ops</span><span class="p">):</span>
        <span class="c1"># XXX: This needs to be revised now that</span>
        <span class="c1"># dpsi_t is the change for all stochastic collapse operators</span>

        <span class="c1"># TODO: needs to be updated to support mutiple Weiner increments</span>
        <span class="n">dpsi_t_H</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">spmv</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">)</span>

        <span class="n">psi_t_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">psi_t</span> <span class="o">+</span> <span class="n">dpsi_t_H</span> <span class="o">+</span>
                   <span class="n">d1</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">+</span>
                   <span class="n">d2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">psi_t_p</span> <span class="o">=</span> <span class="p">(</span><span class="n">psi_t</span> <span class="o">+</span> <span class="n">dpsi_t_H</span> <span class="o">+</span>
                   <span class="n">d1</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">+</span>
                   <span class="n">d2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sqrt_dt</span><span class="p">)</span>
        <span class="n">psi_t_m</span> <span class="o">=</span> <span class="p">(</span><span class="n">psi_t</span> <span class="o">+</span> <span class="n">dpsi_t_H</span> <span class="o">+</span>
                   <span class="n">d1</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">-</span>
                   <span class="n">d2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sqrt_dt</span><span class="p">)</span>

        <span class="n">dpsi_t</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="mf">0.50</span> <span class="o">*</span> <span class="p">(</span><span class="n">d1</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t_1</span><span class="p">)</span> <span class="o">+</span> <span class="n">d1</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">))</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">+</span>
            <span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span><span class="n">d2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t_p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">d2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t_m</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                    <span class="mi">2</span> <span class="o">*</span> <span class="n">d2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
            <span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span><span class="n">d2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t_p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">d2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t_m</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
            <span class="p">(</span><span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">dt</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt_dt</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">dpsi_t</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Milstein rhs functions for the stochastic master equation</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">_rhs_rho_milstein_homodyne_single</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A_ops</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span>
                                      <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. note::</span>

<span class="sd">        Experimental.</span>
<span class="sd">        Milstein scheme for homodyne detection with single jump operator.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A_ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">d2_vec</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">)</span>
    <span class="n">d2_vec2</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">d2_vec</span><span class="p">)</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">d2_vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">drho_t</span> <span class="o">=</span> <span class="n">_rhs_rho_deterministic</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="p">(</span><span class="n">d2_vec</span> <span class="o">-</span> <span class="n">e1</span> <span class="o">*</span> <span class="n">rho_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">d2_vec2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">e1</span> <span class="o">*</span> <span class="n">d2_vec</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">e2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">e1</span> <span class="o">*</span> <span class="n">e1</span><span class="p">)</span> <span class="o">*</span>
                     <span class="n">rho_t</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dW</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rho_t</span> <span class="o">+</span> <span class="n">drho_t</span>


<span class="k">def</span> <span class="nf">_rhs_rho_milstein_homodyne</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A_ops</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. note::</span>

<span class="sd">        Experimental.</span>
<span class="sd">        Milstein scheme for homodyne detection.</span>
<span class="sd">        This implementation works for commuting stochastic jump operators.</span>
<span class="sd">        TODO: optimizations: do calculation for n&gt;m only</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A_ops</span><span class="p">)</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">A_ops</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A_ops</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)])</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)])</span>

    <span class="n">d1_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">spmv</span><span class="p">(</span><span class="n">A_ops</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">7</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">d2_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">spmv</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)])</span>

    <span class="c1"># This calculation is suboptimal. We need only values for m&gt;n in case of</span>
    <span class="c1"># commuting jump operators.</span>
    <span class="n">d2_vec2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">spmv</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">d2_vec</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
                         <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)])</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">d2_vec</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)])</span>

    <span class="n">drho_t</span> <span class="o">=</span> <span class="n">_rhs_rho_deterministic</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">d1_vec</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([(</span><span class="n">d2_vec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">e1</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">rho_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="p">[(</span><span class="n">d2_vec2</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e1</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">d2_vec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span>
         <span class="p">(</span><span class="o">-</span><span class="n">e2</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e1</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">e1</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">*</span> <span class="n">rho_t</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dW</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">dW</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># This calculation is suboptimal. We need only values for m&gt;n in case of</span>
    <span class="c1"># commuting jump operators.</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="p">[(</span><span class="n">d2_vec2</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="n">e1</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">d2_vec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">e1</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">d2_vec</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span>
         <span class="p">(</span><span class="o">-</span><span class="n">e2</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e1</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">e1</span><span class="p">[</span><span class="n">m</span><span class="p">])</span> <span class="o">*</span> <span class="n">rho_t</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dW</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
         <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">A_len</span><span class="p">,</span> <span class="n">A_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">m</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rho_t</span> <span class="o">+</span> <span class="n">drho_t</span>


<span class="k">def</span> <span class="nf">_rhs_rho_milstein_homodyne_single_fast</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">ddW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span>
                                           <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    fast Milstein for homodyne detection with 1 stochastic operator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ddW</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="n">d_vec</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho_t</span><span class="p">))</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
        <span class="n">d_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">axis1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

    <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">drho_t</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">dW</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho_t</span>
    <span class="n">dW</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">d_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dW</span><span class="p">,</span> <span class="n">d_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">rho_t</span> <span class="o">+</span> <span class="n">drho_t</span>


<span class="k">def</span> <span class="nf">_rhs_rho_milstein_homodyne_two_fast</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">ddW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    fast Milstein for homodyne detection with 2 stochastic operators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ddW</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="n">d_vec</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho_t</span><span class="p">))</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
        <span class="n">d_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">axis1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">d_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">e</span><span class="p">[:</span><span class="mi">2</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">d_vec</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

    <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">e</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">drho_t</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">dW</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho_t</span>
    <span class="n">dW</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>

    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">d_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dW</span><span class="p">,</span> <span class="n">d_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">rho_t</span> <span class="o">+</span> <span class="n">drho_t</span>


<span class="k">def</span> <span class="nf">_rhs_rho_milstein_homodyne_fast</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">ddW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    fast Milstein for homodyne detection with &gt;2 stochastic operators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ddW</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">sc_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">sc2_len</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sc_len</span>

    <span class="n">d_vec</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho_t</span><span class="p">))</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">d_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">axis1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">d_vec</span><span class="p">[</span><span class="n">sc2_len</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_vec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_vec</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
         <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">sc_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">])</span>

    <span class="n">e</span><span class="p">[</span><span class="n">sc_len</span><span class="p">:</span><span class="n">sc2_len</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">[:</span><span class="n">sc_len</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span><span class="p">[:</span><span class="n">sc_len</span><span class="p">]</span>
    <span class="n">e</span><span class="p">[</span><span class="n">sc2_len</span><span class="p">:]</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">sc_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">])</span>

    <span class="n">drho_t</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">dW</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho_t</span>
    <span class="n">dW</span><span class="p">[:</span><span class="n">sc_len</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">[:</span><span class="n">sc_len</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="n">sc_len</span><span class="p">:</span><span class="n">sc2_len</span><span class="p">]</span>

    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">d_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dW</span><span class="p">,</span> <span class="n">d_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">rho_t</span> <span class="o">+</span> <span class="n">drho_t</span>


<span class="k">def</span> <span class="nf">_rhs_rho_taylor_15_one</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">ddW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span>
                                           <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    strong order 1.5 Tylor scheme for homodyne detection with 1 stochastic operator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dW</span> <span class="o">=</span> <span class="n">ddW</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1">#reusable operators and traces</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">rho_t</span>
    <span class="n">e0</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">rho_t</span> <span class="o">-</span> <span class="n">e0</span> <span class="o">*</span> <span class="n">rho_t</span>
    <span class="n">TrAb</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">Lb</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">TrAb</span> <span class="o">*</span> <span class="n">rho_t</span> <span class="o">-</span> <span class="n">e0</span> <span class="o">*</span> <span class="n">b</span>
    <span class="n">TrALb</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Lb</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">TrAa</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">drho_t</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">Lb</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># Milstein term</span>

    <span class="c1"># new terms: </span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span> <span class="o">-</span> <span class="n">TrAa</span> <span class="o">*</span> <span class="n">rho_t</span> <span class="o">-</span> <span class="n">e0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">-</span> <span class="n">TrAb</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">dt</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Lb</span> <span class="o">-</span> <span class="n">TrALb</span> <span class="o">*</span> <span class="n">rho_t</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">TrAb</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">e0</span> <span class="o">*</span> <span class="n">Lb</span><span class="p">)</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> 
        
    <span class="k">return</span> <span class="n">rho_t</span> <span class="o">+</span> <span class="n">drho_t</span>

<span class="c1">#include _rhs_rho_Taylor_15_two#</span>

<span class="k">def</span> <span class="nf">_rhs_rho_milstein_implicit</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">ddW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Drift implicit Milstein (theta = 1/2, eta = 0)</span>
<span class="sd">    Wang, X., Gan, S., &amp; Wang, D. (2012). </span>
<span class="sd">    A family of fully implicit Milstein methods for stiff stochastic differential </span>
<span class="sd">    equations with multiplicative noise. </span>
<span class="sd">    BIT Numerical Mathematics, 52(3), 741–772.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">dW</span> <span class="o">=</span> <span class="n">ddW</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    

    <span class="c1">#reusable operators and traces</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">rho_t</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">e0</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">rho_t</span> <span class="o">-</span> <span class="n">e0</span> <span class="o">*</span> <span class="n">rho_t</span>
    <span class="n">TrAb</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">drho_t</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">a</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">TrAb</span> <span class="o">*</span> <span class="n">rho_t</span> <span class="o">-</span> <span class="n">e0</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># Milstein term</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">rho_t</span>

    <span class="n">v</span><span class="p">,</span> <span class="n">check</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">bicgstab</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">drho_t</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">drho_t</span> <span class="o">+</span> <span class="n">a</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;tol&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">v</span>
    
<span class="k">def</span> <span class="nf">_rhs_rho_taylor_15_implicit</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">ddW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Drift implicit Taylor 1.5 (alpha = 1/2, beta = doesn&#39;t matter)</span>
<span class="sd">    Chaptert 12.2 Eq. (2.18) in Numerical Solution of Stochastic Differential Equations</span>
<span class="sd">    By Peter E. Kloeden, Eckhard Platen</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">dW</span> <span class="o">=</span> <span class="n">ddW</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1">#reusable operators and traces</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">rho_t</span>
    <span class="n">e0</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">rho_t</span> <span class="o">-</span> <span class="n">e0</span> <span class="o">*</span> <span class="n">rho_t</span>
    <span class="n">TrAb</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">Lb</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">TrAb</span> <span class="o">*</span> <span class="n">rho_t</span> <span class="o">-</span> <span class="n">e0</span> <span class="o">*</span> <span class="n">b</span>
    <span class="n">TrALb</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Lb</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">TrAa</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">drho_t</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">Lb</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># Milstein term</span>
    <span class="n">xx0</span> <span class="o">=</span> <span class="p">(</span><span class="n">drho_t</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho_t</span> <span class="c1">#starting vector for the linear solver (Milstein prediction)</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span>

    <span class="c1"># new terms: </span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="n">dW</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dW</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span> <span class="o">-</span> <span class="n">TrAa</span> <span class="o">*</span> <span class="n">rho_t</span> <span class="o">-</span> <span class="n">e0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">-</span> <span class="n">TrAb</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="n">drho_t</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Lb</span> <span class="o">-</span> <span class="n">TrALb</span> <span class="o">*</span> <span class="n">rho_t</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">TrAb</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">e0</span> <span class="o">*</span> <span class="n">Lb</span><span class="p">)</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">rho_t</span>

    <span class="n">v</span><span class="p">,</span> <span class="n">check</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">bicgstab</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">drho_t</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">xx0</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;tol&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">v</span>
    
<span class="k">def</span> <span class="nf">_rhs_rho_pred_corr_homodyne_single</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">ddW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span>
                                           <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dW</span> <span class="o">=</span> <span class="n">ddW</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    
    <span class="c1">#predictor</span>

    <span class="n">d_vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">rho_t</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho_t</span><span class="p">))</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
        <span class="n">d_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">axis1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

    <span class="n">a_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">d_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">b_pred</span> <span class="o">=</span> <span class="o">-</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">rho_t</span>
    <span class="n">b_pred</span> <span class="o">+=</span> <span class="n">d_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">pred_rho_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">a_pred</span><span class="p">)</span>
    <span class="n">pred_rho_t</span> <span class="o">+=</span> <span class="n">b_pred</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pred_rho_t</span> <span class="o">+=</span> <span class="n">rho_t</span>

    <span class="n">a_pred</span> <span class="o">-=</span> <span class="p">((</span><span class="n">d_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">rho_t</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">b_pred</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
    
    <span class="c1">#corrector</span>

    <span class="n">d_vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pred_rho_t</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho_t</span><span class="p">))</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
        <span class="n">d_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">axis1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

    <span class="n">a_corr</span> <span class="o">=</span> <span class="n">d_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">b_corr</span> <span class="o">=</span> <span class="o">-</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pred_rho_t</span>
    <span class="n">b_corr</span> <span class="o">+=</span> <span class="n">d_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">a_corr</span> <span class="o">-=</span> <span class="p">((</span><span class="n">d_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pred_rho_t</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">b_corr</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">a_corr</span> <span class="o">+=</span> <span class="n">a_pred</span>
    <span class="n">a_corr</span> <span class="o">*=</span> <span class="mf">0.5</span>

    <span class="n">b_corr</span> <span class="o">+=</span> <span class="n">b_pred</span>
    <span class="n">b_corr</span> <span class="o">*=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">corr_rho_t</span> <span class="o">=</span> <span class="n">a_corr</span>
    <span class="n">corr_rho_t</span> <span class="o">+=</span> <span class="n">b_corr</span>
    <span class="n">corr_rho_t</span> <span class="o">+=</span> <span class="n">rho_t</span>

    <span class="k">return</span> <span class="n">corr_rho_t</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.
      Last updated on Jul 14, 2017.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'4.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>